<html>
<head>
  <title>一、Servlet规范</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2106"/>
<h1>一、Servlet规范</h1>

<div>
<span><div><span style="font-weight: bold;">一、Servlet规范</span></div><div>    1、servlet规范来自于JAVAEE规范中的一种</div><div>    2、作用：1.&gt;在servlet规范中，指定【动态资源文件】开发步骤</div><div>                    2.&gt;在servlet规范中，指定Http服务器调用动态资源文件规则</div><div>                    3.&gt;在servlet规范中，指定Http服务器管理动态资源文件实例对象规则</div><div><br/></div><div><span style="font-weight: bold;">二、servlet</span></div><div>    1、Servlet接口来自于Servlet规范下一个接口，这个接口存在于Http服务器提供的jar包中。</div><div>    2、Tomcat服务器lib文件有一个servlet-api.jar存放servlet接口。（javax.servlet.Servlet接口）</div><div><img src="一、Servlet规范_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>    3、Servlet规范中认为，Http服务器能调用的【动态资源文件】必须是一个Servlet接口的实现类</div><div><br/></div><div><span style="font-weight: bold;">二、Tomcat根据Servlet规范调用Servlet接口实现类规则：</span></div><div>    1、Tomcat 有权创建Servlet接口实现类实例对象；</div><div>        Servlet oneServlet=new OneServlet();</div><div>    2、Tomcat根据实例对象调用service方法处理当前请求</div><div>            oneServlet.service();</div><div><br/></div><div> <span style="font-weight: bold;"> </span><span style="font-weight: bold;">三、Servlet接口实现类开发步骤</span></div><div>    第一步：通过继承HttpServlet 父类来创建一个Servlet接口实现类（抽象类降低接口实现类实现接口的难度）</div><div><img src="一、Servlet规范_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>                类名 extends HttpServlet implements Servlet</div><div>    第二步：根据浏览器发送的请求方式，重写父类中doGet或者doPost方法来处理请求</div><div>    第三步：到网站的核心配置文件（web.xml）向Tomcat注册动态资源文件</div><div><img src="一、Servlet规范_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>        1、将Servlet接口实现类类路径地址交给Tomcat</div><div>                &lt;servlet&gt;</div><div>                        &lt;servlet-name&gt;变量名&lt;/servlet-name&gt;&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</div><div>                        &lt;servlet-class&gt;类路径&lt;/servlet-class&gt;&lt;!--声明servlet接口实现类路径--&gt;</div><div>                &lt;/servlet&gt;</div><div>            &lt;!--为了降低用户访问Servlet接口实现类的难度，需要设置简短的请求别名--&gt;</div><div>            &lt;servlet-mapping&gt;</div><div>                    &lt;servlet-name&gt;变量名&lt;/servlet-name&gt;</div><div>                    &lt;url-pattern&gt;/one&lt;/url-pattern&gt;&lt;!--设置请求别名，必须以‘/’为开头--&gt;</div><div>            &lt;/servlet-mapping&gt;</div><div><br/></div><div><span style="font-weight: bold;">四、Servlet对象生命周期</span></div><div>        1、网站中所有Servlet接口实现类的实例对象，只能由Http服务器负责创建，开发人员不能手动创建Servlet接口实现类的实例对象    </div><div>        2、在默认的情况下，Http服务器接收到对当前Servlet接口实现类的第一次请求时，自动创建Servlet接口实现类的实例对象。</div><div>            在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</div><div>                &lt;servlet&gt;</div><div>                        &lt;servlet-name&gt;变量名&lt;/servlet-name&gt;&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</div><div>                        &lt;servlet-class&gt;类路径&lt;/servlet-class&gt;&lt;!--声明servlet接口实现类路径--&gt;</div><div>                        &lt;load-on-startup&gt;10&lt;/load-on-startup&gt;&lt;标签默认值是0，填写一个大于0的整数表示自动创建该实例对象&gt;</div><div>                &lt;/servlet&gt;</div><div>        3、在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象。</div><div>        4、在Http服务器关闭的时刻，自动将网站中所有的Servlet实例对象销毁。</div><div><br/></div><div><span style="font-weight: bold;">五、idea快速创建Servlet接口实现类</span></div><div>    src---&gt;new---&gt;Servlet---&gt;填写类地址信息---&gt;没掉左下角的√</div><div>（Create java EE6 annotated class）</div><div><span style="font-weight: bold;">六、HttpServletResponse接口</span></div><div>  <span style="font-weight: bold;">1.介绍：</span>      1、HttpServletResponse接口来自Servlet规范中，存在于Tomcat服务器中servlet-api.jar中的javax.servlet.http</div><div>                2、HttpServletResponse接口实现类由Http服务器负责提供</div><div>                3、HttpServletResponse接口负责doGet，doPost方法执行结果写入【响应体】交给浏览器</div><div>                4、开发人员习惯于将HttpServletResponse接口修饰的对象称为 <span style="font-weight: bold;">【响应对象】</span></div><div>    <span style="font-weight: bold;">2.主要功能</span>：</div><div>            1、将执行结果以二进制形式写入到【响应体】</div><div>            2、设置响应头中【content-type】属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</div><div>            3、设置响应头【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求。</div><div>  <span style="font-weight: bold;">  3、对请求响应(功能一)</span></div><div><span style="font-weight: bold;">        String result=&quot;Hello World&quot;;</span></div><div>        1、通过响应对象，向Tomcat索要输出流</div><div>            PrintWriter out= response.getWriter();</div><div>        2、通过输出流，将执行结果以二进制写入响应体</div><div>            out.print(result);</div><div>    <span style="font-weight: bold;">4、</span><span style="font-weight: bold;">设置响应头中【content-type】属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】（功能二）</span></div><div>        在得到输出流之前，通过content-type属性进行一次重新赋值用于指定浏览器采用正确编译器（默认编译器为文本编译器）</div><div>    response.setContentType(&quot;text/html;charset=utf-8&quot;);</div><div><span style="font-weight: bold;">5、设置响应头【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求。（功能三）</span></div><div>            String result=&quot;http://www.baidu.com?name=value&quot;;</div><div>            response.sendRediredt(result);//[响应头 location=&quot;<a href="http://www.baidu.com/">http://www.baidu.com</a>&quot;]</div><div><img src="一、Servlet规范_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">七：HttpServletRequest接口</span></div><div>  <span style="font-weight: bold;">1.介绍：</span>      1、HttpServletResponse接口来自Servlet规范中，存在于Tomcat服务器中servlet-api.jar中的javax.servlet.http</div><div>                    2、HttpServletResponse接口实现类由Http服务器负责提供</div><div>                    3、HttpServletResponse接口负责在doGet/doPost方法运行时读取Http请求协议包中的信息</div><div>                    4、开发人员习惯于将HttpSevvletRequest接口修饰的对象称为<span style="font-weight: bold;">【请求对象</span><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">】</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    2.作用：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                    1、读取Http请求协议包中【请求行】信息</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                    2、读取保存在Http协议请求协议包中【请求头】或者【请求体】中的参数信息    </span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                    3、可以代替浏览器向Http服务器申请资源文件调用</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    3、</span><span style="font-size: unset; color: unset; font-family: unset;">读取Http请求协议包中【请求行】信息</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            String url=request.getRequestURL().toString();</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            String method=request.getMethod();</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            String uri=</span><span style="font-size: unset; color: unset; font-family: unset;">request.getRequestURL();//对被访问文件做精准定位</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    4、</span><span style="font-size: unset; color: unset; font-family: unset;">读取保存在Http协议请求协议包中【请求头】或者【请求体】中的参数信息</span><span style="font-size: unset; color: unset; font-family: unset;">    </span></div><div><img src="一、Servlet规范_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="一、Servlet规范_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用UTF-8字符集对请求体内容进行一次重新解码。</div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: common-ligatures;">    request.setCharacterEncoding();代码修改字符集编码。</span></div><div><span style="font-weight: bold;">八、请求对象和响应对象的生命周期</span></div><div><span style="font-weight: bold;">    1、在Http服务器在接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</span></div><div><span style="font-weight: bold;">    2、在Http服务器调用doGet/doPost方法时，Http服务器负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</span></div><div><span style="font-weight: bold;">    3、在Http服务器准备推送Http响应协议包之前，会将本次请求关联的【请求对象】和【响应对象】负责销毁。</span></div><div><br/></div><div><span style="font-weight: bold;">九、欢迎资源文件</span></div><div>    1、前提：用户可以记住网站名，但不会记住资源名。</div><div>    2、默认欢迎资源文件：用户发送了一个针对某个网站【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件。</div><div>    3、Tomcat对于默认欢迎资源文件定位规则</div><div>        1、规则位置：Tomcat安装位置/conf/web.xml---&gt;最下方</div><div><img src="一、Servlet规范_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>    2、规则命令：</div><div>        &lt;welcome-file-list&gt;</div><div>                &lt;welcome-file&gt;index.html&lt;welcome-file&gt;</div><div>                &lt;welcome-file&gt;index.htm&lt;welcome-file&gt;</div><div>                &lt;welcome-file&gt;index.jsp&lt;welcome-file&gt;</div><div>        &lt;/welcome-file-list&gt;</div><div>    3、设置当前网站的默认欢迎资源文件规则</div><div>        1&gt;规则位置：网站/web/WEB-INF/web.xml</div><div>        2&gt;规则命令：</div><div>          &lt;welcome-file-list&gt;</div><div>                &lt;welcome-file&gt;login.html&lt;welcome-file&gt;</div><div>        &lt;/welcome-file-list&gt;</div><div>        3&gt;若用户网站设置了自定义欢迎页面命令，Tomcat欢迎资源文件命令将失效</div><div>        4&gt;servlet文件在作为默认欢迎页面时，‘/’必须抹掉。</div><div><span style="font-weight: bold;">十、Htttp状态码</span></div><div>        1、介绍：</div><div>                1&gt;由三为数字组成的一个符号。</div><div>                2&gt;Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上。</div><div>                3&gt;如果Http服务器针对本次请求，反回了对应的资源文件 ，通过Http状态码通知浏览器应该如何处理这个结果。</div><div>                如果Http服务器针对本次请求，无法返回对应的资源文件，通过Http状态码向浏览器解释不能提供服务的原因。</div><div>        2、分类：</div><div>                1&gt;组成 100---599：分为五个大类</div><div>                2&gt;1xx:</div><div>                        100(最有特征):通知浏览器本次返回的资源文件不是一个独立的资源文件，需要浏览器在接收到响应包之后，继续向Http服务器索要依赖的其他资源文件。</div><div><img src="一、Servlet规范_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>                3&gt;2xx:</div><div>                        200(最有特征):通知浏览器本次返回的资源文件是一个完整的独立资源文件，浏览器在接收到之后不需要索要其他关联文件。</div><div>                4&gt;3xx:</div><div>                        302(最有特征):通知浏览器本次返回的不是一个资源文件的内容，而是一个资源文件的地址，需要浏览器根据这个地址自动的发起请求来索要这个资源文件。</div><div>                       respon.sendRedirect(&quot;资源文件地址&quot;)写入响应头中location,z这个行为导致Tomcat将302状态码写入状态行中。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Tomcat在推送响应包之前，看到响应体是空的，响应头location存放了一个地址，Tomcat将302状态码写入到状态行中;</div><div>浏览器在接收到响应包之后，因为302状态码，浏览器不会读取响应体内容，自动根据响应头中location中的地址发送请求；</div></div><div>                5&gt;4xx</div><div>                        404:通知浏览器，由于服务端没有定位到被访问的资源文件，因此无法提供帮助。</div><div>                        405:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理</div><div>                6&gt;sxx</div><div>                        500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于JAVA异常导致处理失败</div><div><br/></div><div><span style="font-weight: bold;">十一、多个Servlet之间调用规则：</span></div><div>        1、前提条件：</div><div>                                某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。增加了用户获得服务的难度。</div><div>        2、提高用户使用感受规则：</div><div>                                无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发送一次请求即可。</div><div>        3、多个Servlet之间调用规则：</div><div>                    1&gt;重定向解决方案</div><div>                           原理：</div><div><img src="一、Servlet规范_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>                 </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>一、实现命令：response.sendRedirect(&quot;请求地址&quot;);</div><div><font face="Monaco">将地址写入到响应包中响应头中location属性</font></div><div><font face="Monaco">二、特征：</font></div><div><font face="Monaco">        1&gt;请求地址：即可以是当前网站内部资源文件地址</font><span style="font-family: Monaco;">，也可以是其他网站资源文件地址</span></div><div><span style="font-family: Monaco;">        2&gt;请求次数：浏览器至少发送两次请求，但只有第一次请求是用户手动发送的，后续请求都是浏览器自动发送的；</span></div><div><span style="font-family: Monaco;">        3&gt;请求方式：后续请求都为【</span>GET<span style="font-family: Monaco;">】方式。</span></div><div><span style="font-family: Monaco;">        4&gt;缺点：1、重定向解决方案需要在浏览器与服务器之间多次往返，大量时间浪费在往返次数上，增加用户等待服务时间。</span></div></div><div><br/></div><div>                    2&gt;请求转发解决方案</div><div>                            原理：用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomact在接收到这个请求之后，自动调用TwoServlet来完成剩余任务。</div><div><img src="一、Servlet规范_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>一、实现命令：请求对象代替浏览器向Tomcat发送请求</div><div>    1、通过当前请求对象生成资源文件申请报告对象</div><div>     RequestDispatcher report= request.getRequestDispatcher(&quot;/资源文件名&quot;)//一定要以'/'开头</div><div>    2、将报告对象发送给Tomcat</div><div>      report.forward(当前请求对象，当前响应对象);</div><div>二、特征：</div><div>        1、请求次数：浏览器只发送一次请求；</div><div>        2、请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址，不能调用其他网站资源文件；</div><div>        request.getRequestDispathcer(&quot;/资源文件名&quot;);</div><div>            注意：不要写网站名。</div><div>        3、请求方式：在请求转发解决方案，实际上是所有的Servlet共享一个请求协议包，之后的请求方式取决于用户第一次的请求方式。</div><div>三、优点：Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数，增加处理服务速度。</div></div><div><span style="font-weight: bold;">十二、多个Servlet之间数据共享实现方案：</span></div><div>            1、数据共享：OneServlet工作完毕后，将产生数据交给Twoservlet来使用。</div><div>            2、Servlet规范中提供四种数据共享的方案</div><div>                    1&gt;ServletContext接口</div><div>                    2&gt;Cookie类</div><div>                    3&gt;HttpSession接口</div><div>                    4&gt;HttpServletRequest接口</div><div><span style="font-weight: bold;">十三、ServletContext接口：</span></div><div>            1、介绍：</div><div>                    1&gt;来自于Servlet规范中的一个接口。在Tomcat中存在servlet-api.jar,在Tomcat中负责提供这个接口实现类</div><div>                    2&gt;如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享</div><div>                    3&gt;开发人员习惯于将ServletContext对象称为【全局作用域对象】</div><div>            2、工作原理：每一个网站都存在一个全局作用域对象，这个全局作用域对象相当于一个【Map】，在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中的其他Servlet此时都可从全局作用域对象中得到这个数据进行使用。</div><div><img src="一、Servlet规范_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>           3、全局作用域对象生命周期：</div><div>                    1、在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象。</div><div>                    2、在Http服务器运行期间，一个网站只有一个全局作用域对象。</div><div>                    3、在Http服务器运行期间，全局作用域对象一直处于存活状态。</div><div>                    4、在Http服务器准备关闭的时候，服务器负责将当前网站中的全局作用域对象进行销毁处理。</div><div>（全局作用域对象生命周期贯穿网站整个运行期间）</div><div>            4、命令实现：【同一个网站】OneServlet将数据共享给TwoServlet</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>OneServlet{</div><div>    public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>    //1、通过【请求对象】向Tomcat索要当前网站中的【全局作用域对象】</div><div>ServletContext application= request.getServletContext();</div><div>    //2、将数据添加到全局作用域对象中作为【共享数据】</div><div>application.setAttribute(&quot;key1&quot;,数据);</div><div>}</div><div><br/></div><div>}</div><div>TwoServlet{</div><div>    public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>    //1、通过【请求对象】向Tomcat索要当前网站中的【全局作用域对象】</div><div>ServletContext application= request.getServletContext();</div><div>    //2、从全局作用域对象得到指定关键字对应数据</div><div>Object object=qpplication.getAttribute(&quot;key1&quot;);</div><div>}</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//全局作用域对象不能无限使用，会占用太多服务器内存，在公司实际开发过程中一般由高级工程师将关键数据放入全局作用域对象中，初级程序员只负责取数据并使用数据。</span></div></div><div>十四、Cookie</div><div>            1、介绍：</div><div>                    1&gt;Cookie来自于Servlet规范中的一个工具类，存在于Tomcat提供的servlet-api.jar中。</div><div>                    2&gt;如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时可以借助于Cookie对象进行数据共享</div><div>                    3&gt;Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。</div><div>                    4&gt;在现实生活场景中，Cookie相当于用户在服务端得到的【会员卡】</div><div>            2、原理：</div><div>                    用户通过浏览器第一次向MyWeb网站发送请求OneServlet。OneServlet在运行期间创建一个Cookie存储当前用户相关数据，OneServlet工作完毕后， 将Cookie写入【<span style="font-weight: bold;">响应头</span>】交还给当前浏览器。</div><div>                    浏览器收到响应包之后，将Cookie存储在浏览器的缓存中，一段时间之后，用户通过同一个浏览器再次向MyWeb网站发送请求TwoServlet时，浏览器需要无条件的将MyWeb网站之前推送过来的 Cookie写入到<span style="font-weight: bold;">请求头</span>中发送到服务器。</div><div>                    TwoServlet在运行时，就可以通过读取请求头中 Cookie中的信息，得到OneServlet提供的共享数据。</div><div><img src="一、Servlet规范_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>        3、实现命令：同一个网站OneServlet与TwoServlet借助于Cookie实现数据共享</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>OneServlet{</div><div>    public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>    //1、创建一个Cookie对象，保存共享数据（当前用户数据）</div><div>        Cookie card=new Cookie(&quot;key1&quot;,&quot;abc&quot;);</div><div>        //Cookie相当于一个map</div><div>        //一个Cookie中只能存放一个键值对</div><div>        //这个键值对的key与value只能是 String</div><div>        //键值对中key不能是中文</div><div>    //2、将Cookie写入到响应头中，交给浏览器</div><div>        response.addCookies(card);</div><div>   }</div><div>}</div><div><font face="Monaco">浏览器/用户&lt;-----------响应包【200】</font></div><div><font face="Monaco">                                                【Cookie：key1=abc】</font></div><div><font face="Monaco">                                                【】</font></div><div><font face="Monaco">                                                【处理结果】</font></div><div><font face="Monaco">浏览器向MyWeb网站发送请求访问TwoServlet---&gt;请求包【url:/MyWeb/two method:get】</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">【请求参数：xxxx</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Cookie key1=abc</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    】</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">【】</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">【】</span></div><div><font face="Monaco">TwoServlet{</font></div><div><font face="Monaco">    </font>public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>    //1、调用请求对象从请求头得到浏览器返回的Cookie</div><div>    Cookie cookieArray[]=request.getCookies();</div><div>    //2、循环遍历数据得到每一个Cookie的key与value</div><div>    for(Cookie card:cookieArray){</div><div>        String key=card.getname();//读取key</div><div>        String value=card.getValue();//读取value &quot;abc&quot;</div><div>}</div><div>}</div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">}</font></div></div><div>            4、Cookie销毁时机：</div><div>                    1、在默认情况下，Cookie对象存放在浏览器的缓存中，因此只要浏览器关闭，Cookie对象就被销毁掉。</div><div>                    2、在手动设置情况下，可以要求浏览器接收的Cookie存放在客户端计算机的硬盘上，同时需要去指定Cookie在硬盘上的存活时间。在存活时间范围内，关闭浏览器，关闭计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>cookie.setMaxAge(60);//cookie在硬盘上存活一分钟</div></div><div><br/></div><div>十五、HttpSession接口：</div><div>            1、介绍：</div><div>                    1&gt;HttpSession接口来自于Servlet规范下一个接口。存活于Tomcat中servlet-api.jar，其实现类由Http服务器提供，Tomcat提供实现类存在于servlet-api.jar</div><div>                    2&gt;如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时可以借助于HttpSession对象进行数据共享</div><div>                    3&gt;开发人员习惯于将HttpSession接口修饰对象称为【会话作用域对象】</div><div>            2、HttpSession与Cookie区别【面试题】</div><div>                    1&gt;存储位置：Cookie：存放在客户端计算机（浏览器内存/硬盘）</div><div>                                        HttpSession：存放在服务端计算机内存中</div><div>                    2&gt;数据类型：</div><div>                                        Cookie：存储数据只能是String</div><div>                                        HttpSession对象可以存储任意类型的共享数据Object</div><div>                    3&gt;数据数量：Cookie：一个Cookie只能存储一个共享数据    </div><div>                                        HttpSession使用map集合存储共享数据，可以存储任意数量共享数据。</div><div>                    4&gt;参照物不同：Cookie相当于客户在服务端的【会员卡】</div><div>                                            HttpSession相当于客户在服务端的【私人保险柜】</div><div>            3、命令实现：同一个网站下OneServlet将数据传递给TwoServlet</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>OneServlet{</div><div>    public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>   //1、调用请求对象向Tomcat索要当前对象在服务端的私人储物柜</div><div>        HttpSession session=request.getSession();</div><div>    //2、将数据添加到用户私人储物柜</div><div>        session.setAttribute(&quot;key1&quot;,共享数据);</div><div>  }</div><div>}</div><div><font face="Monaco">浏览器访问/myweb中TwoServlet</font></div><div><font face="Monaco">TwoServlet{</font></div><div><font face="Monaco">        </font>  public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>   //1、调用请求对象向Tomcat索要当前对象在服务端的私人储物柜</div><div>        HttpSession session=request.getSession();</div><div>    //2、从会话作用域对象得到OneServlet提供的共享数据</div><div>        Object 共享数据=session.getAttribute(&quot;key1&quot;);</div><div>-------</div><div>    //2、将session中所有的key读取出来，存放一个枚举对象</div><div>  Enumeration goodsNames= seeion.getAttributeNames();</div><div>    while(goodsName.hasMoreElements()){</div><div>        Object object=goodsName.nextElement();</div><div>        Odject value=session.getAttribute(goodsName);</div><div>        }</div><div>    }</div><div><font face="Monaco">}</font></div></div><div>            4、Http服务器如何区分不同用户的HttpSession</div><div>                    cookie</div><div><img src="一、Servlet规范_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>            5、getSession()与getSession(false)</div><div>                     1&gt;getSession():如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜返回。如果当前用户尚未拥有自己的私人储物柜，要求Tomcat为当前用户创建一个全新的私人储物柜。</div><div>                    2&gt;getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜返回。如果当前用户尚未拥有自己的私人储物柜，此时Tomcat将返回null。</div><div>            6、HttpSession销毁时机：</div><div>                    1&gt;用户与HttpSession 关联时使用的Cookie只能存放在浏览器缓存中。</div><div>                    2&gt;在浏览器关闭时，意味着用户与他的HttpSession关系被切断了</div><div>                    3&gt;由于Tomcat无法检测客户端浏览器何时关闭，因此在浏览器关闭时，并不会导致Tomcat将浏览器关联的HttpSession进行销毁</div><div>                    4&gt;为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，这个空闲时间默认是30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat就认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁掉这个HttpSession。</div><div>            7、HttpSession空闲时间手动设置</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>在当前网站/web/WEB-INF/web.xml</div><div>&lt;session-config&gt;</div><div>    &lt;!--当前网站中每一个Session最大空闲时间5分钟--&gt;</div><div>    &lt;session-timeout&gt;5&lt;/session-timeout&gt;</div><div>&lt;/session-config&gt;</div></div><div>十六、HttpServletRequest接口实现数据共享</div><div>            1、介绍：</div><div>                    1&gt;在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享一个请求协议包。而一个请求协议包只对应一个请求对象，因此servlet之间共享同一个请求对象</div><div>，此时可以利用这个请求对象在两个Servlet之间实现数据共享。</div><div>                    2&gt;在请求对象实现Servlet之间实现数据共享功能时，开发人员将请求对象称为【请求作用域对象】</div><div>            2、命令实现：OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>OneServlet{</div><div>    public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>   //1、将数据添加到【请求作用域对象】中 attribute属性</div><div>    request.setAttribute(&quot;key1&quot;,数据);//这个数据可以是任意类型数据（Object）</div><div>    //2、向Tomcat申请调用TwoServlet</div><div>    request.getRequestDispatcher(&quot;/two&quot;).forward(request,response);</div><div>  }</div><div>}</div><div>TwoServlet{</div><div>          public void doGet(HttpServletRequest request,HttpServletResponse response){</div><div>     //从当前请求对象得到OneServlet写入的数据</div><div>    Object s数据=request.getAttribute(&quot;key1&quot;); </div><div>    }</div><div>}</div></div><div>十七、Servlet规范扩展---------监听器接口</div><div>        1、介绍：</div><div>                    1&gt;一组来自Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包</div><div>                    2&gt;监听器接口需要由开发人员亲自实现，Http服务器提供的jar包并没有对应的实现类</div><div>                    3&gt;监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据的变化时刻】</div><div><br/></div><div>        2、作用域对象：</div><div>                1&gt;在Servlet规范中认为在服务端可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</div><div>                2&gt;Servlet规范下作用域对象：</div><div>                        ServletContext：全局作用域对象</div><div>                        HttpSession：会话作用域对象</div><div>                        ServletHttpRequset：请求作用域对象</div><div>        3、监听器接口实现类开发规范：三步</div><div>                1&gt;根据监听的实际情况，选择对应监听器接口进行实现</div><div>                2&gt;重写监听器接口中声明的【监听事件处理方法】</div><div>                3&gt;在web.xml文件将 监听器接口实现类注册到Http服务器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;Listener&gt;</div><div>    &lt;Listener-class&gt;监听器接口实现类路径&lt;/Listener-class&gt;</div><div>&lt;/Listener&gt;</div></div><div>        4、ServletContextListener接口 ：</div><div>                1&gt;作用：通过这个借口合法的检测全局作用域对象被初始化时刻以及被销毁时刻</div><div>                2&gt;监听事件处理方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void contextInitLized():在全局作用域对象被Http服务器初始化时调用</div><div>public void contextDestory():在全局作用域对象被Http服务器销毁的时候触发调用</div></div><div>        5、ServletContextAttributeListener接口：</div><div>                1&gt;作用：通过这个接口合法的检测全局作用域对象共享数据变化时刻。</div><div>                2&gt;监听事件方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void contextAdd():在全局作用域对象添加共享数据被触发public void contextReplaced():在全局作用域对象更新共享数据被触发</div><div>public void contextRemove():在全局作用域对象删除共享数据被触发</div></div><div>        6、全局作用域对象共享数据变化时刻</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ServletContext application=request.getServletContext();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">application.setAttribute(&quot;key1&quot;,100);//新增共享数据</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">application.setAttribute(&quot;ket1&quot;,200);//更新共享数据</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">application.removeAttribute(&quot;key1&quot;);//删除共享数据</span></div></div><div><br/></div><div>十八、Filter接口（过滤器接口）</div><div>        1、介绍：</div><div>                    1&gt;来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包</div><div>                    2&gt;Filter接口实现类由开发人员提供，Http服务器不负责提供</div><div>                    3&gt;Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</div><div>        2、具体作用：</div><div>                    1&gt;拦截Http服务器，帮助Http服务器检测当前请求的合法性</div><div>                    2&gt;拦截Http 服务器，对当前请求进行增强操作</div><div>        3、Filter接口实现类开发步骤：三步</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1、创建一个Java类实现Filter接口</div><div>2、重写Filter接口中doFilter方法</div><div>3、web.xml将过滤器接口实现类注册到Http服务器</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>帮助Http服务器检测当前请求的合法性</b></div><div><br/></div><div>public class OneFilter implements Filter{</div><div>    public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException,ServletException{</div><div>        //1、通过拦截请求对象得到请求包参数信息</div><div>        String age=servletRequest.getParameter(&quot;age&quot;);</div><div>        //2、根据年龄，帮助Http服务器判断本次请求的合法性</div><div>        if(Integer.valueOf(age)&lt;70){</div><div>//将拦截请求对象和响应对象交还给Tomcat，由Tomcat继续调用资源文件,放行</div><div>   filterChain.doFilter(servletRequest,servletResponse);</div><div>        }else{</div><div>            //过滤器将代替Http服务器拒绝本次请求</div><div>        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);</div><div>PrintWriter out=servletResponse.getWriter();</div><div>out.print(&quot;&lt;h1&gt;摸摸哒&lt;/h1&gt;&quot;);</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--将过滤器类文件路径交给Tomcat--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;filter&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    &lt;filter-class&gt;路径&lt;/filter-class&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;/filter&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;filter-mapping&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    &lt;url-pattern&gt;/mm.jpg&lt;/url-pattern&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;/filter-mapping&gt;</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>对请求进行增强操作</b></div><div><br/></div><div>利用过滤器对象实现Tomcat对POST请求编码为UTF-8</div><div>public class OneFilter implements Filter{</div><div>    public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException,ServletException{</div><div>            //增强操作</div><div>       servletRequest.setCharacterEncoding(&quot;utf-8&quot;);</div><div>            //放行</div><div>   filterChain.doFilter(servletRequest,servletResponse);</div><div>        </div><div>    }</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--将过滤器类文件路径交给Tomcat--&gt;</div><div>&lt;filter&gt;</div><div>    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</div><div>    &lt;filter-class&gt;路径&lt;/filter-class&gt;</div><div>&lt;/filter&gt;</div><div>&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</div><div>&lt;filter-mapping&gt;</div><div>    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</div><div>    &lt;!--通知tomcat在调用所有的资源文件之前都需要OneFilter进行拦截--&gt;</div><div>    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div>&lt;/filter-mapping&gt;</div></div><div><br/></div><div>        4、Filter拦截地址格式</div><div>                    1&gt;命令格式：</div><div>                                &lt;filter-mapping&gt;</div><div>                                      &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</div><div>                                      &lt;url-pattern&gt;拦截地址&lt;/url-pattern&gt;</div><div>                                &lt;/filter-mapping&gt;</div><div>                    2&gt;命令作用：</div><div>                                拦截地址通知Tomcat在调用何种资源文件之前需要调用oneFilter过滤器进行相关的拦截。</div><div>                    3&gt;具体格式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1、要求Tomcat在调用某一个具体文件之前，来调用 OneFilter拦截</div><div>&lt;url-pattern&gt;/img/mm.jpg&lt;/url-pattern&gt;</div><div>2、要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用 OneFilter拦截</div><div>&lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;</div><div>3、要求Tomcat在调用任意文件夹下某种类型文件之前，来调用 OneFilter拦截</div><div>&lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;</div><div>4、要求Tomcat在调用网站中任意文件之前，来调用 OneFilter拦截</div><div>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div></div><div>        5、过滤器防止用户恶意登录行为</div><div><img src="一、Servlet规范_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>令牌机制（令牌可以是【会话作用域对象】）</div><div><font face="Monaco">实现细节：在登录页面的Servlet中使用</font>request.getSession();使用户拥有一个私人储物柜，在调用其他资源前，用过滤器判断用户是否拥有私人储物柜：request.getSession(flase);若没有则返回NULL，拦截该请求，若存在该储物柜，放行。</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>利用过滤器对象实现Tomcat对POST请求编码为UTF-8</div><div>public class OneFilter implements Filter{</div><div>    public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException,ServletException{</div><div>        //向下转型</div><div>      if(servletRequest instanceof  HttpServletRequest){</div><div>          HttpServletRequest requ=(HttpServletRequest)servletRequest;</div><div>}</div><div>        //调用请求对象读取请求包中请求行中URI（网站名和资源路径）</div><div>        String uri=request.getRequestURI();</div><div>        //判断本次请求是否和登录资源文件相关【是否含有login】</div><div>        if(uri.indexOf(&quot;login&quot;)!=-1 ||&quot;/myweb/&quot;.equals(uri)){</div><div>        //放行</div><div>   filterChain.doFilter(servletRequest,servletResponse);</div><div>    return;</div><div>    }</div><div>        HttpSession session=requ.getSession(false);</div><div>        if(session==null){</div><div>            request.getRequestDispatcher(&quot;/login_error.html&quot;).forward(servletRequest,servletResponse);</div><div>            return;</div><div>        }</div><div>            //放行</div><div>   filterChain.doFilter(servletRequest,servletResponse);</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--过滤器注册--&gt;</div><div>&lt;!--将过滤器类文件路径交给Tomcat--&gt;</div><div>&lt;filter&gt;</div><div>    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</div><div>    &lt;filter-class&gt;路径&lt;/filter-class&gt;</div><div>&lt;/filter&gt;</div><div>&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</div><div>&lt;filter-mapping&gt;</div><div>    &lt;filter-name&gt;oneFilter&lt;/filter-name&gt;</div><div>    &lt;!--通知tomcat在调用所有的资源文件之前都需要OneFilter进行拦截--&gt;</div><div>    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div>&lt;/filter-mapping&gt;</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 