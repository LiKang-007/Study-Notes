<html>
<head>
  <title>并查集</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3303"/>
<h1>并查集</h1>

<div>
<span><div><b>并查集是一种树形的数据结构，并查集可以高效的进行如下操作：</b></div><div><span>    1、查询元素p和元素q是否属于同一组</span><br/></div><div><span><span>    2、合并元素p和元素q所在的组</span><br/></span></div><div><img src="并查集_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b><font style="font-size: 12pt;">并查集结构：</font></b></div><div>    <b>并查集也是一种树形结构：这种树要求比较简单：</b><span><b>  </b>  </span><br/></div><div><span><span>    <span>    1、每个元素都唯一的对应一个节点</span></span><br/></span></div><div><span><span>    </span><span>    2、每一组数据中的多个元素都在同一颗树中</span><br/></span></div><div><span><span>    </span><span>    3、一组中的数据对应的树和另一个组中的数据对应的树没有任何联系。</span><br/></span></div><div><span><span>    </span><span>    4、元素在树中并没有父子级关系的硬性要求</span><br/></span></div><div><img src="并查集_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><b>并查集API设计：</b></div><div><img src="并查集_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class UF{</div><div><span>    private int[]eleAndGroup;</span><br/></div><div><span><span>    private int count;</span><br/></span></div><div><span>    public UF(int N){</span></div><div><span><span>    </span><span>    //初始化分组的数量，默认情况下，有N个分组</span><br/></span></div><div><span><span>    </span><span>    this.count=N;</span><br/></span></div><div><span><span>    </span><span>    //初始化eleAndGroup数组</span><br/></span></div><div><span><span>    </span><span>    this.eleAndGroup=new int[N];</span><br/></span></div><div><span><span>    </span><span>    //初始化eleAndGroup中的元素及其所在组的标识符,让eleAndGroup数组的索引作为并查集的每个节点元素，并且让每个索引处的值为该元素所在组的标识符</span><br/></span></div><div><span>    </span><span>    for(int i=0;i&lt;eleAndGroup.length;i++){</span></div><div><span><span>    </span><span>    </span><span>    eleAndGroup[i]=i;</span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div><span><span><span>    </span>}</span><br/></span></div><div><span>    public int count(){</span></div><div><span><span>    </span><span>    return count;</span><br/></span></div><div><span><span><span>    </span>}</span><br/></span></div><div><span>    public int find(int p){</span></div><div><span><span>    </span><span>    return eleGroup[p];</span><br/></span></div><div><span><span><span>    </span>}</span><br/></span></div><div><span>    public boolean connected(int p,int q){</span></div><div><span><span>    </span><span>    return find(p)==find(q);</span><br/></span></div><div><span><span><span>    </span>}</span><br/></span></div><div><span>    public void union(int p,int q){</span></div><div><span><span>    </span><span>    //判断P和Q是否在同一分组，若在同一分组，结束方法即可</span><br/></span></div><div><span>    </span><span>    if(connected(p,q)){</span></div><div><span><span>    </span><span>    </span><span>    return;</span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div><span><span>    </span><span>    //找到p所在分组的标识符</span><br/></span></div><div><span><span>    </span><span>    int pGroup=find(p);</span><br/></span></div><div><span><span>    </span><span>    //找到q所在分组的标识符</span><br/></span></div><div><span><span>    </span><span>    int qGroup=find(q);</span><br/></span></div><div><span><span>    </span><span>    //合并组：让p所在组的所有元素的组标识符变为q所在分组的标识符</span><br/></span></div><div><span>    </span><span>    for(int i=0;i&lt;eleAndGroup.length;i++){</span></div><div><span>    </span><span>    </span><span>    if(eleAndGroup[i]==pGroup){</span></div><div><span><span>    </span><span>    </span><span>    </span><span>    eleAndGroup[i]=qGroup;</span><br/></span></div><div><span><span><span>    </span><span>    </span><span>    </span>}</span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div><span><span>    </span><span>    //分组个数-1</span><br/></span></div><div><span><span>    </span><span>    this.count--;</span><br/></span></div><div><span><span><span>    </span>}</span><br/></span></div><div>}</div></div><div><img src="并查集_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><b>并查集应用举例：</b></div><div><span>    </span><span>    如果用并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则就可以通过connected(int p,int q)来检测该网络中的某两台计算机之间是否连通。</span><br/></div><div><span><span>    </span><span>    上述合并算法要使所有的节点都在同一个分组内时间复杂度为O(n^2),需要对算法进行优化。</span><br/></span></div><div><br/></div><div><b><font style="font-size: 12pt;">UF_Tree算法优化：</font></b></div><div>重新对数组含义进行定义：</div><div><img src="并查集_files/Image [4].png" type="image/png" data-filename="Image.png"/>    <b>API和先前相同</b><br/></div><div>实现</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class UF-Tree{</div><div>    private int[]eleAndGroup;</div><div>    private int count;</div><div>    public UF(int N){</div><div>        //初始化分组的数量，默认情况下，有N个分组</div><div>        this.count=N;</div><div>        //初始化eleAndGroup数组</div><div>        this.eleAndGroup=new int[N];</div><div>        //初始化eleAndGroup中的元素及其所在组的标识符,让eleAndGroup数组的索引作为并查集的每个节点元素，并且让每个索引处的值为该元素所在组的标识符</div><div>        for(int i=0;i&lt;eleAndGroup.length;i++){</div><div>            eleAndGroup[i]=i;</div><div>        }</div><div>    }</div><div>    public int count(){</div><div>        return count;</div><div>    }</div><div>    public int find(int p){</div><div>       while(true){</div><div><span>    </span><span>    </span><span>    if(eleAndGroup[p]==p){</span></div><div><span><span>    </span><span>    </span><span>    </span><span>    break;</span><br/></span></div><div><span><span>    </span><span>    </span><span>    </span>}</span><br/></div><div><span><span>    </span><span>    </span><span>    p=eleAndGroup[p];</span><br/></span></div><div><span>    </span><span>  </span> }</div><div><span>    </span><span>    return p;</span><br/></div><div>    }</div><div>    public boolean connected(int p,int q){</div><div>        return find(p)==find(q);</div><div>    }</div><div>    public void union(int p,int q){</div><div>       //找到p元素和q元素所在组的根节点</div><div><span>    </span><span>    int pRoot=find(p);</span><br/></div><div><span><span>    </span><span>    int qRoot=find(q);</span><br/></span></div><div><span><span>    </span><span>    //判断p和q是否在同一分组</span><br/></span></div><div><span>    </span><span>    if(pRoot==qRoot){</span></div><div><span><span>    </span><span>    </span><span>    return;</span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div><span><span>    </span><span>    //合并</span><br/></span></div><div><span><span>    </span><span>    //让p所在的树的根节点的父节点为q所在树的根节点即可</span><br/></span></div><div><span><span>    </span><span>    eleAndGroup[pRoot]=qRoot;</span><br/></span></div><div><span><span>    </span><span>    //组的数量-1</span><br/></span></div><div><span><span>    </span><span>    this.count--;</span><br/></span></div><div>    }</div><div>}</div></div><div><span>find方法实现</span></div><div><img src="并查集_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>合并方法实现：</div><div><span>    </span><img src="并查集_files/Image [6].png" type="image/png" data-filename="Image.png"/><br/></div><div><b><font style="font-size: 12pt;">优化后的性能分析：</font></b></div><div><span>    find();方法时间复杂度从O(1)变为了O(n)；</span><br/></div><div><span><span>    在union方法中调用了find方法，所以在最坏情况下，合并所有元素的union算法的时间复杂度仍然为O(N^2);</span><br/></span></div><div><b>路径压缩：</b></div><div><span>    UF_Tree中最坏情况下的时间复杂度为O(n^2),主要原因是在最坏情况下，树的深度和数组的大小一样，如果通过一些算法，让合并时生成的树的深度尽可能的小，就可以优化find()方法；</span><br/></div><div><span><span>    之前的合并方法是比较暴力的，直接将一个数连接到了另一个树上。如果将每一课树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。</span><br/></span></div><div><img src="并查集_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><b>UF_Tree_Weighted API设计</b></div><div><img src="并查集_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class UF-Tree{</div><div>    private int[]eleAndGroup;</div><div>    private int count;</div><div><span>    //用来存储每一个根节点对应的树中保存节点的个数</span><br/></div><div><span>    private int[]sz;</span><br/></div><div>    public UF(int N){</div><div>        //初始化分组的数量，默认情况下，有N个分组</div><div>        this.count=N;</div><div>        //初始化eleAndGroup数组</div><div>        this.eleAndGroup=new int[N];</div><div>        //初始化eleAndGroup中的元素及其所在组的标识符,让eleAndGroup数组的索引作为并查集的每个节点元素，并且让每个索引处的值为该元素所在组的标识符</div><div>        for(int i=0;i&lt;eleAndGroup.length;i++){</div><div>            eleAndGroup[i]=i;</div><div>        }</div><div><span>    </span><span>    //默认情况下，sz每个索引处的值都是1</span><br/></div><div><span>    </span><span>    this.sz=new int[N];</span></div><div><span>    </span><span>    for(int i=0;i&lt;sz.length;i++){</span></div><div><span><span>    </span><span>    <span>    sz[i]=1;</span></span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div>    }</div><div>    public int count(){</div><div>        return count;</div><div>    }</div><div>    public int find(int p){</div><div>       while(true){</div><div>            if(eleAndGroup[p]==p){</div><div>                break;</div><div>            }</div><div>            p=eleAndGroup[p];</div><div>       }</div><div>        return p;</div><div>    }</div><div>    public boolean connected(int p,int q){</div><div>        return find(p)==find(q);</div><div>    }</div><div>    public void union(int p,int q){</div><div>       //找到p元素和q元素所在组的根节点</div><div>        int pRoot=find(p);</div><div>        int qRoot=find(q);</div><div>        //判断p和q是否在同一分组</div><div>        if(pRoot==qRoot){</div><div>            return;</div><div>        }</div><div><span>    </span><span>    //判断pRoot对应的树大，还是QRoot对应的树大，最终需要把较小的树合并到较大的树中</span><br/></div><div><span>    </span><span>    if(sz[pRoot]&lt;sz[qRoot]){</span></div><div><span><span>    </span><span>    </span><span>    eleAndGroup[pRoot]=qRoot;</span><br/></span></div><div><span><span>    </span><span>    </span><span>    sz[qRoot]+=sz[pRoot];</span><br/></span></div><div><span><span>    </span><span>    </span>}else{</span></div><div><span><span>    </span><span>    </span><span>    eleAndGroup[qRoot]=pRoot;</span><br/></span></div><div><span><span>    </span><span>    </span><span>    sz[pRoot]+=sz[qRoot];</span><br/></span></div><div><span><span><span>    </span><span>    </span>}</span><br/></span></div><div>       </div><div>        //组的数量-1</div><div>        this.count--;</div><div>    }</div><div>}</div></div><div>并查集案例：-</div><div><span>    畅通工程：</span><br/></div><div><img src="并查集_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><img src="并查集_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div></span>
</div></body></html> 