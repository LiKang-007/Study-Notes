<html>
<head>
  <title>图</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3327"/>
<h1>图</h1>

<div>
<span><div><div><span style="font-size: 12pt; font-weight: bold;">图的定义及分类：</span></div><div>    <span style="font-weight: bold;">定义</span>：图是由一组顶点和一组能够将两个顶点相连的边组成的。</div><div><span style="font-weight: bold;">特殊的图：</span></div><div>    1、自环：即一条连接一个顶点和其自身的边</div><div>    2、平行边：连接同一对顶点的两条边</div><div><span style="font-weight: bold;">图的分类：</span></div><div>    按照连接两个顶点的边的不同，可以把图分为一下两种：</div><div>        <span style="font-weight: bold;">无</span><span style="font-weight: bold;">向图：</span>边仅仅连接两个顶点，没有其他含义；</div><div>        <span style="font-weight: bold;">有向图：</span>边不仅仅连接两个顶点，并且具有方向；</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">无向图：</span></div><div>图的相关术语：</div><div>    1、相邻顶点：</div><div>            当两个顶点通过一条边相连时，称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</div><div>    2、度：</div><div>            某个顶点的度就是依附于该顶点的边的个数。</div><div>    3、子图：</div><div>            是一幅图的所有边的子集（包含这些边依附的顶点）组成的图；    </div><div>    4、路径：</div><div>            是由边顺序连接的一系列的顶点组成的。</div><div>    5、环：</div><div>            是一条至少含有一条边且终点和起点相同的路径。</div><div>    6、连通图：</div><div>            如果图中任意一个顶点都存在一条路径到达另一个顶点、</div><div>    7、连通子图：</div><div>            一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图。</div><div>    <img src="图_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">图的存储结构：</span></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">要表示一幅图，只需要表示清楚两部分：</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        1、图中所有的顶点；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        2、所有连接顶点的边；</span></div><div>    常见的图的存储结构有两种：<span style="font-weight: bold;">邻接矩阵和邻接表。</span></div><div><span style="font-size: 11pt; font-weight: bold;">邻接矩阵：</span></div><div>    1、使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点；</div><div>    2、如果顶点v和顶点w相连，只需要将adj[v][w]和adj[w][v]的值设置为1，否则设置为0即可。</div><div><img src="图_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>    显然，邻接矩阵这种存储方式的空间复杂度是V^2,如果处理问题的规模比较大，内存空间可能会不够用。</div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">邻接表：</span></font></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">1、使用一个大小为v的数组 Queue[V]adj,把索引看做是顶点。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    2、每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点。</span></div><div>    很明显，邻接表的空间并不是线性级别的，后面我们一直采用临街表这种形式存储图。</div><div><img src="图_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">无向图实现</span></div><div><span style="font-weight: bold;"> 无向图API设计</span></div><div><img src="图_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Graph{</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //顶点数目</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    private final int V;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //边的数目</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    private int E;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    private Queue&lt;Integer&gt;[]adj;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public Graph(int V){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //初始化顶点的数量</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        this.V=V;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //初始化边的数量</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        this.E=0;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //初始化邻接表</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        adj=new Queue[V];</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        for(int i=0;i&lt;V;i++){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            adj[i]=new Queue&lt;Integer&gt;();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取顶点的数目</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public int V(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return V;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取边的数目</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public int E(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return E;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //向图中添加一条边 V-W</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public void addEdge(int V,int W){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //在无向图中，边是没有方向的，该边既可以是从v到w的边，又可以说是从w到v的边，因此，需要让w出现在v的邻接表中，还要让v出现在w的邻接表中</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        adj[V].enqueque(W);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        adj[W].enqueque(V);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        E++;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取和顶点V相邻的所有的顶点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public Queue&lt;Integer&gt; adj(int V){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return agj[V];</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">图的搜索：</span></div><div>    深度优先搜索：    </div><div>        所谓的深度优先搜索，指的是在搜索时，如果遇到一个节点既有子节点，又有兄弟节点，那么先找子节点，然后再找兄弟节点。</div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">深度优先搜索API</span></font></div><div><span style="font-size: 14pt;"><img src="图_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public class DepthFirstSearch{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //索引代表顶点，值表示当前顶点是否已经被搜索</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    private boolean[] marked;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //记录有多少个顶点与S顶点相通</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    private int count;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //构造方法，使用深度优先搜索对象找出G图顶点的所有相邻顶点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public DepthFirstSearch(Graph,int s){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        this.marked=new boolean[G.V()];</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        this=0;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        dfs(G,s);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //使用深度优先搜索找出G图中V顶点的所有相通顶点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    priavte void dfs(Group G,int v){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //把V顶点标识为已搜索</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        marked[v]=true;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        for(Integer w:G.adj(v)){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //判断当前w有没有被搜索过，如果没有被搜索过，则递归调用dfs进行深度搜索</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            if(!marked[w]){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                dfs(G,w);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //相通顶点数量+1</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        count++;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //判断w顶点与s顶点是否相通</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public boolean marked(int w){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return marked[w];</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取与顶点s相通的所以有顶点的总数</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public int count(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return count;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div><span style="font-size: 12pt; font-weight: bold;">广度优先搜索：</span></div><div>    所谓的广度优先搜索，指的是在搜索时，如果遇到一个节点既有子节点，又有兄弟节点，那么先找兄弟节点，再找子节点。</div><div>  <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">  广度优先搜索API</span></font></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">二叉树的层序遍历就是广度优先搜索</span></span></div><div><span style="font-size: 10pt; font-weight: bold;">图的广度优先搜索API</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [6].png" type="image/png" data-filename="Image.png"/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14.6667px;">public class BreadthFirstSearch{</span></div><div><span style="font-size: 14.6667px;">    //索引代表顶点，值表示当前元素是否已经被搜索</span></div><div><span style="font-size: 14.6667px;">    private boolean[] marked;</span></div><div><span style="font-size: 14.6667px;">    //记录有多少个顶点与s顶点相通</span></div><div><span style="font-size: 14.6667px;">    private int count;</span></div><div><span style="font-size: 14.6667px;">    //用来存储将搜索邻接表的顶点</span></div><div><span style="font-size: 14.6667px;">    private Queue&lt;Integer&gt; waitSearch;</span></div><div><span style="font-size: 14.6667px;">    public BreadthFirstSearch(Graph G,int s){</span></div><div><span style="font-size: 14.6667px;">        this.marked=new boolean[G.V()];</span></div><div><span style="font-size: 14.6667px;">        this.count=0;</span></div><div><span style="font-size: 14.6667px;">        this.waitSearch=new Queue&lt;Integer&gt;();</span></div><div><span style="font-size: 14.6667px;">        bfs(G,s);</span></div><div><span style="font-size: 14.6667px;">    }</span></div><div><span style="font-size: 14.6667px;">    //使用广度优先搜索找出G图中v顶点的所有相邻顶点</span></div><div><span style="font-size: 14.6667px;">    private void  bfs(Graph G,int v){</span></div><div><span style="font-size: 14.6667px;">        //把当前顶点标识为已搜索</span></div><div><span style="font-size: 14.6667px;">        marked[v]=true;</span></div><div><span style="font-size: 14.6667px;">        //让顶点v进入队列，待搜索</span></div><div><span style="font-size: 14.6667px;">        waitSearck.enqueque(v);</span></div><div><span style="font-size: 14.6667px;">        //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索</span></div><div><span style="font-size: 14.6667px;">        while(!waitSearch.isEmpty()){</span></div><div><span style="font-size: 14.6667px;">            //弹出一个待搜索的顶点</span></div><div><span style="font-size: 14.6667px;">             Integer wait=waitSearch.dequeque();</span></div><div><span style="font-size: 14.6667px;">            //遍历wait顶点的邻接表</span></div><div><span style="font-size: 14.6667px;">            for(Integer w:G.adj(wait)){</span></div><div><span style="font-size: 14.6667px;">                if(!marked[w]){</span></div><div><span style="font-size: 14.6667px;">                    gfs(G,w);</span></div><div><span style="font-size: 14.6667px;">                }</span></div><div><span style="font-size: 14.6667px;">            }</span></div><div><span style="font-size: 14.6667px;">        }</span></div><div><span style="font-size: 14.6667px;">        //让相同的顶点+1</span></div><div><span style="font-size: 14.6667px;">        count++;</span></div><div><span style="font-size: 14.6667px;">    }</span></div><div><span style="font-size: 14.6667px;">    public boolean marked(int w){</span></div><div><span style="font-size: 14.6667px;">        return marked[w];</span></div><div><span style="font-size: 14.6667px;">    }</span></div><div><span style="font-size: 14.6667px;">    public int count(){</span></div><div><span style="font-size: 14.6667px;">        return count;</span></div><div><span style="font-size: 14.6667px;">    }</span></div><div><span style="font-size: 14.6667px;">}</span></div></div><div><span style="font-size: 14.6667px;">案例：畅通工程续</span></div><div><span style="font-size: 14.6667px;"><span style="font-size: 11pt;"><img src="图_files/Image [7].png" type="image/png" data-filename="Image.png"/></span></span></div><div>解题思路：</div><div><span style="font-size: 11pt;"><img src="图_files/Image [8].png" type="image/png" data-filename="Image.png"/></span></div><div>实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>day05 152</div></div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">有向图：</span></div><div><span style="font-weight: bold;">定义：</span>有向图是一副有方向的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</div><div><span style="font-weight: bold;">出度：</span>由某个顶点指出的边的个数称为该顶点的出度。</div><div><span style="font-weight: bold;">入度：</span>指向某个顶点的边的个数称为该顶点的入度。</div><div><span style="font-weight: bold;">有向路径：</span>由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。</div><div><span style="font-weight: bold;">有向环：</span>一条至少含有一条边，且起点和终点相同的有向路径。</div><div><br/></div><div>一副有向图中两个顶点v和w可能存在一下四种关系：</div><div>        1、没有边相连;</div><div>        2、存在从v到w的边；</div><div>        3、存在从w到v的边；</div><div>        4、既存在w到v的边，有存在v到w的边，即双向连接。</div><div><br/></div><div>   <span style="font-weight: bold;">有向图API设计：</span></div><div><img src="图_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Digraph{</div><div>    private final int V;</div><div>    priavte int E;</div><div>    private Queue&lt;Integer&gt;[] adj;</div><div>    public Dig(int v){</div><div>        this.V=v;</div><div>        this.E=0;</div><div>        this.adj=new Queue[V];</div><div>        for(int i=0;i&lt;adj.length;i++){</div><div>            adj[i]=new Queue&lt;&gt;(Inteage);</div><div>        }</div><div>    }</div><div>    public int V(){</div><div>        return V;</div><div>    }</div><div>    public int E(){</div><div>        return E;</div><div>    }</div><div>    //向有向图中添加一条边 v-w</div><div>    public  void addEdge(int v,int w){</div><div>        //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是：v-&gt;其他顶点</div><div>        adj[v].enqueue(w);</div><div>        E++;</div><div>    }</div><div>    public Queue&lt;Integer&gt; adj(int v){</div><div>        return adj[v];</div><div>    } </div><div>    private Digraph reverse(){</div><div>        Digraph r=new Digraph(V);</div><div>        for(int v=0;v&lt;V;v++){</div><div>            //由该顶点指出的所有边</div><div>            for(Integer w:adj[v]){</div><div>                //原图中表示的由顶点v指向w的边</div><div>                r.addEdge(w,v);</div><div>            }</div><div>        }</div><div>        return Digraph;</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">    二、拓扑排序：</span></div><div>        给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面指向排在后面的元素，此时，就可以明确指出每个顶点的优先级。</div><div><img src="图_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><img src="图_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">检测有向图中的环</span></div><div><span style="font-weight: bold;">    如果要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。</span></div><div><span style="font-weight: bold;">检测有向图中的环的API设计</span></div><div><span style="font-weight: bold;"><img src="图_files/Image [12].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">原理：</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;"><img src="图_files/Image [13].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="图_files/Image [14].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">实现：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class DirectedCycle{</div><div>    //索引代表顶点，值表示当前顶点是否已经被搜索</div><div>    private boolean[] marked;</div><div>    //记录图中是否有环</div><div>    private boolean hasCycle;</div><div>    //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上</div><div>    priavte boolean[] onStack;</div><div>    private DirectedCycle(Digraph){</div><div>        this.marked=new boolean[G.V()];</div><div>        this.hasCycle=false;</div><div>        this.onStack=new boolean[G.V()];</div><div>        //找到图中的每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索</div><div>        for(int v=0;v&lt;G.v();v++){</div><div>            if(!marked[v]){</div><div>                dfs(G,v);</div><div>            }</div><div>        }</div><div>    }</div><div>    private void dfs(Digraph G,int v){    </div><div>        //把顶点v标识为已搜索</div><div>         mark[v]=true;</div><div>        //把当前顶点进栈</div><div>        onStack[v]=true;</div><div>        //进行深度搜索</div><div>        for(Integer w:G.adj(v)){</div><div>            //判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索</div><div>            if(!marked[w]){</div><div>                dfs(G,w);</div><div>            }</div><div>            //判断当前顶点w是否已经在栈中，如果已经在栈中当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了</div><div>            if(onStack[w]){</div><div>                hasCycle=true;</div><div>                return;</div><div>            }</div><div>        }</div><div>        //把当前顶点出栈</div><div>        onStack[v]=false;</div><div>    }</div><div>    //判断当前有向图G中是否有环</div><div>    public boolean hasCycle(){</div><div>        hasCycle;</div><div>    }</div><div>    </div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">基于深度优先的顶点排序：</span></div><div>    深度优先搜索有一个特点：在一个连通子图上，每个顶点只会被搜索一次，在深度优先搜索的基础上加一行代码，把要搜索的顶点放入到线性序列的数据结构中，就完成了对顶点的排序。</div><div>    顶点排序的API设计：</div><div><img src="图_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>每搜索一个顶点，就将其放入到reversePost中，就可以实现顶点排序。</div><div><img src="图_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><img src="图_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div><img src="图_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class DepthFirstOrder{</div><div>    //</div><div>    private boolean[] marked;</div><div>    priavte Stack&lt;Integer&gt; reversePost;</div><div>    public DepthFirstOrder(Digraph G){</div><div>        this.marked=new boolean[G,V()];</div><div>        this.reversePost=new Stack&lt;Integer&gt;();</div><div>        //遍历图中的每一个顶点，完成一次深度优先搜索</div><div>        for(int v=0;v&lt;G.V();v++){</div><div>            if(!marked[v]){</div><div>                dfs(G,v);</div><div>            }</div><div>        }</div><div>    }</div><div>    //基于深度优先搜索，把顶点排序</div><div>    private void dfs(Digraph G,int v){</div><div>        //标记当前v已经被搜索</div><div>        marked[v]=true;</div><div>        //通过循环深度搜索顶点v</div><div>        for(Integer w:G.adj[v]){</div><div>            //如果当前顶点w没有搜索，则递归调用dfs进行搜索</div><div>            dfs(G,v);</div><div>        }</div><div>       // 让顶点v进栈</div><div>        reversePost.push(v);</div><div>    }</div><div>    //获取顶点线性序列</div><div>    public  Stack&lt;Integer&gt; reversePost(){</div><div>        return reversePost;</div><div>    }</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">拓扑排序实现：</span></div><div>    基于一副图，先检测有没有环，如果没有环，则调用顶点排序即可。    </div><div><span style="font-weight: bold;">拓扑排序的API设计：</span></div><div><img src="图_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div>实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class TopoLogical{</div><div>    private Stack&lt;Integer&gt; order;</div><div>    public TopoLogical(Digraph G){</div><div>        DirectedCycle cycle=new DirectedCycle(G);</div><div>        if(!cyc){</div><div>        }</div><div>    }</div><div>    private boolean isCycle(){</div><div>    }</div><div>    public Stack&lt;Integer&gt;order(){</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">加权无向图：</span></div><div><br/></div><div>加权无向图，需要给边关联一个权重值，因此可以使用对象来描述一条边。</div><div><br/></div><div>加权无向图边的表示</div><div>API设计：</div><div><img src="图_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Edge implements Comparable&lt;Edge&gt;{</div><div>    private final int v;</div><div>    private final int w;</div><div>    priavte final double weight;</div><div>    //通过顶点w和v，以及权重构造一个边对象</div><div>    public Edge(int v,int w,double weight){</div><div>        this.v=v;</div><div>        this.w=w;</div><div>        this.weight=weight;</div><div>    }</div><div>    //获取边的权重值</div><div>    public double  weight(){</div><div>        return weight;</div><div>    }</div><div>    //获取边上的一个点</div><div>    public int either(){</div><div>        return v;</div><div>    }</div><div>    //获取边上除了顶点vertex外的另一个顶点</div><div>    public  int  other(int vertex){</div><div>        if(vertex==v){</div><div>            return w;</div><div>        }else{</div><div>            return v;</div><div>        }</div><div>    }</div><div>    public int compareTo(Edge that){</div><div>        //使用一个遍历记录比较的结果</div><div>        int cmp;</div><div>        //如果当前边的权重比较大，则让cmp=1;</div><div>        if(this.weight()&gt;that.weight){</div><div>            cmp=1;</div><div>        }</div><div>        //如果当前边的权重值小，则让cmp=-1;</div><div>        if(this.weight()&lt;that.weight()){</div><div>            cmp=-1</div><div>        }</div><div>        //如果当前边的权重值和that边的权重值一样大，则让cmp=0</div><div>        if(this.cmp==this.cmp){</div><div>            cmp=0;</div><div>        }</div><div>        return cmp;</div><div>    }</div><div><br/></div><div>}</div></div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">加权无向图实现：</span></div><div><span style="font-weight: bold;">API设计：</span></div><div><img src="图_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class EdgewightedGraph{</div><div>    private final int v;</div><div>    private int  E;</div><div>    private Queue&lt;Edge&gt;[] agj;</div><div>    public EdgeWeightedGraph(int v){</div><div>        this.v=v;</div><div>        this.E=0;</div><div>        this.adj=new Queue[v];</div><div>        for(int i=0;i&lt;adj.length;i++){    </div><div>            adj[i]=new Queue&lt;Edge&gt;();</div><div>        }</div><div>    }</div><div>    //获取顶点的数量</div><div>    public int v(){</div><div>        return v;</div><div>    }</div><div>    //获取图中边的数量</div><div>    public intE(){</div><div>        return E;</div><div>    }</div><div>    //向加权无向图中添加一条边    </div><div>    public void  addEdge(Edge e){</div><div>        //需要让边e同时出现在e这个边的两个顶点的邻接表中</div><div>        int v=e.either();</div><div>        int w=e.other(v);</div><div>        adj[v]=enqueue(e);</div><div>        adj[w].enqueue(e);</div><div>        //边的数量+1</div><div>        E++;</div><div>    }</div><div>    //获取和顶点关联的所有边</div><div>    public Queue&lt;Edge&gt;adj(int v){</div><div>        return adj[v];</div><div>    }</div><div>    public Queue&lt;Edge&gt; edges(){</div><div>        //创建一个队列对象，存储所有的边</div><div>        Queue&lt;Edge&gt;allEdges=new Queue&lt;&gt;();</div><div>        //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边</div><div>        //因为这是无向图，所以同一条边出现在了它关联的两个顶点的邻接表中，需要让一条边只记录一次</div><div>        for(int v=0;v&lt;V;v++){</div><div>            //遍历v顶点的邻接表，找到每一条和v关联的边</div><div>            for(Edge e:adj(v)){</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            if(</span>e.other(v)&lt;v<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                allEdges.enqueue(e);    </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            }</span></div><div>            }</div><div>        }</div><div>        return allEdges;</div><div>    }</div><div><br/></div><div>}</div></div><div><span style="font-size: 12pt;"><b>生成树：</b></span></div><div><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">连通图中的生成树必须满足以下 2 个条件：</span></div><ol style="margin-top: 0px; margin-bottom: 0px; list-style: decimal; margin-left: 0px; padding-left: 20px; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li><div>包含连通图中所有的顶点；</div></li><li><div>任意两顶点之间有且仅有一条通路；</div></li></ol><div><span style="font-size: 11pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;;"><br/></span></div><div><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">因此，连通图的生成树具有这样的特征，即生成树中</span><span style="display: inline-block; font-size: 14px; color: rgb(51, 51, 51); border: 1px solid rgb(221, 221, 221); background: rgb(246, 246, 246); border-radius: 2px; font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">边的数量 = 顶点数 - 1</span><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">。</span></div><div><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">最小生成树：</span></div><div>    <span style="font-weight: bold;">最小生成树及其相关约定</span></div><div>        定义：图的生成树是它的一颗含有所有顶点的无环连通子图，一副加权无向图的最小生成树它的一颗权值和（树中所有边的权重之和）最小的生成树。</div><div>    约定：</div><div>        只考虑连通图，最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通子图的最小生成树，合并到一起称为最小生成森林。</div><div>        所有边的权重都不相同，如果不同边的权重可以相同，那么一副图额最小生成树就可能不唯一了， 虽然本算法可以处理这种情况，但是为了好理解，约定所有边的权重都各不相同。</div><div>  <span style="font-size: 11pt; font-weight: bold;">  最小生成树原理：</span></div><div>      <span style="font-weight: bold;">  树的性质：</span></div><div><span style="font-weight: bold;"><img src="图_files/Image [22].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 11pt; font-weight: bold;">切分定理：</span></div><div>    要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。</div><div><span style="font-weight: bold;">    切分：</span></div><div>        将图的所有顶点按照某些规则分为两个非空且没有交集的集合。</div><div><span style="font-weight: bold;">    横切边：</span></div><div>        连接两个属于不同集合的顶点的边称为横切边。</div><div><img src="图_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">    切分定理：</span></div><div>        在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。</div><div><img src="图_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div>  <span style="font-weight: bold;">  注意：</span>一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边</div><div><br/></div><div><span style="font-weight: bold;">贪心算法：</span>    </div><div>    贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，<span style="font-weight: bold;">使用切分定理找到最小生成树的一条边，不断地重复直到找到最小生成树的所有边。</span>如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。</div><div><img src="图_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div>计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在于保存切分和判定权重最小的横切边的方式。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第一种算法：Prim算法</span></div><div><span style="font-weight: bold;">Prim算法的切分规则：</span></div><div>    把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。</div><div><span style="font-weight: bold;">    Prim算法API设计：</span></div><div><img src="图_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div>    Prim算法的实现原理：</div><div>    将图中的顶点分为 ：最小生成树顶点和非最小生成树顶点。</div><div>        初始，默认将顶点0放入最小生成树顶点，将顶点0的边看做是整个最小生成树的横切边，选择其中权值最小的边，将其顶点加入最小生成树顶点，更新整个树的横切边，直到所有的顶点都在最小生成树顶点。</div><div><img src="图_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">使用最小索引优先队列保存横切边的权重。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class PrimMST{</div><div>    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边</div><div>    private Edge[] edgeTo;</div><div>    private double[] disTo;</div><div>    priavte boolean[] marked;</div><div>    private IndexMinPriorityQueue&lt;Double&gt;pq;</div><div>    //根据一副加权无向图，创建最小生成树计算对象</div><div>    public  PrimMST(EdgeWeightedGraph G){</div><div>        //初始化edgeTo</div><div>        this.edgeTo=new Edge[G.V()];</div><div>        //初始化distTo</div><div>        this.distTo=new double[G.V()];</div><div>        for(int i=0;i&lt;disTo.length;i++){</div><div>            distTo[i]=Double.POSITIVE_INFINITY;</div><div>        }</div><div>        //初始化marked</div><div>       this.marked=new boolean[G.V()];</div><div>        //初始化pq</div><div>        pq=new IndexMinPriorityQueue&lt;Double&gt;(G.V());</div><div>        //默认让顶点0进入到树中，但是树中只有一个顶点0，因此，顶点默认没有和其他的顶点相连，所以让distTo对应位置处的值存储0.0</div><div>        distTo[0]=0.0;</div><div>        pq.insert(0,0.0);</div><div>        //遍历索引优先队列，拿到最小横切边对应的顶点，把该顶点加入到最小生成树中</div><div>        while(!pq.isEmpty()){</div><div>            visit(G,pq.delMin());</div><div>        }</div><div>    }</div><div>    //将顶点v添加到最小生成树中，并且更新数据</div><div>    private void  visit(EdgeWeightedGraph G,int v){</div><div>        //把顶点v添加到最小生成树中</div><div>        marked[v]=true;</div><div>        //更新数据</div><div>        for(Edge e:G.adj(v)){</div><div>        //获取e边的另外一个顶点（当前顶点是v）</div><div>        //判断另外一个顶点是不是已经在树中，如果在树中，则不做任何处理，更新数据</div><div>        if(marked[w]){</div><div>            continue;</div><div>         }</div><div>        //判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重</div><div>        if(e.weight()&lt;distTo[w]){</div><div>            //更新数据</div><div>            edgeTo[w]=e;</div><div>            distTo[w]=e.weight();</div><div>            if(pq.contains(w)){</div><div>                pq.changeItem(w,e.weight());</div><div>            }else{</div><div>                pq.insert(w,e.weight);</div><div>            }</div><div>        }</div><div>        }</div><div>    }</div><div>    //获取最小生成树中的所有边</div><div>    public  Queue&lt;Edge&gt;edges(){</div><div>        //创建队列对象</div><div>        Queue&lt;Edge&gt;  allEdges=new Queue&lt;&gt;();</div><div>        //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中</div><div>        for(int i=0;i&lt;edgeTo.length;i++){</div><div>            if(egdeTo[i]!=null){</div><div>                allEdges.enqueque(edgeTo[i]);</div><div>            }</div><div>        }</div><div>       return  allEdge;</div><div>    }</div><div>    </div><div>}</div></div><div><span style="font-size: 11pt; font-weight: bold;">Kruskal算法</span></div><div>kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的思想是按照边的权重（从小到大），将边加入到最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。</div><div><span style="font-size: 11pt; font-weight: bold;">kruskal算法和prim算法的区别：</span></div><div>    prim算法是一条边一条边的构造最小生成树，每一步都为一颗树添加一条边。kruskal算法    构造最小生成树的时候也是一条边一条边地构造，但是它的切分规则是不一样的。它的每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图有v个顶点组成，初始化情况下每个顶点都构成一颗独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并成一颗树，直到森林中只剩一颗树为止。</div><div>    <img src="图_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 11pt; font-weight: bold;">kruskal算法的API设计</span></div><div><img src="图_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 11pt; font-weight: bold;">kruskal算法实现原理</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [30].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 10pt; font-weight: bold;">通过最小优先队列对所有的边以权值进行排序</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [31].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [32].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [33].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [34].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><img src="图_files/Image [35].png" type="image/png" data-filename="Image.png"/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class KruskalMST{</div><div>    //保存最小生成树的所有边</div><div>    private Queue&lt;Edge&gt;mst;</div><div>    //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并</div><div>    private UF_Tree_Weighted uf;</div><div>    //存储图中所有的边，使用最小优先队列，对边按照权重进行排序</div><div>    priavte MinPriOrityQueue&lt;Edge&gt;pq;</div><div>    //根据一副加权无向图，创建最小生成树计算对象</div><div>    public KruskalMST(EdgeWeightedGraph G){</div><div>        //初始化mst</div><div>        this.mst=new Queue&lt;Edge&gt;();</div><div>        //初始化uf</div><div>        this.uf=new UF_Tree_weighted(G.V());</div><div>        //初始化pq</div><div>        this.pq=new MinPriorityQueue&lt;&gt;(G.E()+1);</div><div>        for(Edge e:G.edges()){</div><div>            pq.insert(e);</div><div>        }</div><div>        //遍历pq队列，拿到最小权重的边，进行处理</div><div>        while(!pq.isEmpty()&amp;&amp;mst.size()&lt;G.V()-1){</div><div>            //找到权重最小的边</div><div>           Edge e= pq.delMin();</div><div>            //找到该边的两个顶点</div><div>            int v=e.either();</div><div>            int w=e.other(v);</div><div>            //判断这两个顶点是否已经在同一颗树中，如果在同一棵树中，则不对该边进行处理，如果不在同一棵树中，则让着两个顶点属于的两颗树合并成一棵树</div><div>            if(uf.connected(v,w)){</div><div>                continue;</div><div>            }</div><div>            uf.union(v,w);</div><div>            //让边e进入到mst队列中</div><div>            mst.enqueque(e);</div><div>        }</div><div>    }</div><div>    //获取最小生成树的所有边</div><div>    public Queue&lt;Edge&gt;edges(){</div><div>        return mst;</div><div>    }</div><div>}</div></div><div style="font-size: 11pt;"><br/></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">加权有向图边的表示</span></div><div style="font-size: 11pt;"><br/></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">API设计：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;"><img src="图_files/Image [36].png" type="image/png" data-filename="Image.png"/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class DirectedEdge{</div><div>    private final int v;//起点</div><div>    private final int w;//终点</div><div>    private final double weight;//当前边的权重</div><div>    public DirectedEdge(int v,int w,double weight){</div><div>        this.v=v;</div><div>        this.w=w;</div><div>        this.weight=weight;</div><div>    }</div><div>    public double weight(){</div><div>        return weight;</div><div>        </div><div>    }</div><div>    public int from(){</div><div>        return v;</div><div>    }</div><div>    public int to(){</div><div>        return w;</div><div>    }</div><div>}</div></div><div style="font-size: 11pt;"><br/></div><div style="font-size: 11pt;"><br/></div><div style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">加权有向图的实现：</span></div><div><span style="font-size: 11pt; font-weight: bold;">   </span> <span style="font-size: 10pt; font-weight: bold;">在有向图的基础上，把边的表示切换成DirectedEdge对象即可。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">   </span> <span style="font-size: 11pt; font-weight: bold;">API</span><span style="font-size: 11pt;"><img src="图_files/Image [37].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 11pt;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div style="font-size: 11pt;"><br/></div><div><span style="font-size: 12pt; font-weight: bold;">最短路径：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">   </span> <span style="font-size: 11pt; font-weight: bold;">最短路径定义及性质</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">      </span> <span style="font-size: 11pt; font-weight: bold;"> </span><span style="font-size: 11pt; font-weight: bold;">定义：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            在一副有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;"><img src="图_files/Image [38].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 11pt;"><br/></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">       </span> <span style="font-size: 11pt; font-weight: bold;">性质：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            1、路径具有方向性；</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            2、权重不一定等价于距离。权重可以是距离，时间，花费等内容，权重最小指的是成本最低。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            3、只考虑连通图，一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径，为了简化问题，这里只考虑连通图。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            4、最短路径不一定是唯一的，从一个顶点到达另外一个顶点的权重最小的路径可能有很多条，这里只需要找出一条。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">       </span> <span style="font-size: 11pt; font-weight: bold;">最短路径树：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">            给定一副加权有向图和一个顶点s，以s为起点的一颗最短路径树是图的一副子树，它包含顶点s已经从s可达的所有顶点。这颗有向树的根节点为s,树的每条路径都是有向图中的一条最短路径。</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">   </span> <span style="font-size: 11pt; font-weight: bold;">最短路径树API设计：</span><span style="font-size: 11pt; color: unset; font-family: unset;">   </span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">    计算最短路径的经典算法是dijstra算法</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt; color: unset; font-family: unset;"><img src="图_files/Image [39].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">松弛技术：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">    生活中的松弛：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;"><img src="图_files/Image [40].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">边的松弛</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;"><img src="图_files/Image [41].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;">顶点的松弛：</span></div><div style="font-size: 11pt;"><span style="font-size: 11pt;"><img src="图_files/Image [42].png" type="image/png" data-filename="Image.png"/></span></div><div><img src="图_files/Image [43].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">Dijstra算法实现</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class DijkstraSP{</div><div>    //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边</div><div>    private DirectedEdge[] edgeTo;</div><div>    //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重</div><div>    private double[] distTo;</div><div>    //存放树中顶点与非树中顶点之间的有效横切边</div><div>    private IndexMinPrioriorityQueue&lt;Double&gt;pq;</div><div>    //根据一副加权有向图G和顶点S，创建一个计算顶点为s的最短路径树对象</div><div>    public DijkstraSP(EdgeWeightedDigraph G,int s){ </div><div>       //初始化edgeTo</div><div>        this.edgeTo=new DirectedEdge[G.V()];</div><div>        //初始化disTo</div><div>        this.disTo=new double[G.V()];</div><div>        for(int i=0;i&lt;distTo.length;i++){</div><div>            distTo[i]=Double.POSITIVE_INFINITY;</div><div>        }</div><div>        //初始化pq</div><div>        this.pq=new IndexMinPriorityQueue&lt;&gt;(G.V());</div><div>        //找到图G中以s为起点的最短路径树</div><div>        //默认让顶点s进入到最短路径树中</div><div>        distTo[s]=0.0;</div><div>        pq.insert(s,0.0);</div><div>        //遍历pq</div><div>        while(!pqisEmpty()){</div><div>            relax(G,pq.delMin());</div><div>        }</div><div>        </div><div>    }</div><div>    //松弛图G中的顶点V</div><div>    public void relax(EdgeWeightedDigraph G,int v){</div><div>        for(DirectedEdge edge:G.adj(v)){</div><div>            //获取到该边的终点</div><div>            int w=edge.to();</div><div>            //通过松弛技术判断从顶点s到顶点w的最短路径是否需要先从顶点到v，然后再由顶点v到顶点w</div><div>            if(distTo(v)+edge.weight()&lt;distTo(w)){</div><div>                distTo[w]=distTo[v]+edge.weight();</div><div>                edgetTo[w]=edge;</div><div>                //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在则直接添加</div><div>                if(pq.contains(w)){</div><div>                    pq.changeItem(w,distTo(w));</div><div>                }else{</div><div>                    pq.insert(w,distTo(w));</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>    //获取从顶点s到顶点v的最短路径的总权重</div><div>    public double distTo(int v){</div><div>        return distTo[v];</div><div>    }</div><div>    //判断从顶点s到顶点v是否可达</div><div>    public boolean hasPathTo(int v){</div><div>        return distTo[v]&lt;Double.POSITIVE_INFINITY;</div><div>    }</div><div>    //查询从起点s到顶点v的最短路径中的所有边</div><div>    public Queue&lt;DirectedEdge&gt;pathTo(int v){</div><div>        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null</div><div>        if(hasPathTo(v)){    </div><div>            return null;</div><div>        }</div><div>        //创建一个队列对象</div><div>        Queue&lt;DirectedEdge&gt; allEdges=new Queue&lt;&gt;();</div><div>        while(true){</div><div>            DirectedEdge e=edgeTo[v];</div><div>            if(e==null){</div><div>                break;</div><div>            }</div><div>            allEdgees.enqueue(e);</div><div>            v=e.from();</div><div>        }</div><div>        return allEdges;</div><div>    }</div><div>}</div></div><div><br/></div></div></span>
</div></body></html> 