<html>
<head>
  <title>优先队列</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3193"/>
<h1>优先队列</h1>

<div>
<span><div><span style="font-size: unset; color: unset; font-family: unset;">    普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除，在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下，计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率并不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</span></div><div><img src="优先队列_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">优先队列按照其作用不同，可以分为一下两种：</span></div><div><span style="font-weight: bold;">    最大优先队列：</span></div><div>        可以获取并删除队列中的最大的值。</div><div>    <span style="font-weight: bold;">最小优先队列：   </span></div><div>        可以获取并删除队列的中最小的值。</div><div><span style="font-weight: bold; font-size: 12pt;">最大优先队列：</span></div><div>    堆这种结构可以方便的删除最大的值，所以，可以基于堆来实现最大优先队列。</div><div>    最大优先队列API设计：</div><div><img src="优先队列_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>代码实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class MaxPriorityQueue(T extends Comparable&lt;T&gt;){</div><div>    private T[] items;</div><div>    private int N;</div><div>    public MaxPriorityQueue(int capacity){</div><div>        this.items=new Comparable[capacity+1];</div><div>        this.N=0;</div><div>    }</div><div>    //判断堆中索引i处的元素是否小于索引j处的元素</div><div>    private boolean less(int i,int j){</div><div>        return items[i].compareTo(items[j])&lt;0;</div><div>    }</div><div>    //交换堆中i索引和j索引处的值</div><div>    private void exch(int i,int j){</div><div>        T com=items[i];</div><div>        items[i]=items[j];</div><div>        items[j]=com;</div><div>        </div><div>    }</div><div>    //往堆中插入一个元素</div><div>    public T insert(T t){</div><div>        item[++N]=t;</div><div>        swim(N);</div><div>        </div><div>    }</div><div>    //删除堆中最大的元素，并返回这个最大的元素</div><div>    public T delMax(){</div><div>        T max=items[1];</div><div>        exch(1,N--);</div><div>        sink(1);</div><div>        return max;</div><div>    }</div><div>    //使用上浮算法，使索引k处的值能在堆中处于一个正确的位置</div><div>    private void swim(int k){</div><div>        while(K&gt;1){</div><div>            if(less(k/2,k)){</div><div>                exch(k/2,k);</div><div>            }</div><div>            k=k/2;</div><div>        }</div><div>    }</div><div>    //使用下沉算法，使索引k处的值能在堆中处于一个正确的位置</div><div>    private void sink(int k){</div><div>        while(2*k&lt;=N){</div><div>            int max;</div><div>            if(2*k+1&lt;N){</div><div>                if(less(2*K,2*K+1)){</div><div>                    max=2*k+1;</div><div>                }else{</div><div>                    max=2*k;</div><div>                }</div><div>            }else{</div><div>                max=2*k;</div><div>            }</div><div>            if(!less(k,max)){</div><div>                break;</div><div>            }</div><div>            exch(k,max);</div><div>            k=max;</div><div>        }</div><div>    }</div><div>}</div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold; font-size: 12pt;">最小优先队列：</span></div><div><span style="font-weight: bold;">最小堆：</span></div><div>    1、最小的元素放在数组的索引1处；</div><div>    2、每个节点的数据总是小于等于它的两个子节点的数据。</div><div>最小优先队列的API设计</div><div><img src="优先队列_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>代码实现</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class MinPriorityQueue&lt;&gt;{</div><div>    private T[] items;</div><div>    private int N;</div><div>    public MinPriorityQueue(int capacity){</div><div>        this.items=(T[])new Comparable[capacity+1];</div><div>        this.N=0;</div><div>    }</div><div>    public int size(){</div><div>        return N;</div><div>    }</div><div>    public boolean less(int i,int j){</div><div>        return items[i].compareTo(items[j])&lt;0;</div><div>    }</div><div>    private void exch(int i,int j){</div><div>        T tmp=items[i];</div><div>        items[i]=items[j];</div><div>        items[j]=tmp;</div><div>    }</div><div>    public void insert(T t){</div><div>        item[++N]=t;</div><div>        swin(N);</div><div>    }</div><div>    public T delMin(){</div><div>        Comparable min=items[1];</div><div>        exch(i,N);</div><div>        N--;</div><div>        sink(1);</div><div>        return min;</div><div>    }</div><div>    private void swim(int K){</div><div>        while(k&gt;1){</div><div>            if(less(k,k/2)){</div><div>                exch(k,k/2);</div><div>            }</div><div>            k=k/2;</div><div>        }</div><div>    }</div><div>    private void sink(int k){</div><div>        while(2*k&lt;=N){</div><div>            int min;</div><div>            if(2*k+1&lt;=N){</div><div>                if(less(2*k,2*k+1)){</div><div>                    min=2*k;</div><div>                }else{</div><div>                    min=2*k+1;</div><div>                }</div><div>            }else{</div><div>                    min=2*k;</div><div>            }</div><div>            if(less(k,min)){</div><div>                break;</div><div>            }</div><div>            exch(k,min);</div><div>            k=min;</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">索引优先队列：</span></div><div>    最小和最大优先队列，分别可以快速访问到队列中最大元素和最小元素，但是他们有一个缺点，就是没有办法通过索引访问已经存在优先队列中的对象，并且更新他们。为了实现这个目的，引入了索引优先队列。</div><div><br/></div><div>索引优先队列的实现思路：</div><div>    步骤一：</div><div><img src="优先队列_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>    步骤二：</div><div><img src="优先队列_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="优先队列_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>    步骤三：</div><div><img src="优先队列_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>总结：</div><div>        要使用三个一维数组</div><div>            items[]用来保存数据元素；</div><div>            pq[]用来保存items中的元素的索引，实现堆有序；</div><div>            qp[]用来保存pq[]数组的逆序。（逆序：内容下标相互交换，目的是快速查找）</div><div><span style="font-weight: bold;">索引优先队列的API设计</span></div><div><img src="优先队列_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>代码实现：</div><div>    day04 113-118<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div><br/></div></span>
</div></body></html> 