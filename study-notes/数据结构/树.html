<html>
<head>
  <title>树</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3155"/>
<h1>树</h1>

<div>
<span><div><div><span style="font-size: 14pt; font-weight: bold;">树的基本定义</span></div><div>树具有以下特点：</div><div>    1、每个节点有零个或者多个子节点。</div><div>    2、没有父节点的节点为根节点。</div><div>    3、每一个非根节点只有一个父节点。</div><div>    4、每个节点及其后代节点整体上可以看做是一棵树，称为当前节点的父节点的一颗子树。</div><div><span style="font-size: 14pt; font-weight: bold;">树的相关术语</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="树_files/Image.png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-weight: bold;">节点的度：</span></div><div>        一个节点含有的子树的个数称为该节点的度。</div><div>        <span style="font-weight: bold;">例如：</span>A的度为6，E的度为2</div><div><span style="font-weight: bold;">叶节点：</span></div><div>        度为0的节点称为叶节点，也可以叫做终端节点。</div><div>      <span style="font-weight: bold;">  例如：</span>B、H、P</div><div><span style="font-weight: bold;">分支节点：</span></div><div>        度不为0的节点称为分支节点，也可以叫做非终端节点。</div><div>        <span style="font-weight: bold;">例如：</span> A、F、E</div><div><span style="font-weight: bold;">节点的层次：</span></div><div>        从根节点开始，根节点的层次为1，根的直接后继层次为2，以此类推。</div><div>        <span style="font-weight: bold;">例如：</span>A的层次为1，B、C、D层次为2，H层次为3，P和Q层次为4.</div><div><span style="font-weight: bold;">节点的层序编号：</span></div><div>        将树中的节点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</div><div>        例如：A为1，B为2，C为3，D为4，G为7，H为8，N为14</div><div><span style="font-weight: bold;">树的度：</span></div><div>        树中所有节点的度的最大值。</div><div><span style="font-weight: bold;">树的高度：</span></div><div>        树中节点的最大层次。</div><div><span style="font-weight: bold;">森林：</span></div><div>        m（m&gt;=0）个互不相交的树的集合，将一颗非空的根节点删去，树就变成一个森林；给森林增加一个统一的根节点，森林就变成了一棵树。</div><div><span style="font-weight: bold;">孩子节点：</span></div><div>        一个节点的直接后继节点称为该节点的孩子节点互称兄弟节点。</div><div><span style="font-weight: bold;">双亲节点：</span></div><div>        一个节点的直接前驱称为该节点的双亲节点。</div><div><span style="font-weight: bold;">兄弟节点：</span></div><div>        同一双亲节点的孩子节点间 </div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">二叉树</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;">二叉树的基本定义</span></div><div>    二叉树就是度不超过2的树（每个节点最多有两个子节点）</div><div><span style="font-weight: bold;">满二叉树：</span></div><div>    如果一个二叉树的每一层的节点树都达到最大值，则这个二叉树就是满二叉树。</div><div><span style="font-weight: bold;">完全二叉树：</span></div><div>    叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">二叉查找树的创建</span></div><div><font style="font-size: 12pt;"><br/></font></div><div>二叉树的节点类API设计</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 252px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 252px; padding: 8px; border: 1px solid;"><div>Node&lt;Key,Value&gt;</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 252px; padding: 8px; border: 1px solid;"><div>Node(Key key,Value value,Node left,Node right)</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 252px; padding: 8px; border: 1px solid;"><div>public Node left:记录左子节点</div><div>public Node right：记录右子节点</div><div>public Key key 存储键</div><div>public Value value:存储值</div></td></tr></tbody></table><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div></div><div><br/></div><div>二叉查找树的API设计</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 108px;"></col><col style="width: 378px;"></col></colgroup><tbody><tr><td style="width: 108px; padding: 8px; border: 1px solid;">类名</td><td style="width: 378px; padding: 8px; border: 1px solid;"><div>BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value value&gt;</div></td></tr><tr><td style="width: 108px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 378px; padding: 8px; border: 1px solid;"><div>BinaryTree()</div></td></tr><tr><td style="width: 108px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 378px; padding: 8px; border: 1px solid;"><div>private Node root:记录根节点</div><div>private int N:记录树中元素的个数</div></td></tr><tr><td style="width: 108px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 378px; padding: 8px; border: 1px solid;"><div>public void put(Key key,Value value):向树中插入一个键值对</div><div>private Node put(Node x,Key key,Value val):给指定的树x上，添加一个键值对，并返回添加后的新树</div><div>public Value get(Key key):根据key，从树中找出对应的值</div><div>private Value get(Node x,Key key):从指定的树x中，找出key对应的值</div><div>public void delete(Key key):根据key，删除树中对应的键值对</div><div>private Node delete(Node x,Key key):删除指定树x上键为key的键值对，并返回删除后的新树。</div><div>public int size():获取树中元素的个数</div></td></tr></tbody></table><div>二叉查找树的实现</div></div><div><img src="树_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Value get(Key key){</div><div>    get(key,root);</div><div>}</div><div>public Value get(Key key,Node x){</div><div>    if(x==null){</div><div>        return null;</div><div>    }</div><div>    if(key.comparto(x.key)&gt;0){</div><div>        return get(key,x.right);</div><div>    }else if(key.comparto(x.key)&lt;0){</div><div>        return get(key,x.left);</div><div>            }else{</div><div>                return x.value;</div><div>            }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public void delete(Key key){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    delete(root,key);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public Node delete(Node x,Key key){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //x树为null</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    if(x==null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        return null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //x树不为null</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    int cmp=key.compareTo(x.key);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    if(cmp&gt;0){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            x.right=delete(x.right,key);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    }else if(cmp&lt;0){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            x.left=delete(x.left,key);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                            }else{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    </span>                          //元素个数-1</div><div>                            N--;<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                            </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //完成删除节点的动作，删除x</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //找到右子树中最小的节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    if(x.right==null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                              return x.left;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                              }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    if(x.left==null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                return x.right;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    Node minNode=x.right;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    while(minNode.left!=null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                            minNode=minNode.left;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //删除右子树中最小的节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    Node n=x.right;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    while(n.left!=null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                            if(n.left.left==null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                    n.left=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                }else{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                     n=n.left;   </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                                    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //让x节点的左子树成为minNode的左子树</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    minNode.left=x.left;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //让x节点的右子树成为minNode的右子树</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    midNode.right=x.right;   </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    //让x节点的父节点指向minNode</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                     x= midNode; </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                                    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return x;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><span style="font-size: 12pt; font-weight: bold;">二叉查找树其他的便捷方法</span></div></div><div><span style="font-weight: bold;">查找二叉树中最小的键：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Key min(){</div><div>    return min(root).key;</div><div>}</div><div>public Key min(Node x){</div><div>    if(x.left!=null){</div><div>            return min(x.left); </div><div>        }else{</div><div>            return x;</div><div>        }</div><div>}</div></div><div><span style="font-weight: bold;">查找二叉树中最大的键：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Key max(){</div><div>   return max(root).key;</div><div>}</div><div>public Key max(Node x){</div><div>    if(x.right!=null){</div><div>            return max(x.right);</div><div>        }else{</div><div>            return x;</div><div>        }</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">二叉查找树的基础遍历：</span></div><div><span style="font-weight: bold;">    1、前序遍历：</span></div><div>            先访问根节点，然后再访问左子树，最后访问右子树。</div><div>  <span style="font-weight: bold;">  2、中序遍历：</span></div><div>            先访问左子树，再访问根节点，最后访问右子树。</div><div>    <span style="font-weight: bold;">3、后序遍历：</span></div><div>            先访问左子树，再访问右子树，最后访问根节点。</div><div><span style="font-weight: bold;">前序遍历：</span></div><div>    API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; preErgodic():使用前序遍历，获取整个树中的所有键</div><div>public void preErgodic(Node x,Queue&lt;Key&gt;):使用前序遍历，把指定树x中的所有键放入到keys队列中</div></div><div>代码</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; preErgodic(){</div><div>    Queue&lt;key&gt; keys=new Queue&lt;&gt;();</div><div>    preErgodic(root,keys);</div><div>    return keys;</div><div><br/></div><div>}</div><div>public void preErgodic(Node x,Queue&lt;Key&gt; keys){</div><div>    if(x==null){</div><div>        return;</div><div>    }</div><div>    //把x节点的key放入keys中</div><div>    keys.enqueque(x.key);</div><div>    //递归遍历x节点的左子树</div><div>    if(x.left!=null){</div><div>         preErgodic(x.left,keys);</div><div>    }</div><div>    //递归遍历x节点的右子树</div><div>   if(x.right!=null){</div><div>         preErgodic(x.right,keys);</div><div>    }</div><div> }</div></div><div><br/></div><div><span style="font-weight: bold;">中序遍历：</span></div><div>API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; midErgodic():使用中序遍历，获取整个树中的所有键</div><div>public void preErgodic(Node x,Queue&lt;Key&gt;):使用中序遍历，把指定树x中的所有键放入到keys队列中</div></div><div>代码</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; midErgodic(){</div><div>    Queue&lt;Key&gt; keys =new Queue&lt;&gt;();</div><div>    midErgodic(root,keys);</div><div>    return keys;</div><div>}</div><div>public void midErgodic(Node x,Queue&lt;Key&gt; keys){</div><div>    if(x.==null){</div><div>        return;</div><div>    }</div><div>    //先递归，把左子树中的键放入keys中</div><div>    if(x.left!=null){</div><div>        mid(x.left,keys);</div><div>    }</div><div>    //把当前节点的键放入到keys</div><div>    keys.enqueque(x);</div><div>    //递归，把右子树中的键放入到keys中</div><div>    if(x.right!=null){</div><div>        mid(x.right,keys);</div><div>    }</div><div>    </div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">后序遍历</span></div><div>API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; afterErgodic():使用中序遍历，获取整个树中的所有键</div><div>public void afterErgodic(Node x,Queue&lt;Key&gt;):使用中序遍历，把指定树x中的所有键放入到keys队列中</div></div><div>代码</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; afterErgodic(){</div><div>    Queue&lt;Key&gt; keys=new Queue();</div><div>    afterErgodic(root,keys);</div><div>    return keys;</div><div>}</div><div>public void afterErgodic(Node x,Queue&lt;Key&gt;){</div><div>    if(x==null){</div><div>        return; </div><div>    }</div><div>    if(x.left!=null){</div><div>        afterErgodic(x.left,keys);</div><div>    }</div><div>    if(x.right!=null){</div><div>        afterErgodic(x.right,keys);</div><div>    }</div><div>    keys.enqueque(x.key);</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">二叉树的层序遍历：</span></div><div>所谓的层序遍历，就是从根节点(第一层)开始，依次向下，获取每一层所有节点的值。</div><div>API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; layerErgodic():使用层序遍历，获取整个树中的所有键</div></div><div><span style="font-weight: bold;">实现步骤：</span></div><div>1、创建队列，存储每一层的节点；</div><div>2、使用循环队列从队列中弹出一个节点；</div><div>        2、1、获取当前节点的key；</div><div>        2、2、如果当前节点的左子节点不为空，则把左子节点放入队列中</div><div>        2、3、如果当前节点的右子节点不为空，则把右子节点放入到队列中 </div><div><img src="树_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Queue&lt;Key&gt; layerErgodic(){</div><div>    //定义两个队列，分别存储树中的键和树中的节点</div><div>    Queue&lt;Key&gt; keys=new Queue&lt;&gt;();</div><div>    Queue&lt;Node&gt; nodes=new Queue&lt;&gt;();</div><div>    //在节点队列放入根节点</div><div>    nodes.enqueue(root);</div><div>    while(!nodes.isEmpty){</div><div>        //从nodes队列中弹出一个节点，并将弹出节点的key放入keys队列</div><div>        Node n=nodes.dequeque();</div><div>        keys.enqueque(n.key);</div><div>        if(n.left!=null){</div><div>            nodes.enqueque(n.left);</div><div>            }</div><div>        if(n.right!=null){</div><div>            nodes.enqueque(n.right);</div><div>            }</div><div>    }</div><div>    return keys;</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">二叉树应用案例：</span></div><div>  <span style="font-weight: bold;">  1、二叉树的最大深度问题：</span></div><div>        需求：给定一棵树，计算树的最大深度（树的根节点到最远叶子节点的最长路径上的节点数）</div><div>        API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public int maxDepth():计算整个树的最大深度</div><div>private int maxDepth(Node x):计算指定树x的最大深度</div></div><div>  <span style="font-weight: bold;">实现步骤：</span></div><div>    1、如果根节点为空，则最大深度为0</div><div>    2、计算左子树的最大深度</div><div>    3、计算右子树的最大深度</div><div>    4、当前树的最大深度=左子树的最大深度和右子树中最大深度中的较大者+1</div><div>  <span style="font-weight: bold;">  代码：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public int maxDepth(){</div><div>    maxDepth(root);</div><div>}</div><div>private int maxDepth(Node x){</div><div>    if(x==null){</div><div>        return 0;</div><div>    }</div><div>    int max=0;</div><div>    int maxLeft=0;</div><div>    int maxRight=0;</div><div>    if(x.left!=null){</div><div>        maxLeft=maxDepth(x.left);</div><div>    }</div><div>    if(x.right!=null){</div><div>        maxRight=maxDepth(x.right);</div><div>    }</div><div>    max=maxLeft&gt;maxRight?maxLeft+1:maxRight+1;</div><div>    return max;</div><div>}</div></div><div>  2、折纸问题：</div><div><img src="树_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public class PagerFoldingTest{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public static void main(String[] args){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        </span>//通过模拟对折N次纸，产生树</div><div>    Node&lt;String&gt; tree=createTree(3);</div><div>    printTree(tree);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">   </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public static Node&lt;String&gt; createTree(int N){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //定义根节点：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            Node&lt;String&gt; root=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            for(int 1=0;i&lt;N;i++){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //1、当前是第一次对折</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                if(i==0){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    root=new Node(&quot;down,null,null&quot;);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    continue;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //2、当前不是第一次对折    </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    //定义一个层序队列，通过层序遍历的思想，找到叶子节点，给叶子节点添加子节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    Queue&lt;Node&gt; queue=new Queue&lt;&gt;();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    Queue.enqueuqe(root);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    while(!queue.isEmpty()){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            //从队列中弹出一个节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            Node&lt;String&gt; tmp=queue.dequeue();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            //如果有左子节点，则把左子节点放入到队列中</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            if(tmp.left!=null){        </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                queue.enqueue(tmp.left);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            //如果有右子节点，则把右子节点放入到队列中</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            </span>if(tmp.right!=null){        </div><div>                 queue.enqueue(tmp.right);</div><div>                 }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            //如果既没有左子节点也没有右子节点，则证明是叶子节点，给叶子节点添加左子节点，和右子节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            if(tmp.left==null&amp;&amp;tmp.right==null){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                    tmp.left=new Node&lt;String&gt;(&quot;down&quot;,null,null);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                                    tmp.fight=new Node&lt;String&gt;(&quot;up&quot;,null,null);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            return null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div>  //节点类</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    priavte static class Node&lt;T&gt;{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        public T item;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        public Node left;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        public Node right;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">       public Node(T item,Node left,Node right){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            this.item=item;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            this.left=left;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            this.right=right;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //打印树中每个节点到控制台</span></div><div>  public static void printTree(Node root){</div><div>            //需要使用中序遍历完成</div><div>            if(root==null){</div><div>                return;</div><div>            }</div><div>            //打印左子树的每个节点</div><div>            if(root.left!=null){</div><div>                printTree(root.left);</div><div>            }</div><div>            System.out.print(root.item);</div><div>            //打印当前节点</div><div>            //打印右子树的每个节点</div><div>            if(root.right!=null){</div><div>                printTree(root.right);</div><div>            }</div><div>        }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">平衡树：</span></div><div><span style="font-size: 12pt; font-weight: bold;">1.1 2-3查找树</span></div><div><span style="font-size: 12pt; font-weight: bold;">   </span> <span style="font-size: 12pt;">为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中一个节点保存多个值。确切地说，我们将一颗标准二叉查找树中的节点称为2-节点（含有一个键和两条链），而现在我们饿引入3-节点，它含有两个键和三条链，2-节点和3-节点中的每条链都对应着其中保存的键所分割产生的一个区间。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.1.1 2-3查找树的定义</span></font></div><div><span style="font-size: 12pt; font-weight: bold;">   </span> <span style="font-size: 12pt;">一颗2-3查找树要么为空，要么满足一面两个要求。</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;">2-节点：</span></div><div><span style="font-size: 12pt;">  </span> <span style="font-size: 10pt;">     含有一个键（及其对应的值）和两条链，左链接指向2-3树中的链都小于该节点，右链接指向的2-3树中的键都大于该节点。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3-节点</span></font></div><div><span style="font-size: 12pt;">       </span> <span style="font-size: 10pt;">含有两个键（及其对应的值）和三条链，左链接指向2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向2-3树中的键都大于该节点。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="树_files/Image [9].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.1.2 查找</span></span></div><div><span style="font-size: 12pt; font-weight: bold;">   </span> <span style="font-size: 10pt;">将二叉查找树的查找算法一般化我们就能够直接得到2-3查找树的查找算法。要判断一个键是否在树中，我们先将它和根节点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到相应区间的连接，并在其指向的子数中递归地继续查找，如果这个是空链接，查找未命中。</span></div><div><img src="树_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 11pt; font-weight: bold;">1.1.3 插入</span></div><div>   </div><div><span style="font-weight: bold;">1.1.3.1 向2-节点中插入新键</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">往2-3查找树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3查找树之所以能够保证在最差的情况下的效率的原因是在于其插入之后仍然能够保持平衡状态。如果查找未找到的节点是一个2-节点，那么很容易，我们只需要将新的元素放到这个2-节点里面使其变成一个3-节点即可。但是如果查找的节点结束与一个3-节点，那么可能有点麻烦。</span></div><div><img src="树_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">1.1.3.2 向一颗只含有一个3-节点的树中插入新键</span></div><div>    假设2-3树只包含一个3-节点，这个节点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个节点能放三个元素，暂时使其变成一个4-节点，同时包含四条链接，然后，我们将这个4-节点的中间元素提升，左边的键作为其左子节点，右边的键作为其右子节点。插入完成，变为2-3查找树，树的高度从0变为1。</div><div><img src="树_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">1.1.3.3 向一个父节点为2-节点的3-节点中插入新键</span></div><div>    和情况2一样，我们也可以将新的元素插入到3-节点中，使其成为一个临时的4-节点，然后，将该节点的中间元素提升到父节点即2-节点中，使其父节点成为一个3-节点，然后将左右节点分别挂在这个3-节点的恰当位置。</div><div><img src="树_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">1.1.3.4 向一个父节点为3-节点的3-节点中插入新键</span></div><div>    当我们插入的节点是3-节点的时候，我们将该节点拆分，中间元素提升至父节点，但是此时父节点是一个3-节点，插入之后，父节点变成了4-节点，然后继续将中间元素提升至其父节点，直至遇到一个父节点是2-节点，然后将其变为3-节点，不需要继续进行拆分。</div><div><img src="树_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [17].png" type="image/png" data-filename="Image.png"/><img src="树_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">1.1.3.5 分解根节点</span></div><div>    当插入节点到根节点的路径上全部是3-节点的时候，最终我们的根节点会变成一个临时的4-节点，此时，就需要将根节点拆分为两个2-节点，树的高度+1.</div><div><img src="树_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">2-3查找树的性质：</span></div><div>    通过对2-3查找树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变化来保持2-3树的平衡。</div><div>    一颗完全平衡的2-3树具有一下的性质：</div><div>            1、任意空链接到根节点的路径长度都是相等的。</div><div>            2、4-节点变换未3-节点时，树的高度不会发生变化，只有当根节点是临时的4-节点，分解根节点时，树高+1。</div><div>            3、2-3树与普通的二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3查找树是自底向上生长。</div><div><span style="font-weight: bold;"> 2-3树的实现</span></div><div>    直接实现2-3树比较复杂，因为：</div><div>            1、需要处理不同的节点类型，非常繁琐；</div><div>            2、需要多次比较操作来将节点下移；</div><div>            3、需要拆分4-节点</div><div>            4、拆分4-节点的情况有很多种。</div><div>2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对红黑树、B树和B+树非常重要。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1.2 红黑树</span></div><div>        2-3树最坏情况下所有的子节点都是2-节点，树的高度为lgN，相比于二叉查找树（二叉查找树最坏情况下树的高度为N），确实保证了最坏情况下的时间复杂度，但是实现起来过于繁琐，红黑树是2-3树思想的简单实现。</div><div>        红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树（完全由2-节点构成）和一些额外的信息（替换3-节点）来表示2-3树。将树中的链接分为两种类型：</div><div>            <span style="font-weight: bold;">红链接</span>：将两个2-节点连接起来构成一个3-节点。</div><div>            <span style="font-weight: bold;">黑链接</span>：是2-3树中的普通链接。</div><div>        确切的说，我们将3-节点表示为右一条左斜的红色链接（两个2-节点其中之一是另个一个左子节点）相连的两个2-节点，这种表示法的一个优点是，我们无需修改就可以使用标准的二叉查找树的get()方法。</div><div><img src="树_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 11pt; font-weight: bold;">红黑树的定义：</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    红黑树是含有红黑链接并满足下列条件的二叉树：</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        1、红链接均为左链接；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        2、没有任何一个节点同时和两条红链接相连；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        3、该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同。</span></div><div>    下面是红黑树与2-3树的对应关系：</div><div><img src="树_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">红黑树节点类API</span></div><div>因为每个节点都只会有一条指向自己的链接（从它的父节点指向它），我们可以在之前的Node节点中添加一个布尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果该链接是黑色的，那么该变量的值为false。</div><div><img src="树_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">平衡化：</span></div><div>    在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。</div><div>       <span style="font-weight: bold;"> </span><span style="font-weight: bold;">左旋：</span></div><div>                <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">当某个节点的左子节点为黑色，右子节点为红色，此时需要左旋。</span></div><div>        前提：当前节点为h，它的右子节点为x；</div><div>        左旋过程：</div><div>            1、让x的左子节点变为h的右子节点：h.right=x.left;</div><div>            2、让h成为x的左子节点：x.left=h;</div><div>            3、让h的color属性变为x的color属性值：x.color=h.color;</div><div>            4、让h的color属性变为RED：h.color=true;</div><div><img src="树_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">右旋：</span></div><div>    当某个节点的左子节点是红色，且左子节点的左子节点也是红色，需要右旋。</div><div>    前提：当前节点为h，它的左子节点为x；</div><div>右旋过程：</div><div>        1、让x的右子节点成为h的左子节点：h.left=x.right;</div><div>        2、让h成为x的右子节点：x.right=h;</div><div>        3、让h的color变为x的color属性值：x.color=h.color;</div><div>        4、让h的color为RED;</div><div><img src="树_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">插入操作：</span></div><div>  <span style="font-weight: bold;">  1、向单个2-节点中插入新键</span></div><div><img src="树_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div>  <span style="font-weight: bold;">  2、向底部的2-节点插入新键</span></div><div><img src="树_files/Image [31].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [32].png" type="image/png" data-filename="Image.png"/></div><div>    <span style="font-weight: bold;">3、颜色反转</span></div><div><img src="树_files/Image [33].png" type="image/png" data-filename="Image.png"/></div><div>  <span style="font-weight: bold;">  4、向一颗双键树（即一个3-节点）中插入新键</span></div><div><img src="树_files/Image [34].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [35].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [36].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [37].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">5、根节点的颜色总是黑色的</span></div><div>    color属性为父节点指向当前节点的连接的颜色，由于根节点不存在父节点，所以每次插入操作后，我们都需要把根节点的颜色设置为黑色。</div><div><span style="font-weight: bold;">6、向树底部的3-节点插入新键</span></div><div><img src="树_files/Image [38].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [39].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [40].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">红黑树的API设计</span></div><div><img src="树_files/Image [41].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">红黑树的实现：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class RedBlackTree&lt;Key extends Comparable&lt;Key&gt;,value&gt;{</div><div>    //根节点</div><div>    private Node root;</div><div>    //记录树中元素的个数</div><div>    private int N;</div><div>    //红色链接</div><div>    private static final boolean RED=true;</div><div>    //黑色链接</div><div>    private static final boolean BLACK=false;</div><div>    //节点类</div><div>    private class Node{</div><div>        //存储键</div><div>        public Key key;</div><div>        //存储值</div><div>        private Value value;</div><div>        //记录左子节点</div><div>        public Node left;</div><div>        //记录右子节点</div><div>        public Node right;</div><div>        //由其父节点指向它的链接的颜色</div><div>        public boolean color;</div><div>        public Node(Key key,Value value,Node left,Node right,boolean color){</div><div>            this.key=key;</div><div>            this.value=value;</div><div>            this.left=left;</div><div>            this.right=right;</div><div>            this.color=color;</div><div>        }</div><div>    }</div><div>    public int size(){</div><div>        return N;</div><div>    }</div><div>    private boolean isRed(Node x){</div><div>        if(x==null){</div><div>            return false;</div><div>        }</div><div>        return x.color==RED;</div><div>    }</div><div>    private Node rotateLeft(Node h){</div><div>        //获取h节点的右子节点，表示为x</div><div>        Node x=h.right;</div><div>        //让x节点的左子节点成为h节点的右子节点</div><div>        h.right=x.left;</div><div>        //让h成为x节点的左子节点</div><div>        x.left=h;</div><div>        //让x节点的color属性等于h节点的color属性</div><div>        x.color=h.color;</div><div>        //让h节点的color属性变为红色</div><div>        h.color=RED;</div><div>        return x;</div><div>    }</div><div>    private Node rotateRight(Node h){</div><div>        //获取h节点的左子节点，表示为x</div><div>         Node x=h.left;</div><div>        //让x节点的右子节点成为h节点的左子节点</div><div>        h.left=x.right;</div><div>        //让h节点成为x节点的右子节点</div><div>        x.right=h;</div><div>        //让x节点的color属性等于h节点的color属性</div><div>        x.color=h.color;</div><div>        //让h节点的color属性为RED</div><div>        h.color=RED;</div><div>        return x;</div><div>    }</div><div>    private void flipColors(Node h){    </div><div>        //当前节点变为红色</div><div>        h.color=RED;</div><div>        //左子节点和右子节点变为黑色</div><div>        h.left.color=BLACK;</div><div>        h.right.color=BLACK;</div><div>    }</div><div>    //在整个树上完成插入操作</div><div>    public void put(Key key,Value val){</div><div>        root=put(root,key,val);</div><div>        //根节点的颜色总是黑色的</div><div>        root.color=RED;</div><div>    }</div><div>    //在指定树中，完成插入操作，并返回添加元素后新的树</div><div>    public Node put(Node h,Key key,Value val){</div><div>        //判断h是否为空，如果为空则直接返回一个红色的节点</div><div>        if(h==null){</div><div>            N++;</div><div>            return new Node(key,val,null,null,RED);</div><div>        }</div><div>        //比较h节点的键和key的大小</div><div>        int cmp=key.compareTo(h.key);</div><div>        if(cmp&lt;0){</div><div>            //继续往左</div><div>            h.left=put(h.left,key,val);</div><div>            }</div><div>        }else if(cmp&gt;0){</div><div>            //继续往右</div><div>            h.right=put(h.right,key,val);</div><div>        }else{</div><div>            //发生值的替换</div><div>            h.value=val;</div><div>        }</div><div>        //进行左旋：当当前节点h的左子节点为黑色，右子节点为红色，需要左旋</div><div>        if(isRed(h.right)&amp;&amp;!isRed(h.left)){</div><div>           h=rotateLeft(h);</div><div>        }</div><div>        //进行右旋：当前节点h的左子节点和左子节点的左子节点都为红色，需要右旋</div><div>        if(isRed(h.left)&amp;&amp;isRed(h.left.left)){</div><div>            h=rotateRight(h);</div><div>        }</div><div>        //颜色反转：当前节点的左子节点和右子节点都为红色时，需要进行颜色反转</div><div>        if(isRed(h.left)&amp;&amp;isRed(h.right)){</div><div>            flipColors(h);</div><div>        }</div><div>        return h;</div><div>    }</div><div>    //根据key，从树中找出对应的值</div><div>    public Value get(Key key){</div><div>        return get(root,key);</div><div>    }</div><div>    public Value get(Node x,Key key){</div><div>        if(x==null){</div><div>            return null;</div><div>        }</div><div>        //比较x节点的键和key的大小</div><div>        int cmp=key.compareTo(x.key);</div><div>        if(cmp&lt;0){</div><div>            return get(x.left,key);    </div><div>        }else if(cmp&gt;0){</div><div>            return get(x.right,key);</div><div>        }else{</div><div>            return x.value;</div><div>        }</div><div>    }</div><div>    </div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">B-树</span></div><div>B树是一种树状数据结构，它能够存储数据，对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插入和删除等操作。</div><div><span style="font-weight: bold;">B-树的特性：</span></div><div>    B树中允许一个节点包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。选择一个参数M，来构造一个B树，可以把它称作是M阶的树，那么该树会具有如下的特点：</div><div>    1、每个节点最多有M-1个key，并且以升序排列；</div><div>    2、每个节点最多能有M个子节点；</div><div>    3、根节点至少有两个子节点。</div><div><img src="树_files/Image [42].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>    在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度任然比较小，在某些应用场合就可以体现出它的优势。</div><div><span style="font-weight: bold;">B-树中存储数据</span></div><div>    若参数M选择为5，那么每个节点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。</div><div><img src="树_files/Image [43].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [44].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [45].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">B树在磁盘文件中的应用</span></div><div>    计算机操作磁盘上的文件是通过文件系统操作的。在文件系统中就使用到了B树这种数据结构。</div><div>磁盘：</div><div><img src="树_files/Image [46].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">磁盘IO</span></div><div><img src="树_files/Image [47].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [48].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">B+树</span></div><div>    B+树是对B树的一种变形术，它与B树的差异在于：</div><div>        1、非叶节点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</div><div>        2、树的所有叶节点构成一个有序链表，可以按照key排序的次序遍历全部数据。</div><div><span style="font-weight: bold;">B+树存储数据</span></div><div>    若参数M选择为5，那么每个节点最多包含4个键值对，以5阶B+树为例，看看B+树的数据存储。</div><div><img src="树_files/Image [49].png" type="image/png" data-filename="Image.png"/></div><div><img src="树_files/Image [50].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">B+树和B树的对比：</span></div><div><span style="font-weight: bold;">B+树的优点在于：</span></div><div>    1、由于B+树在非叶子节点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。</div><div>    2、B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要每一层的递归遍历。</div><div><span style="font-weight: bold;">B树的优点在于：</span></div><div>    由于B树的每一个节点都包含key和value，因此根据key查找value时，只需要找到key所在的位置，就能够找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子节点的深度，才能找到value。</div><div><b><font style="font-size: 12pt;">B+树在数据库中的应用：</font></b><br/><span>    在数据库的操作中，查询操作可以说是一种最频繁的操作，因此在设计数据库时。必须要考虑到查询的效率问题，在很多数据库中，都采用了B+树来提高查询的效率。</span><br/></div><div><span>    </span>在操作数据库时，为了提高效率，可以基于某张表的某个字段建立索引，其实这个索引就是B+树这种数据结构实现的。</div><div><img src="树_files/Image [51].png" type="image/png" data-filename="Image.png"/></div><div><b>建立主键索引</b></div><div><img src="树_files/Image [52].png" type="image/png" data-filename="Image.png"/></div><div>未建立主键查询：区间查询需要查找每一条数据，并判断其是否在该区间。</div><div>建立主键查询之后，B+树所有叶子结点构成有序的链表，查找效率大大的提高。</div></span>
</div></body></html> 