<html>
<head>
  <title>常见的排序算法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3104"/>
<h1>常见的排序算法</h1>

<div>
<span><div><div><span style="font-size: 10pt; font-weight: bold;">Comparable接口</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">简单排序</span></div><div><br/></div><div><span style="font-weight: bold;">1、冒泡排序</span></div><div>        原理：</div><div>                1、比较相邻的元素，如果前一个元素比第一个元素大（小），就交换这两个元素的位置</div><div>                2、对每一组相邻元素做相同的工作，从开始第一对元素到结尾最后一对元素，最终最后位置的元素就是最大（小）值。</div><div>        api设计</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 588px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 588px; padding: 8px; border: 1px solid;"><div>Bubble</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 588px; padding: 8px; border: 1px solid;"><div>Bubble();创建 Bubble对象</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 588px; padding: 8px; border: 1px solid;"><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static boolean greate(Comparable v,Comparable w);判断v是否大于w</div><div>3、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr></tbody></table><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Bubble{</div><div>    public static void sort(Comparable[] a){</div><div>        for(int i=0;i&lt;a.length-1;i++){</div><div>            for(int j=0;j&lt;a.length-i-1;j++){</div><div>                if(greate(a[j],a[j+1])){</div><div>                    exch(a,j,j+1);</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>    private static boolean greate(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&gt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Bubble{</div><div>    public static void sort(Comparable[] a){</div><div>        for(int i=a.length-1;i&gt;0;i--){</div><div>            for(int j=0;j&lt;i;j++){</div><div>                if(greate(a[j],a[j+1])){</div><div>                    exch(a,j,j+1);</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>    private static boolean greate(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&gt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div>}</div></div><div>冒泡排序的时间复杂度为：O(n^2)</div><div><br/></div><div><span style="font-weight: bold;">2、选择排序</span></div><div>        排序原理：</div><div>            1、每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值一次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，最后可以找到最小值所在的索引</div><div>            2、交换第一个索引处和最小值所在索引处的值。</div><div>        选择排序api</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 120px;"></col><col style="width: 588px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>类名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Selection</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>构造方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Selection();创建 Selection对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>成员方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static boolean greate(Comparable v,Comparable w);判断v是否大于w</div><div>3、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr></tbody></table><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Selection{</div><div>    public static void sort(Comparable[] a){</div><div>       </div><div>        for(int i=0;i&lt;a.length-1;i++){</div><div>            int n=i;</div><div>            for(int j=i+1;j&lt;a.length;j++){</div><div>                if(greate(a[n],a[j])){</div><div>                    n=j;</div><div>                }</div><div>            }</div><div>            exch(a,i,n);</div><div>        }</div><div>    }</div><div>    private static boolean greate(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&gt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div>}</div></div><div>选择排序的时间复杂度：</div><div>    O(n^2)</div><div><br/></div><div><span style="font-weight: bold;">3、插入排序</span></div><div>        插入排序的工作方式非常像人们排序一手扑克牌一样，开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入到左手的正确位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</div><div>      排序原理：</div><div>            1、把所有元素分为两组，已经排序的和未排序的。</div><div>            2、找到未排序的组中的第一个元素，向已经排序的组中进行插入。</div><div>            3、倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。</div><div>    </div><div>    api</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 120px;"></col><col style="width: 588px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>类名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Insertion</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>构造方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Insertion();创建 Insertion对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>成员方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static boolean greate(Comparable v,Comparable w);判断v是否大于w</div><div>3、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr></tbody></table><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Insertion{</div><div>    public static void sort(Comparable[] a){</div><div>       for(int i=1;i&lt;a.length;i++){</div><div>           for(int j=i;j&gt;0;j--){</div><div>               if(greate(a[j-1],a[j])){</div><div>                    exch(a,j-1,j);</div><div>               }else{</div><div>                    break;</div><div>               }</div><div>           }     </div><div>       }</div><div>       </div><div>    }</div><div>    private static boolean greate(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&gt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div>}</div></div><div><br/></div><div>插入排序的时间复杂度：</div><div>    O(n^2)</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">高级排序</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">1、希尔排序</span></div><div>    希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序的一种更高效地改进版本。</div><div>    排序原理：</div><div>        1、选定一个增长量h,按照增长量h作为数据分组的依据，对数据进行分组。</div><div>        2、对分好组的每一组数据完成插入排序。</div><div>        3、减小增长量，最小减为1，重复第二步操作。</div><div><br/></div><div>增长量h的确定：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int h=1;</div><div>while(h&lt;数组长度/2){</div><div>    h=2h+1；</div><div>}</div><div>//循环结束后我们就可以确定h的最大值</div><div>h的减小规则为：</div><div>    h=h/2</div></div><div><br/></div><div>    api</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 120px;"></col><col style="width: 588px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>类名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Shell</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>构造方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>Shell();创建 Shell对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 120px; padding: 8px;"><div>成员方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 588px; padding: 8px;"><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static boolean greate(Comparable v,Comparable w);判断v是否大于w</div><div>3、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr></tbody></table><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Shell{</div><div>    public static void sort(Comparable[] a){</div><div>      //根据数组的长度，确定增长量h的初始值</div><div>        while(h&lt;a.length/2){</div><div>            h=2*h+1;</div><div>        }</div><div>        while(h&gt;=1){</div><div>            //排序</div><div>            //第一步、找到待插入的元素</div><div>            for(int i=h;i&lt;a.length;i++){</div><div>                //第二步、把待插入的元素插入到有序数列中</div><div>                for(int j=i;j&gt;=h;j-=h){</div><div>                     if(greate(a[j-h],a[j])){</div><div>                        //交换元素</div><div>                        exch(a,j-h,j);</div><div>                     }else{</div><div>                        //待插入的元素已经找到了合适的位置</div><div>                        break;</div><div>                      }</div><div>                }</div><div>            }</div><div>          </div><div>            //减小h的值</div><div>            h=h/2;   </div><div>        }</div><div>    }</div><div>    private static boolean greate(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&gt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div>}</div></div><div><br/></div><div>希尔排序的时间复杂度分析</div><div>    用事后分析法对希尔排序和插入排序进行比较分析</div><div>    当需要排序的数据为1-100000的逆序时，</div><div>        插入排序所需时间为：37499ms</div><div>        希尔排序所需时间为：30ms</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>递归：</div><div>        定义：定义方法时，在方法内部调用方法本身，称之为递归。</div><div>        作用：它通常把一个大型复杂问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出过程所需要的多次重复计算，大大地减少了程序的代码量。</div><div>        注意事项：在递归中，不能无限的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。</div></div><div><span style="font-size: 12pt; font-weight: bold;">2、归并排序</span></div><div><span style="font-size: 12pt; font-weight: bold;">   </span><span style="font-size: 10pt; font-weight: bold;"> 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称之为二路归并。</span></div><div>   排序原理：</div><div>        1、尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</div><div>        2、将相邻的两个子组进行合并成一个有序的大组。</div><div>        3、不断地重复步骤二，直到最终只有一个组为止。</div><div>    </div><div>    api设计</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 112px;"></col><col style="width: 790px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div>类名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div>Merge</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div>构造方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div>Merge();创建 Merge对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div>成员方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div><br/></div><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static void sort(Comparable[] a,int lo,int hi);对数组a从索引lo到索引hi之间的元素进行排序</div><div>3、pricate static void merge(Comparable[]a,int lo,int mid,int hi);从索引lo到索引mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从索引lo到索引hi）</div><div>4、private static boolean less(Comparable v,Comparable w);判断v是否小于w</div><div>5、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div>成员变量</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div>1、private static Comparable[] assist;完成归并操作需要的辅助数组</div></td></tr></tbody></table><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class  Shell{</div><div>    private static Comparable[] assist;</div><div>    public static void sort(Comparable[] a){</div><div>         //1、初始化辅助数组 assist</div><div>            assist=new Comparable[a.length];</div><div>         //2、定义一个lo变量和hi变量，分别记录数组中最小的索引和最大的索引</div><div>            int lo=0;</div><div>            int hi=a.length-1;</div><div>         //3、调用shot重载方法完成数组a中，从索引lo到索引hi的元素的排序</div><div>            sort(a,lo,hi);</div><div>    }</div><div>    private static void sort(Comparable[] a,int lo,int hi){</div><div>        //安全性校验</div><div>            if(hi&lt;=lo){</div><div>                return;</div><div>            }</div><div>        //对lo到hi之间的数据进行分组，分为两个组</div><div>            int mid=lo+(hi-lo)/2;</div><div>        //分别对每一组进行排序</div><div>            sort(a,lo,mid);</div><div>            sort(a,mid+1,hi);</div><div>        //再把两个组中的数据进行归并</div><div>            merge(a,lo,mid,hi);</div><div>    }</div><div>    pricate static void merge(Comparable[]a,int lo,int mid,int hi){</div><div>    //定义三个指针</div><div>    int i=lo;//辅助数组的指针</div><div>    int p1=lo;//左子组的指针</div><div>    int p2=mid+1;//右子组的指针</div><div>    //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处</div><div>    while(p1&lt;=mid&amp;&amp;p2&lt;=hi){</div><div>        //比较对应索引处的值</div><div>        if(less(a[p1],a[p2])){</div><div>            assist[i++]=a[p1++];</div><div>        }else{</div><div>            assist[i++]=a[p2++];</div><div>            }</div><div>    }</div><div>    //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处</div><div>    while(p1&lt;=mid){</div><div>        assist[i++]=a[p1++];</div><div>    }</div><div>    //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处</div><div>    while(p2&lt;=hi){</div><div>        assist[i++]=a[p2++];</div><div>    }</div><div>    //把辅助数组中的元素copy到原数组中</div><div>    for(int index=lo;index&lt;=hi;index++){</div><div>        a[index]=assist[index];</div><div>    }</div><div>    }</div><div>    private static boolean less(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&lt;0;    </div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>        Comparable temp;</div><div>        temp=a[i];</div><div>        a[i]=a[j];</div><div>        a[j]=temp;</div><div>    }</div><div> </div><div>}</div></div><div><br/></div><div>归并排序的时间复杂度分析：</div><div>    O( nlog(n) )</div><div>缺点：需要申请额外的1数组空间，空间复杂度提升，典型的以空间换时间。</div><div>    希尔排序和归并排序效率比较：</div><div>            通过事后分析法得出，希尔排序和归并排序的效率是差不多的。在实际开发中，选择哪种排序还需要考虑排序算法的稳定性。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3、快速排序</span></div><div>    排序原理：</div><div>        1、首先设定一个分界值，通过该分界值将数组分成左右两部分。</div><div>        2、将大于或者等于分界值的数据放到数组右边，小于分界值的数据方到数组的左边，此时左边的部分中各元素都小于或者等于分界值，而右边部分中各元素都大于或者等于分界值。</div><div>        3、然后，左边和右边的数据可以独立排序，对于左侧的数组数据，又可以取一个分界值，将该部分部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</div><div>        4、重复上述过程，可以看出，这是一个递归定义。通过递归将左侧的部分排好序后，在递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</div><div><br/></div><div>    api设计</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 100px;"></col><col style="width: 790px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 100px; padding: 8px;"><div>类名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div>Quick</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 100px; padding: 8px;"><div>构造方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div>Quick();创建 Quick对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 100px; padding: 8px;"><div>成员方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 790px; padding: 8px;"><div><br/></div><div>1、public static void sort(Comparable[] a) 对数组内的元素进行排序</div><div>2、private static void sort(Comparable[] a,int lo,int hi);对数组a从索引lo到索引hi之间的元素进行排序</div><div>3、private static int partition(Comparable[]a,int lo,int hi);对数组a中，从索引lo到索引hi之间的元素进行分组，并返回分组界限对应的索引</div><div>4、private static boolean less(Comparable v,Comparable w);判断v是否小于w</div><div>5、private static void exch(Comparable[] a,int i,int j);交换a数组中，索引i和j处的值</div></td></tr></tbody></table><div><span style="font-weight: bold;">切分原理：</span></div><div>    把一个数组切分成两个子数组的基本思想</div><div>        1、找一个基准值，用两个指针分别指向数组的头部和尾部。</div><div>        2、先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置。</div><div>        3、再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置。</div><div>        4、交换当前左边指针位置和右边指针位置的元素。</div><div>        5、重复2、3、4步骤，直到左边指针的值大于或者等于右边指针的值停止。</div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Quick{</div><div>    public static void sort(Comparable[] a){   </div><div>        int lo=0;</div><div>        int hi=a.length-1;</div><div>        sort(a,lo,hi); </div><div>    } </div><div>    private static void sort(Comparable[] a,int lo,int hi){</div><div>        if(hi&lt;=lo){</div><div>            return;</div><div>        }</div><div>        int partition=partition(a,lo,hi);//返回的是分组的分界值所在的索引，分界值位置变化后的索引</div><div>        //让左子组有序</div><div>        sort(a,lo,partition-1);</div><div>        //让右子组有序</div><div>        sort(a,partition+1,hi);</div><div>    }</div><div>    private static int partition(Comparable[]a,int lo,int hi){</div><div>        //确定分界值(需要切分元素的第一个元素)</div><div>        Comparable key=a[lo];</div><div>        //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置</div><div>        int left=lo;</div><div>        int right=hi+1;</div><div>        //切分</div><div>        while(true){</div><div>            //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止</div><div>            while(less(key,a[--right])){</div><div>                //判断right是否左移超过边界值</div><div>                if(right==lo){</div><div>                    break;</div><div>                }</div><div>            }</div><div>            //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止</div><div>           while(less[a[++left],key){</div><div>                if(left==hi){</div><div>                    break;</div><div>                }</div><div>            }</div><div>            //判断left&gt;=right,结果为真证明元素扫描完毕，结束循环，如果不为真则交换元素即可</div><div>            if(left&gt;=right){</div><div>                break;</div><div>            }else{</div><div>                exch(a,left,right);</div><div>            }</div><div>        }</div><div>        // 交换分界值</div><div>        exch(a,lo,right);</div><div>        return right;</div><div>    }</div><div>    private static boolean less(Comparable v,Comparable w){</div><div>        return v.compareTo(w)&lt;0;</div><div>    }</div><div>    private static void exch(Comparable[] a,int i,int j){</div><div>    Comparable t=a[i];</div><div>    a[i]=a[j];</div><div>    a[j]=t;</div><div>    }</div><div>}</div></div><div>快速排序和归并排序的区别：</div><div>    快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，分为两部分独立的排序。快速排序和归并排序是互补的，归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就都有序了。在归并排序中，一个数组被等分成两半，归并调用发生在整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</div><div><br/></div><div><span style="font-weight: bold;">快速排序的时间复杂度分析：</span></div><div>    快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个快速排序的时间复杂度和切分的次数相关。</div><div>    <span style="font-weight: bold;">最优情况：</span>每一次切分选择的基准数字刚好将当前的序列等分。</div><div>共切分了 log(n)次，所以，最优情况快速排序的时间复杂度为O(nlog(n));</div><div>    <span style="font-weight: bold;">最坏情况：</span>每一次切分选择的基准数字是当前序列中的最大数或者最小数，这使的每次切分都会只有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2).</div><div>    <span style="font-weight: bold;">平均情况：</span>每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况快速排序的时间复杂度为O(nlog(n))。</div><div><br/></div></div><div><span style="font-size: 14pt; font-weight: bold;">排序的稳定性：</span></div><div>    <span style="font-weight: bold;">稳定性的定义：</span></div><div>        数组中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在</div><div>B元素的前面，可以说这个算法是稳定的。</div><div>  <span style="font-weight: bold;">  稳定性的意义：</span></div><div>        如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</div><div>  <span style="font-weight: bold;">  常见排序算法的稳定性：</span></div><div>      <span style="font-weight: bold;"> 1、冒泡排序：</span></div><div>                只有当arr[i]&gt;arr[i+1]的时候，才会交换元素的位置，而相等的时候并不会交换元素的位置，所以冒泡排序是一种<span style="font-weight: bold;">稳定排序算法</span>。</div><div>        <span style="font-weight: bold;">2、选择排序：</span></div><div>                选择排序是给每个位置选择当前元素最小的，例如有数据（5(1),8,5(2),2,9）,第一遍选择到的元素为2，所以5(1)回和2进行交换位置，此时5(1)排到了5(2)的后面，所以选择排序是一种<span style="font-weight: bold;">不稳定的排序算法。</span></div><div>        <span style="font-weight: bold;">3、插入排序：</span></div><div>                比较元素是从有序序列的末尾开始，也就是想要插入元素和已经有序的最大者开始比起，如果比它大则直接插在它的后面，否则一致往前找直到找到它该插的位置。如果碰见一个插入元素相等的，那么要把插入元素放在相等元素的后面 ，所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入<span style="font-weight: bold;">排序是稳定的。</span></div><div>      <span style="font-weight: bold;">  4、希尔排序：</span></div><div>                希尔排序是不同步长对元素进行插入排序，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后稳定性可能就会被打乱，所以<span style="font-weight: bold;">希尔排序是不稳定的</span>。</div><div>        <span style="font-weight: bold;">5、归并排序：</span></div><div>                归并排序在归并的过程中，只有arr[i]&lt;arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，<span style="font-weight: bold;">归并排序是稳定的。</span></div><div>        <span style="font-weight: bold;">6、快速排序：</span></div><div>                快速排序需要一个基准值，在基准值右侧找一个比基准值小的元素，在基准值左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以<span style="font-weight: bold;">快速排序是一种不稳定的算法。</span> </div><div><br/></div><div><br/></div></span>
</div></body></html> 