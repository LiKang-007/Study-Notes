<html>
<head>
  <title>线性表</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3106"/>
<h1>线性表</h1>

<div>
<span><div>  <span style="font-weight: bold;">概述：</span> </div><div>     线性表是最基本的、最简单的、也是最常用的一种数据结构。一个线性表是n个具有相同特征的数据元素的有限序列。</div><div>        <span style="font-weight: bold;">前驱元素：</span>若A元素在B元素的前面，则称A为B的前驱元素。</div><div>        <span style="font-weight: bold;">后继元素：</span>若B元素在A元素的后面，则称B为A的后继元素。</div><div><span style="font-weight: bold;">线性表的特征：</span> 数据元素之间具有一种“一对一”的逻辑关系。</div><div>    1、第一个数据元素没有前驱，这个数据元素称为头结点。</div><div>    2、最后一个数据元素没有后继，这个数据元素被称为尾节点。</div><div>    3、除了第一个和最后一个数据元素外，其他数据元素有且只有一个前驱和一个后继。</div><div><span style="font-weight: bold;">线性表的分类：</span></div><div>    线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">1.1顺序表</span></div><div><span style="font-size: 14pt; font-weight: bold;">   </span> <span style="font-size: 10pt;">顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储就是指用一组地址连续的存储单元，依次存储线性表中的各个元素。</span></div><div><span style="font-size: 10pt;">1.1.1顺序表的实现</span></div><div><span style="font-size: 10pt;">    顺序表API设计：</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 88px;"></col><col style="width: 258px;"></col></colgroup><tbody><tr><td style="width: 88px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div>SequenceList&lt;T&gt;</div></td></tr><tr><td style="width: 88px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div>SequenceList(int capacity)创建容量为capacity的SequenceList对象</div></td></tr><tr><td style="width: 88px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div>1、public void clear()空置线性表</div><div>2、public boolean isEmpty判断线性表是否为空，是返回true，否返回false</div><div>3、public int length获取线性表中元素的个数</div><div>4、public T get(int i)读取并返回线性表中的第i个元素的值</div><div>5、public void insert(int i,T t)在线性表的第i个元素之前插入一个值为t的数据元素</div><div>6、public void insert(T t)向线性表中添加一个元素t</div><div>7、public T remove(int i)删除并返回线性表中第i个数据元素</div><div>8、public int indexOf(T t)返回线性表中首次出现的指定元素的数据元素的位序号，若不存在，则返回-1.</div></td></tr><tr><td style="width: 88px; padding: 8px; border: 1px solid;">成员变量</td><td style="width: 258px; padding: 8px; border: 1px solid;"><div>1、private T[] eles 存储元素的数组</div><div>2、private int N:当前元素的长度</div></td></tr></tbody></table><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font><font style="font-size: 10pt;">public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{</font></font></div><div><font><font style="font-size: 10pt;">    private T[] eles;</font></font></div><div><font><font style="font-size: 10pt;">    private int N;</font></font></div><div><font>    public SequenceList(int capacity){</font></div><div>        //初始化数组</div><div>        this.eles=(T[])new Object[capacity];</div><div>        //初始化长度</div><div>        this.N=0;</div><div>    }</div><div>    public void clear(){</div><div>        this.N=0;</div><div>    }</div><div>    public boolean isEmpty(){</div><div>        return N==0;</div><div>    }</div><div>    public int length(){</div><div>        return N;</div><div>    }</div><div>    public T get(int i){</div><div>        return eles[i];</div><div>    }</div><div>    public void insert(T t){</div><div>        if(N==eles.length){</div><div>            resize(2*eles.length);</div><div>        }</div><div>        eles[N++]=t;</div><div>    }</div><div>    public void insert(int i,T t){</div><div>        if(N==eles.length){</div><div>            resize(2*eles.length);</div><div>        }</div><div>        //先把i索引处的元素及其后面的元素依次向后移动一位</div><div>        for(int j=N-1;j&gt;=i;j--){</div><div>            eles[j+1]=eles[j];</div><div>        }</div><div>        //再把t元素放到i索引处即可</div><div>        eles[i]=t;</div><div>        //总长度加1</div><div>        N=N+1;</div><div>    }</div><div>    public T remove(int i){</div><div>        //记录索引i处的值</div><div>        T current =eles[i];</div><div>        //索引i后面的元素依次向前移动一位</div><div>        for(int j=i;j&lt;N-1;j++){</div><div>            eles[j]=eles[j+1];</div><div>        }</div><div>        //元素个数-1</div><div>        N--;</div><div>        if(N&lt;eles.length/4){</div><div>            resize(eles.length/2);</div><div>        }</div><div>        return current;</div><div>    }</div><div>    public int indexOf(T t){</div><div>        for(int i=0;i&lt;N;i++){</div><div>            if(eles[i].equals(t)){</div><div>                return i;</div><div>            }</div><div>        }</div><div>        return -1;</div><div>    }</div><div>    //实现容器的遍历</div><div>    public Iterator&lt;T&gt; iterator(){</div><div>        return new SIterator; //定义的内部类实现Iterator接口</div><div>    }</div><div>    private class SIterator implements Iterator{</div><div>        private int cusor;</div><div>        public SIterator(){</div><div>            this.cusor=0;</div><div>        }</div><div>        //判断容器之中还有没有下一个元素</div><div>        @Override</div><div>        public boolean hasNext(){</div><div>            return cusor&lt;N;</div><div>        }</div><div>        //返回容器元素</div><div>        @Override</div><div>        public Object next(){</div><div>            return eles[cusor++];</div><div>        }</div><div>    }</div><div>    //根据参数newSize，重置eles的大小</div><div>    public void resize(int newSize){</div><div>        //定义一个临时数组，指向原数组  </div><div>        T[] temp=eles;  </div><div>        //创建新数组</div><div>        eles=(T[])new Object[newSize];</div><div>        //把原数组的数据拷贝到新数组即可</div><div>        for(int i=0;i&lt;N;i++){</div><div>            eles[i]=temp[i]; </div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div></div><div><span style="font-weight: bold;">顺序表的遍历：</span></div><div>    一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。</div><div>    在java 中，遍历集合的方式一般都是用foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：</div><div>        1、让SequenceList实现Iterable接口，重写iteration方法；</div><div>        2、在SequenceList内部提供一个内部类Slterator实现Iterator接口，重写hasNext方法和next方法；</div><div><span style="font-size: 10pt; font-weight: bold;">顺序表的容量可变</span></div><div><span style="font-size: 10pt;">    考虑容器的容量伸缩性，其实就是改变存储元素的数组的大小，那需要在什么时候改变数组的大小呢？</span></div><div><span style="font-size: 10pt;"> </span> <span style="font-size: 10pt; font-weight: bold;">  1、添加元素时</span><span style="font-size: 10pt;">，应该检查当前数组的大小是否能够容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们创建一个是原数组两倍容量的新数组存储元素。</span></div><div><span style="font-size: 10pt;">   </span> <span style="font-size: 10pt; font-weight: bold;">2、移除元素时</span><span style="font-size: 10pt;">，应该检查当前数组大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量1/2的新数组存储元素。</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-weight: bold;">顺序表的时间复杂度：</span></div><div>    get(i):O(1);</div><div>    insert(int i,T t):O(n);</div><div>    remove(int i):O(n);</div><div>    由于顺序表的底层是有数组实现的，数组的长度是固定的，所以在操作过程中可能会涉及到容器的扩容操作，这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的节点处，耗时会突增，尤其是元素越多，这个问题越明显。</div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">java中的ArrayList实现</span></span></div><div><span style="font-size: 13.3333px;">    java中的ArrayList集合底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。</span></div><div><span style="font-size: 13.3333px;">ArrayList源码：</span></div><div><span style="font-size: 13.3333px;">    1、用数组实现；</span></div><div><span style="font-size: 13.3333px;">    2、有扩容操作；</span></div><div><span style="font-size: 13.3333px;">    3、提供了foreach遍历方式；</span></div><div><span style="font-size: 13.3333px;">    </span></div><div><span style="font-size: 14pt; font-weight: bold;">链表</span></div><div><span style="font-size: 13.3333px;"><br/></span></div><div><span style="font-size: 13.3333px;">节点API设计</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 266px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div>Node&lt;T&gt;</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div>Node(T t,Node next):创建Node对象</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div>T item:存储数据</div><div>Node next：指向下一个节点</div></td></tr></tbody></table><div>节点类实现</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Node&lt;T&gt;{</div><div>    //存储元素</div><div>    public T item;</div><div>    //指向下一个节点</div><div>    public Node next；</div><div>    public Node(T item,Node next){</div><div>        this.item=item;</div><div>        this.next=next;</div><div>    }</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">单向链表</span></div><div>    单向链表是链表的一种，它由多个节点组成，每个节点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其他后继节点，链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的节点。</div><div><span style="font-size: unset;"><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;"> 单向链表API设计</span></span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 120px;"></col><col style="width: 274px;"></col></colgroup><tbody><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 274px; padding: 8px; border: 1px solid;"><div>LinkList&lt;T&gt;</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 274px; padding: 8px; border: 1px solid;"><div>LinkList():创建LinkList对象</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 274px; padding: 8px; border: 1px solid;"><div>1、public void clear():空置线性表</div><div>2、public boolean isEmpty():判断线性表是否为空，是返回true，否返回false</div><div>3、public int length():获取线性表中元素的个数</div><div>4、public T get(int i):读取并返回线性表中第i个元素的值</div><div>5、public void insert(T t):往线性表中添加一个元素</div><div>6、public void  insert(int i,T t):在线性表的第i个元素之前插入一个值为t的数据元素</div><div>7、public T remove(int i):删除并返回线性表中第i个数据元素</div><div>8、public int indexOf(T t):返回线性表中首次出现指定的数据元素的位序号，若不存在，则返回-1</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>成员内部类</div></td><td style="width: 274px; padding: 8px; border: 1px solid;"><div>private class Node&lt;T&gt;节点类</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 274px; padding: 8px; border: 1px solid;"><div>1、private Node head：记录首节点</div><div>2、private int N:记录链表的长度</div></td></tr></tbody></table><div>单向链表代码实现    day02 46</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public </div></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">双向链表：</span></div><div><span style="font-size: 13.3333px;">    双向链表也叫双向表，是链表的一种，它由多个节点组成，每个节点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继节点，一个指针域用来指向其前驱节点。链表的头结点的数据域不存储数据，指向前驱节点的指针域值为null，指向后继节点的指针域指向第一个真正存储数据的节点。</span></div><div><span style="font-size: 13.3333px;">    按照面向对象的思想，我们需要设计一个类，来描述节点这个事物，由于节点是属于链表的，所以我们把节点类作为链表类的一个内部类来实现。</span></div><div><span style="font-weight: bold;">节点的API设计</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 286px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 286px; padding: 8px; border: 1px solid;"><div>Node&lt;T&gt;</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 286px; padding: 8px; border: 1px solid;"><div>Node(T t,Node pre,Node next):创建Node对象</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 286px; padding: 8px; border: 1px solid;"><div>T item:存储数据</div><div>Node next：指向下一个节点</div><div>Node pre：指向上一个节点</div></td></tr></tbody></table><div>双向链表API设计</div></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 112px;"></col><col style="width: 342px;"></col></colgroup><tbody><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 342px; padding: 8px; border: 1px solid;"><div>TowWayLinkList&lt;T&gt;</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 342px; padding: 8px; border: 1px solid;"><div>TowWayLinkList():创建TowWayLinkList对象</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 342px; padding: 8px; border: 1px solid;"><div>1、public void clear():空置线性表</div><div>2、public boolean isEmpty():判断线性表是否为空，是返回true，否返回false</div><div>3、public int length();获取线性表中元素的个数</div><div>4、public T get(int i):读取并返回线性表中的第i个元素</div><div>5、public void insert(T t):往线性表中添加一个元素</div><div>6、public void insert(int i,T t):在线性表中的指定位置插入一个值为t的数据元素</div><div>7、public T remove(int i):删除并返回线性表中的第i个数据元素</div><div>8、public T getFirst():获取第一个元素</div><div>9、public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</div><div>10、public T getLast():获取最后一个元素</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div>成员内部类</div></td><td style="width: 342px; padding: 8px; border: 1px solid;"><div>private class Node&lt;&gt;:节点类</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 342px; padding: 8px; border: 1px solid;"><div>1、private Node first：记录首节点</div><div>2、private Node last：记录尾节点</div><div>3、private int N记录链表的长度</div></td></tr></tbody></table><div>双向链表代码实现（day02 50）</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div><span style="font-size: 13.3333px;"><br/></span></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">java中的 LinkedList实现</span></span></div><div><span style="font-size: 13.3333px;">    java中的LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法。</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">链表的时间复杂度：</span></span></div><div><span style="font-size: 13.3333px;">    get(int i)：时间复杂度为O(n)</span></div><div><span style="font-size: 13.3333px;">    insert(int i,T t):时间复杂度为O(n)</span></div><div><span style="font-size: 13.3333px;">    remove(int i):时间复杂度为O(n</span><span style="font-size: 13.3333px; color: unset; font-family: unset;">)</span></div><div>    相比于顺序表，链表插入和删除的时间复杂度虽然一样，但任然具有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作，同时它没有涉及到元素的交换。</div><div>  <span style="font-weight: bold;">  相比于顺序表，链表的查询操作性能会比较低，因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</span></div><div><br/></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">链表反转：（面试）</span></div><div><font style="font-size: 10pt;"><br/></font></div><div>需求：原链表中数据为：1-&gt;2-&gt;3-&gt;4</div><div>            反转后链表中数据为：4-&gt;3-&gt;2-&gt;1</div><div><br/></div><div>反转API：</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 162px;"></col><col style="width: 250px;"></col></colgroup><tbody><tr><td style="width: 162px; padding: 8px; border: 1px solid;"><div>public void reverse()</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div>对整个链表反转</div></td></tr><tr><td style="width: 162px; padding: 8px; border: 1px solid;"><div>public Node reverse(Node curr)</div></td><td style="width: 250px; padding: 8px; border: 1px solid;">反转链表中的某个节点curr，依次递归调用反转每一个节点，直到最后一个节点反转完毕，整个链表就反转完毕</td></tr></tbody></table><div><br/></div></div><div>使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的节点开始，依次递归调用反转每一个节点，直到把最后一个节点反转完毕，整个链表就反转完毕了。</div><div><img src="线性表_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void reverse(){</div><div>    if(isEmpty()){</div><div>        return;</div><div>    }</div><div>    reverse(head.next){</div><div>    }</div><div>}</div><div>public Node reverse(Node curr){</div><div>    if(curr.next==null){</div><div>        head.next=curr;</div><div>        return curr;</div><div>    }</div><div>    reverse(curr.next).next=curr;</div><div>    return curr;</div><div>}</div></div><div><img src="线性表_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">快慢指针</span></div><div>快慢指针指的是定义两个指针，这两个指针的移动速度一快一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的节点。一般情况下，快指针移动的步长为满指针的两倍。</div><div><span style="font-weight: bold;">快慢指针可以解决的问题：</span></div><div><span style="font-size: 13.3333px;">1、中间值问题：（比如说，一个链表有七个节点，需要获取的是第四个节点的值）</span></div><div><img src="线性表_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div> T getMid(Node&lt;T&gt; first){}//返回链表中间节点的值</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>T getMid(Node&lt;T&gt; first){</div><div>    Node&lt;T&gt; fast=first;</div><div>    Node&lt;T&gt; show=first;</div><div>    while(fast!=null&amp;&amp;fast.next!=null){</div><div>        fast=fast.next.next;</div><div>        show=show.next;</div><div>    }</div><div>    return slow.value;</div><div>}</div></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">2、单项链表是否有环问题：</span></span></div><div><img src="线性表_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="线性表_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="线性表_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>API</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>boolean isCircle()//判断单向链表是否有环</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>boolean isCircle(){</div><div>Node&lt;T&gt; fast=first;</div><div>Node&lt;T&gt; slow=first;</div><div>while(fast!=null&amp;&amp;fast.next!=null){</div><div>    //变换fast和show</div><div>    fast=fast.next.next;</div><div>    show=next;</div><div>    if(fast.equals(slow)){</div><div>        return true;</div><div>    }</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    return false;</span></div><div>}</div></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">3、有环链表环的入口问题：</span></span></div><div><span style="font-size: 13.3333px;">理论：当快慢指针相遇时，可以判断出链表中有环，这是重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与新指针相遇的节点就是环的入口。</span></div><div><span style="font-size: 13.3333px;">API</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Node getEntrance(Node&lt;T&gt; first)//返回有环链表的环入口节点</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Node getEntrance(Node&lt;T&gt; first){</div><div>    //定义快慢指针</div><div>    Node&lt;T&gt; fast=first;</div><div>    Node&lt;T&gt; slow=first;</div><div>    Node&lt;T&gt; index=null;</div><div>    while(fast!=null&amp;&amp;fast.next!=null){</div><div>        fast=fast.next.next;</div><div>        slow=slow.next;</div><div>        if(fast.equals(slow)){</div><div>           index=first;</div><div>            continue;</div><div>        }</div><div>        if(index!=null){</div><div>            index=index.next;</div><div>            if(index.equals(slow)){        </div><div>                break;</div><div>            }</div><div>        }</div><div>    }</div><div>    return index;</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">循环链表：</span></div><div>    循环链表，将单向链表中的尾节点指向头结点即可。</div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;">循环链表的应用：</span></div><div><span style="font-size: 10pt;">    约瑟夫问题：</span></div><div><span style="font-size: 10pt;">        问题描述：</span><span style="color: unset; font-family: unset; font-size: 10pt;">    </span><img src="线性表_files/Image [6].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;"/></div><div><span style="font-size: 10pt;">        问题转换：</span></div><div><span style="font-size: 10pt;">            41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n；</span></div><div><span style="font-size: 10pt;">            1、编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</span></div><div><span style="font-size: 10pt;">            2、自退出那个人开始的下一个再次从1开始报数，依次类推；</span></div><div><span style="font-size: 10pt;">            3、求最后退出的那个人的编号。</span></div><div><br/></div><div><span style="font-size: 10pt;">        图示：</span></div><div><span style="font-size: 10pt;">            </span><img src="线性表_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">        解题思路：</span></div><div><span style="font-size: 10pt;">            1、构建含有41个节点的单向循环链表，分别存储1-41的值，分别代表这41个人。</span></div><div><span style="font-size: 10pt;">            2、使用计数器count，记录当前报数的值。</span></div><div><span style="font-size: 10pt;">            3、遍历链表，每循环一次，count++。</span></div><div><span style="font-size: 10pt;">            4、判断count的值，如果是3，则从链表中删除这个节点并打印节点的值，把count重置为0；</span></div><div><br/></div><div>解决约瑟夫问题：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public static void main(String[] args){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //构建循环链表，包含41个节点，分别存储1-41之间的值</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Node&lt;Integer&gt;first=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Node&lt;Integer&gt;pre=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    for(int i=1;i&lt;=41;i++){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //如果是第一个节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        if(i==1){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            first=new Node&lt;&gt;(i,null);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            pre=first;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            continue;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //如果不是第一个节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            Node&lt;Integer&gt;newNode=new Node&lt;&gt;(i,null);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            pre.next=newNode;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            pre=newNode;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //如果是最后一个节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            if(i==41){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                pre.next=first;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //需要count计数器，模拟报数</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            int count=0;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //记录每次遍历拿到的节点，默认从首节点开始</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            Node&lt;Integer&gt; n=first;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //记录当前节点的上一个节点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            Node&lt;Integer&gt;before=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    </span>//遍历循环链表</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            while(n!=n.next){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //模拟报数    </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                count++；</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //判断当前报数是不是3</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                if(count==3){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //如果是3，就把当前节点删除调用，打印当前节点，重置count=0，让当前节点n后移</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    before.next=n.next;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    System.out.print(n.value+&quot;,&quot;);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    count=0;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    n=n.next;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                }else{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //如果不是3，让before变为当前节点，让当前节点后移；</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    before=n;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                    n=n.next;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //打印最后一个元素：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        System.out.print(n.value);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><span style="font-weight: bold; font-size: 12pt;">栈</span></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">先进后出</span></font></div><div><span style="font-size: 10pt;">数据进入到栈的动作称为</span><span style="font-size: 10pt; font-weight: bold;">压栈</span><span style="font-size: 10pt;">，数据从栈中出去的动作称为</span><span style="font-size: 10pt; font-weight: bold;">弹栈。</span></div><div><span style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">栈的API设计</span></span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 92px;"></col><col style="width: 272px;"></col></colgroup><tbody><tr><td style="width: 92px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">类名</span></div></td><td style="width: 272px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Stack&lt;T&gt;</span></div></td></tr><tr><td style="width: 92px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">构造方法</span></div></td><td style="width: 272px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Stack()：创建Stack对象</span></div></td></tr><tr><td style="width: 92px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">成员方法</span></div></td><td style="width: 272px; padding: 8px; border: 1px solid;"><div>public boolean isEmpty()//判断栈是否为空，是返回true，否返回false</div><div>public int size():获取栈中元素的个数</div><div>public T pop()弹出栈顶元素</div><div>public void push(T t)向栈中压入元素t</div></td></tr><tr><td style="width: 92px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">成员变量</span></div></td><td style="width: 272px; padding: 8px; border: 1px solid;"><div>private Node head:记录首节点</div><div>private Node last;记录尾节点</div><div>private int N:当前栈的元素个数</div></td></tr><tr><td style="width: 92px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">成员内部类</span></div></td><td style="width: 272px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">private class Node：节点类</span></div></td></tr></tbody></table><div>栈代码实现：（链表实现）（day03 66）</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div>栈代码实现：（数组实现）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><br/></b></div></div><div><span style="font-weight: bold; font-size: 10pt;">栈的应用案例</span></div><div><span style="font-size: 12pt; font-weight: bold;"> </span> <span style="font-weight: bold; font-size: 10pt;">  1、括号匹配问题：</span></div><div><span style="font-weight: bold; font-size: 10pt;">        问题描述：给定一个字符串，里面可能包含“（）”小括号和其他字符，请编写程序检查该字符串中的小括号是否成对出现。</span></div><div><span style="font-weight: bold;"><img src="线性表_files/Image [8].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="线性表_files/Image [9].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 13.3333px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//遍历字符串，每遇到一个左括号，就将左括号压栈，遇到一个右括号就弹出一个左括号。</div><div>public boolean isMatch(String str){</div><div>    //1、创建栈对象，用来存储左括号</div><div>    Stack&lt;String&gt; stack=new Stack();</div><div>    //2、从左往右遍历字符串</div><div>    for(int i=0;i&lt;str.length();i++){</div><div>        String currChar=str.charAt(i)+&quot;&quot;;//将字符转为字符串</div><div>        //3、判断当前字符是否为左括号，如果是，则把字符放入到栈中</div><div>        if(currChar.equals(&quot;(&quot;)){</div><div>            stack.push(currChar);</div><div>            //4、继续判断当前字符是否右括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null，如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号。</div><div>        }else if(currChar.equals(&quot;)&quot;)){</div><div>             String pop=stack.pop();   </div><div>             if(pop==null){</div><div>                return false;</div><div>             }</div><div>         }</div><div>    }</div><div>    //5、判断栈中还有没有剩余的左括号，如果有则证明括号不匹配</div><div>    if(stack.size()==0){</div><div>        return true;</div><div>    }else{</div><div>        return false;</div><div>     }</div><div>}</div></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">2、逆波兰表达式求值问题</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">    （1）中缀表达式：</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">                中缀表达式就是平时生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">                中缀表达式是人们最喜欢的表达方式，因为简单，易懂，但对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级，相关操作。</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">    （2）逆波兰表达式（后缀表达式）</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">                后缀表达式的特点：运算符总是放在跟它相关的操作数之后。</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">            例如</span></div><div style="font-size: 13.3333px;"><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">中缀表达式</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">逆波兰表达式</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">a+b</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">ab+</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">a+(b-c)</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">abc-+</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">a+(b-c)*d</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">abc-d*+</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">a*(b-c)+d</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">abc-*d+</span></div></td></tr></tbody></table><div><span style="font-size: 13.3333px;">需求：给定一个包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static int caculate(String[] notaion){</div><div>    </div><div>    return -1;</div><div>}</div></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;"><img src="线性表_files/Image [10].png" type="image/png" data-filename="Image.png"/></span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;"><img src="线性表_files/Image [11].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold; font-size: 12pt;">队列</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">先进先出</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px; font-weight: bold;">队列的API设计</span></div><div style="font-size: 13.3333px;"><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 94px;"></col><col style="width: 266px;"></col></colgroup><tbody><tr><td style="width: 94px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">类名</span></div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><span style="font-size: 13.3333px;">Queue</span></td></tr><tr><td style="width: 94px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">构造方法</span></div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><span style="font-size: 13.3333px;">Queue()：创建Queue对象</span></td></tr><tr><td style="width: 94px; padding: 8px; border: 1px solid;"><span style="font-size: 13.3333px;">成员方法</span></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">public boolean isEmpty()：判断队列是否为空，是返回true，否返回false</span></div><div><span style="font-size: 13.3333px;">public int size():获取队列中元素的个数</span></div><div><span style="font-size: 13.3333px;">public T dequeue():从队列中拿出一个元素</span></div><div><span style="font-size: 13.3333px;">public void enqueue(T t):往队列中插入一个元素</span></div></td></tr><tr><td style="width: 94px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">成员变量</span></div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">private Node head：记录首节点</span></div><div><span style="font-size: 13.3333px;">private int N：当前栈的元素个数</span></div><div><span style="font-size: 13.3333px;">private Node last：记录最后一个节点</span></div></td></tr><tr><td style="width: 94px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">成员内部类</span></div></td><td style="width: 266px; padding: 8px; border: 1px solid;"><div><span style="font-size: 13.3333px;">private class Node：节点类</span></div></td></tr></tbody></table><div><span style="font-size: 13.3333px;">队列的实现</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">单向链表实现</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">    栈：从头插，从头出。</span></div><div style="font-size: 13.3333px;"><span style="font-size: 13.3333px;">    队列：从尾插，从头出。</span></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div style="font-size: 13.3333px;"><br/></div><div><br/></div></span>
</div></body></html> 