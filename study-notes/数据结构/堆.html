<html>
<head>
  <title>堆</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3175"/>
<h1>堆</h1>

<div>
<span><div><span style="font-size: 12pt; font-weight: bold;">堆的特性：</span></div><div>    1、它是完全二叉树，除了树的最后一层节点不需要是满的，其他的每一层从左到右都是满的，如果最后一层节点不是满的，那么要求左满右不满。</div><div><img src="堆_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>    2、它通常用数组实现：</div><div>    具体方法就是将二叉树的节点按照层级顺序放入到数组中，根节点在位置1，它的子节点在位置2和3，而子节点的子节点分别在位置4,5,6和7，以此类推。</div><div><img src="堆_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>如果一个节点的位置为k，则它的父节点位置为[k/2],而它的两个子节点的位置分别为2k和2k+1。这样在不使用指针的情况下，也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就令k等于2k或者2k+1。</div><div>    3、每个节点都大于等于它的两个子节点。注意堆中仅仅规定了每个节点大于等于它的两个子节点，但这两个子节点的顺序并没有做规定，和二叉查找树是有区别的。</div><div><span style="font-size: 12pt; font-weight: bold;">堆的API设计</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 128px;"></col><col style="width: 306px;"></col></colgroup><tbody><tr><td style="width: 128px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 306px; padding: 8px; border: 1px solid;"><div>Heap&lt;T extends Comparable&lt;T&gt;&gt;</div></td></tr><tr><td style="width: 128px; padding: 8px; border: 1px solid;"><div>构造方法</div></td><td style="width: 306px; padding: 8px; border: 1px solid;"><div>Heap(int capacity):创建容量为Heap对象</div></td></tr><tr><td style="width: 128px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 306px; padding: 8px; border: 1px solid;"><div>private boolean less(int i,int j):判断堆中的索引i处的元素是否小于索引j处的元素</div><div>private void exch(int i,int j):交换堆中i索引和j索引处的值</div><div>public T delMax():删除堆中最大的元素，并返回这个最大元素</div><div>public void insert(T t):往堆中插入一个元素</div><div>private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</div><div>private void sink(int k)：使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</div></td></tr><tr><td style="width: 128px; padding: 8px; border: 1px solid;"><div>成员变量</div></td><td style="width: 306px; padding: 8px; border: 1px solid;"><div>private T[] imtes：用来存储元素的数组</div><div>private int N:记录堆中元素的个数</div></td></tr></tbody></table><div>堆的实现</div></div><div><br/></div><div>堆的插入</div><div><img src="堆_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="堆_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void insert(T t){</div><div>    items[++N]=t;</div><div>    swim(N);</div><div>}</div><div>private void swim(int k){</div><div>    //通过循环，不断地比较当前节点的值和其父节点的值，如果发现父节点的值比当前节点的值小，则交换位置</div><div>    while(k&gt;1){</div><div>        //比较当前节点和其父节点</div><div>        if(less(k/2,k)){</div><div>            exch(k,k/2);</div><div>        }</div><div>        k=k/2;</div><div>    }</div><div>}</div></div><div>堆的删除：</div><div>    由堆的特性可以得出，索引1处的元素就是根节点处的元素，当我们把根节点处的元素删除了之后，需要有一个新的根节点出现，这时我们可以暂时把堆中的最后一个元素放入到索引1处，充当根节点，然后在使整个堆有序。</div><div><img src="堆_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="堆_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><img src="堆_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><img src="堆_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//删除堆中最大的元素，并返回这个最大元素</div><div>public T delMax(){</div><div>    T max=item[1];</div><div>    //交换索引1处的元素和最大索引处的元素，让完全二叉树最右侧的元素变为临时根节点</div><div>    exch(1,N);</div><div>    //最大索引处的元素删除掉</div><div>    items[N]=null;</div><div>    //元素个数-1</div><div>    N--;</div><div>    //通过下沉调整堆，让堆重新有序</div><div>    //sink(1);</div><div>    return max;</div><div>}</div><div>private void sink(int k){</div><div>    //通过循环不断地对比当前k节点和其左子节点2*k以及右子节点2*k+1的元素的大小，如果当前节点小，则需要交换位置，交换其和其字节节点中较大一个的位置。</div><div>    while(2*k&lt;=N){</div><div>        //获取当前节点的子节点中的较大节点</div><div>        int max;//记录较大索引的值</div><div>        if(2*k+1&lt;=N){</div><div>            if(less(2*k,2*k+1)){</div><div>                max=2K+1;</div><div>            }else{</div><div>                max=2K;</div><div>            }</div><div>        }else{</div><div>            max=2K;</div><div>        }</div><div>        //比较当前节点和较大节点的值</div><div>        if(less(k,max)){</div><div>            exch(k,max);</div><div>            k=max;</div><div>        }else{</div><div>            break;</div><div>        }</div><div>        </div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">堆排序：</span></div><div>    给定一个数组：</div><div>        String[]arr={&quot;S&quot;,&quot;O&quot;,&quot;R&quot;,&quot;T&quot;,&quot;E&quot;,&quot;X&quot;,&quot;A&quot;,&quot;M&quot;,&quot;P&quot;,&quot;L&quot;,&quot;E&quot;};</div><div>    对数组内的元素进行排序：</div><div>  <span style="font-weight: bold;">  API设计：</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 278px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>类名</div></td><td style="width: 278px; padding: 8px; border: 1px solid;"><div>HeapSort&lt;T extends Comparable&lt;T&gt;&gt;</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>成员方法</div></td><td style="width: 278px; padding: 8px; border: 1px solid;"><div>public static void sort(Comparable[] source):对数组内的元素进行从小到大排序</div><div>private static void createHeap(Comparable[] source,Comparable[] heap):根据原数组构造出堆</div><div>private static boolean less(Comparable[]heap,int i,int j):判断heap堆中索引i处的元素是否小于索引j处的元素</div><div>private static void exch(Comparable[] heap,int i,int j)：交换heap堆中索引i处和索引j处的值</div><div>private static void sink(Comparable[]heap,int target,int range):在heap堆中，对target处的元素做下沉，范围是0-range</div></td></tr></tbody></table><div><span style="font-weight: bold;">实现步骤：</span></div><div>    1、构造堆；</div><div>    2、得到栈顶元素，这个值就是最大值；</div><div>    3、交换栈顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；</div><div>    4、对堆进行调整，重新让除了最后一个元素的剩余元素中最大元素放到堆顶；</div><div>    5、重复2-4步骤，直到堆中仅剩一个元素。</div><div><br/></div><div>代码实现</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class HeapSort{</div><div>    private static boolean less(Comparable[]heap,int i,int j){</div><div>        return heap[i].CompareTo(heap[j]&lt;0);</div><div>    }</div><div>    priavte static void  exch(Comparable[] heap,int i,int j){</div><div>        Comparable tmp=heap[i];</div><div>        heap[i]=heap[j];</div><div>        heap[j]=tmp;</div><div>    }</div><div>    private static void createHeap(Comparable[] source,Comparable[] heap){</div><div>        //数组copy</div><div>        System.arraycopy(source,0,heap,1,source.length);</div><div>        for(int i=(heap.length/2);i&gt;0;){</div><div>            sink(heap,i,heap.length-1);</div><div>        }</div><div>    }</div><div><span>    //range是下沉的范围</span><br/></div><div>    private static void sink(Comparable[] heap,int target,int range){</div><div>        while(target*2&lt;=range){</div><div>            int max;</div><div>            if(taraget*2+1&lt;=range){</div><div>                if(less(heap,2*target,2*target+1)){</div><div>                    max=2*target+1;</div><div>                }else{</div><div>                    max=2*target;</div><div>                }</div><div>            }else{</div><div>                max=2*target;</div><div>            }</div><div>        }</div><div>        if(!less(heap,target,max)){</div><div>            break;</div><div>        }</div><div>        exch(heap,max,target);</div><div>        target =max;</div><div>    }</div><div>    public static void sort(Comparable[] source){</div><div>        //构建堆</div><div>        Comparable[] heap=new Comparable[source.length+1];</div><div>        //定义一个变量，记录未排序的元素中最大索引</div><div>        int N=heap.length-1;</div><div>        //通过循环，交换1索引处的元素和排序的元素中最大索引</div><div>        while(N!=1){</div><div>            //交换元素</div><div>            exch(heap,1,N);</div><div>            //排序交换后最大元素所在的索引，让它不参与堆的下沉</div><div>            N--;</div><div>            //需要对索引1处的元素进行下沉调整</div><div>            sink(heap,1,N);</div><div>        }</div><div>        //把heap中的数据复制到原数组中</div><div>        System.arraycopy(heap,1,source,0,source.length);</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">堆构造过程：</span></div><div>    堆的构造，最直观的想法就是另外再创建一个新数组，然后从左往右遍历原数组，每得到一个元素后，添加到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。</div><div>    更聪明的方式：</div><div>            创建一个新数组，把原数组中的[0-length-1]元素拷贝到新数组中的1-length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。（对非叶子节点进行下沉处理）</div><div><br/></div><div><span style="font-weight: bold;">堆排序过程：</span></div><div>    对构造好的堆，只需要做类似堆的删除操作，就可以完成排序。</div><div>        1、将堆顶元素和堆中最后一个元素交换位置；</div><div>        2、通过对堆顶元素下沉调整堆，把最大的元素放到堆顶（此时，最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边）</div><div>        3、重复1-2步骤，直到堆中剩最后一个元素。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 