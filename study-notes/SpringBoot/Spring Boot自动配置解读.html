<html>
<head>
  <title>Spring Boot自动配置解读</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6304"/>
<h1>Spring Boot自动配置解读</h1>

<div>
<span><div><span style="font-size: 14pt; font-weight: bold;">一、java中的SPI 可插拔原则（解耦和）</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="Spring Boot自动配置解读_files/Image.png" type="image/png" data-filename="Image.png"/></span></span></div><div>    SPI的全名为Service Provide Interface 大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档中有比较详细的介绍。</div><div>    简单总结下java SPI机制的思想。我们系统里抽象的各个模块，往往有很多的实现方案。面向对象的设计里，一般推荐模块之间基于接口编程，模块之间对于不同实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可插拔原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</div><div>    java SPI就是提供这样一个机制：为某个接口寻找服务实现的机制。有点类似于IOC的思想，就是将装配的控制权转移到程序之外，在模块化设计中这个机制尤为重要。</div><div>    </div><div>   <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">java SPI 规范</span></font></div><div>        要使用Java SPI，需要遵循如下约定：</div><div><img src="Spring Boot自动配置解读_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>    </div><div><span style="font-size: 14pt; font-weight: bold;">二、spring boot 源码的引入</span></div><div>    1、下载：（ <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">springboot 2.3及以上，已经使用gradle项目 进行项目构建</span>）</div><div>        github</div><div>    2、将压缩包解压到本地文件夹</div><div>    3、通过IDEA打开</div><div>    4、执行maven命令：clean install -DskipTests -Pfast</div><div>    5、创建自己的工程并运行</div><div><span style="font-size: 14pt; font-weight: bold;">三、springboot启动的初始化</span></div><div>    点击SpringBoot启动类的开始按钮之后,SpringBoot做了哪些工作？</div><div>       SpringApplication(primarySources).run(args)分为两步：</div><div>SpringApplication(primarySources)和run();</div><div>    首先看 SpringApplication(primarySources)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//new SpringApplciation 环境的初始化以及一些其他的准备工作</div><div>//run就是启动容器，以及自动配置类中的服务器的服务 </div><div>new SpringApplication(primarySources).run(args);<br/></div><div>    。</div><div>    。</div><div>    。</div><div><font face="Monaco">SpringApplciation类的构造方法中：</font></div><div><font style="font-family: Monaco;">    //设置初始化器    setInitializers((Collection)getSpringFactoriesInstances(ApplicationContextInitializer.class));</font></div><div><font face="Monaco">     //设置容器的监听器</font></div><div><font face="Monaco">setListeners((Collection)getSpringFactoriesInstances(ApplciationListener.class))</font></div><div><font face="Monaco">    。</font></div><div><font face="Monaco">    。</font></div><div><font face="Monaco">    。</font></div><div>查看getSpringFactoriesInstances()</div><div>该方法作用：获取spring.factories里面的实例对象</div><div>    。</div><div>    。</div><div>    。</div><div>//获取类加载器</div><div>ClassLoader classLoader= getClassLoader();</div><div>//获取当前的所有classpath下的spring.factories里面的类的名称</div><div>Set&lt;String&gt;names=new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type,classLoader));</div><div>//根据上一个步骤的name来创建实例对象</div><div>List&lt;T&gt; instances=createSpringFactoriesInstances(type,parameterTypes,classLoader,args,names);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    。</span></div><div><font face="Monaco">点进</font>loadFactoryNames，查看如何加载文件中的类名称</div><div>    。</div><div>    。</div><div>    。</div><div>点进loadSpringFactories(classLoader);</div><div>    。</div><div>    。</div><div>    。</div><div>//获取到每个jar的spring.factory的url</div><div>Enumeration&lt;URL&gt;urls=(classLoader !=null?classLoader.getResources(FACTORIES_RESOURCE_LOCATION):ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div>//解析获取到每个的spring.factory文件</div><div><font face="Monaco">while(urls.hasMoreElements()){</font></div><div><font face="Monaco">    URL url=urls.nextElement();</font></div><div><font face="Monaco">    UrlResource resource=new UrlResource(url);</font></div><div><font face="Monaco">//spring.factory文件中存储格式是</font></div><div><font face="Monaco">//    #接口的限定类名</font></div><div><font face="Monaco">//        接口的实现类全限定类名</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//prroperty是一个map，key存储接口的全限定类名，value存储其实现类的名称，各个实现类之间用,隔开</span></div><div><font style="font-family: Monaco;">//每个propertie是一个接口名称及其实现类的名称，properties文件中全部的</font>接口名称及其实现类的名称</div><div><font face="Monaco">    Properties properties=PropertiesLoaderUtils.lodaProperties(resource);</font></div><div><font face="Monaco">    for(Map.Entry&lt;?,?&gt;entry:properties.entrySet()){</font></div><div><font face="Monaco">        String factoryClassName=((String) entry.getKey().trim).trim;</font></div><div><font face="Monaco">        for(String factoryName:StringUtils.commaDelinitedListTostringArray((String) entry.getValue())){</font></div><div><font face="Monaco">            //result也是一个map，key存储接口的全限定类名，value是一个list，存储接口的各个实现类</font></div><div><font face="Monaco">            result.add(factoyClassName,factoryName.trim());</font></div><div><font face="Monaco">        }</font></div><div><font face="Monaco">    </font></div><div><font face="Monaco">    }</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">}</font></div><div><font face="Monaco">//将自定义类加载器作为key，result作为value存入缓存</font></div><div>cache.put(classLoader,result);</div><div><font face="Monaco">return result;</font></div><div><font face="Monaco">    。</font></div><div><font face="Monaco">    。</font></div><div><font face="Monaco">    。</font></div><div><font face="Monaco">//</font>loadSpringFactories(classLoader)返回result（全部的spring.factory的接口及实现类），</div><div>//getOrDefault(factoryClassName,Collections.emptyList())</div><div>//是对result进行筛选，选择到和run有关的类</div><div>loadSpringFactories(classLoader).getOrDefault(factoryClassName,Collections.emptyList());</div></div><div>     SpringFactoriesLoader</div><div>    //spring的SPI类加载器，类比于java的servicesLoader</div><div>查看 SpringFactoriesLoader源码：发现它监控的是&quot;META-INF/spring.factores&quot;文件</div><div>（java的servicesLoader监听的是META-INF/services目录）</div><div><br/></div><div>SpringApplication(primarySources)做的工作是加载每个jar包下的spring.factory文件中的接口和类信息（加载到了cache中）。（准备工作）</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">四、自动配置类的导入</span></div><div>  下面再看.run(args)做了哪些工作？</div><div><br/></div><div>    springboot的主启动类的注解@SpringBootApplication其实由@SpringBootConfiguration（作用是把启动类作为配置类）修饰，@SpringBootConfiguration又由@Configuration修饰，所以<span style="font-weight: bold;">springboot的主启动类其实是一个配置类</span>。</div><div><br/></div><div>     @SpringBootApplication上面的@EnableAutoConfiguration（作用是 开启启动配置类的创建），@EnableAutoConfiguration上面的@AutoConfigurationPackage（作用：<span style="background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 9pt; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures; line-height: 26px;">实质上，它负责保存标注相关注解的类的所在包路径。使用一个BasePackage类，保存这个路径。然后使用@Import注解将其注入到ioc容器中。这样，可以在容器中拿到该路径。</span></span></span><span style="font-size: unset; color: unset; font-family: unset;">）</span>@EnableAutoConfiguration上面的@Import（作用： <font style="font-size: 9pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 9pt; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures;">用来导入配置类或者一些需要前置加载的类</span></font><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures;">.</span>）</div><div><br/></div><div><br/></div><div>    springboot的自动配置，配置类的初始化工作是由spring做的，springboot的工作是找到需要的自动配置类（选择自动配置类）。</div><div>   <br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@import(AutoConfigurationImportSelector.class)</div><div>@EnableAutoConfiguration</div></div><div><span>    </span>查看 AutoConfigurationImportSelector.class怎么筛选出需要的自动配置类：</div><div><img src="Spring Boot自动配置解读_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div><img src="Spring Boot自动配置解读_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><span>    </span>怎么过滤呢？</div><div><span>    通过Auto Configuration Import Filters下的类</span><br/></div><div><img src="Spring Boot自动配置解读_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>通过@OnClassCondition（xxx.class,xxx.class）修饰的类表示需要 在项目中含有这两个类，才会去执行接下来的流程（配置类加载）。</div><div><span>    </span><br/></div><div><b><font style="font-size: 14pt;">五、HTTP编码自动配置类解析</font></b></div><div><span>    @ConditionalOnClass()//classpath下需要有某个类通过条件</span><br/></div><div><span>  </span>  @ConditionalOnMissingClass()//classpath下没有某个类通过条件 </div><div><span><span>    @ConditionOnProperty() </span><br/></span></div><div><span>    这些注解（@ConditionalOn开头）都有@Conditional(过滤类.class)注解修饰，用于条件的判断，比如说</span>@Conditional(OnClassCondition.class)修饰注解@ConditionalOnClass(CharacterEncodingFilter.class )</div><div>可以判断当前项目的classpath下有没有CharacterEncodingFilter.class ，有的话继续进行配置类的配置，没有就终止配置（配置失败）。</div><div><img src="Spring Boot自动配置解读_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b><font style="font-size: 12pt;">总结：</font></b></div><div><span>    SpringBoot的自动配置实现利用了SPI思想，在SpringBoot的启动类开启后，</span><span style="color: unset; font-family: unset; font-size: unset;">new SpringApplication(primarySources))负责将所有jar包下的spring.factory下的 接口名作为key，由每个接口对应实现类组成的list作为value 形成一个result（Map类型），并将classloader作为key，result作为value存入cache中。筛选出需要的类名称然后设置初始化器，（设置容器的监听器同理）。</span></div><div><span style="color: unset; font-family: unset; font-size: unset;"><span>    .run()就是启动容器，自动配置类中服务器的服务。通过类上的</span><br/></span></div><div><span>    </span>//new SpringApplciation 环境的初始化以及一些其他的准备工作</div><div><span>    </span>//run就是启动容器，以及自动配置类中的服务器的服务 ，主要通过<br/></div></span>
</div></body></html> 