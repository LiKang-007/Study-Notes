<html>
<head>
  <title>垃圾回收</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3499"/>
<h1>垃圾回收</h1>

<div>
<span><div>1、如何判断对象可以回收</div><div>2、垃圾回收算法</div><div>3、分代垃圾回收</div><div>4、垃圾回收器</div><div>5、垃圾回收调优</div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">一、如何判断对象可以回收</span></div><div>    <span style="font-weight: bold;">1、引用计数法；</span></div><div>        只要有引用指向该对象，该对象的计数+1，如果有引用不再指向它了，让计数-1，当引用计数变为0的时候，被判定为垃圾。</div><div>        弊端：</div><div><img src="垃圾回收_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>    这时，A，B对象都不会被判定为垃圾</div><div>    <span style="font-weight: bold;">2、可达性分析算法</span></div><div>        根对象 ：肯定不会被回收的对象</div><div>        在对象回收之前，先对堆内存中的对象进行扫描，如果堆中的对象没有被根对象直接或者间接的引用，那么它就可以作为垃圾被回收。</div><div><img src="垃圾回收_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>工具：（java堆的分析工具）</div><div><img src="垃圾回收_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>通过虚拟机命令抓取快照信息：</div><div>    jmap -dump:format=b,live,file=文件名.bin 进程号（format 是文件格式为二进制，live参数会主动进行一次垃圾回收）</div><div>通过 eclipse Memory Analyzer(MAT)打开存储的快照文件。</div><div><br/></div><div>查看GC Root对象</div><div><img src="垃圾回收_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">根对象：</span></div><div>    System Class:系统类</div><div>    Native Stack:java虚拟机进行方法调用时调用的操作系统的方法</div><div>    Thread:活动线程</div><div>    Busy Monitor:加锁的类（</div><div>synchronized）</div><div><br/></div><div><span style="font-weight: bold; font-size: 11pt;">五种引用：</span></div><div>    1、强引用</div><div>    2、软引用</div><div>    3、弱引用</div><div>    4、虚引用</div><div>    5、终结器引用</div><div><img src="垃圾回收_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>上图中，实线为强引用。</div><div>    <span style="font-weight: bold;">强引用：</span>GC Root对象直接引用的对象，只要有GC Root对象强引用该对象，它就不会被垃圾回收器回收。</div><div>    <span style="font-weight: bold;">软引用：</span>若垃圾回收器发生了一次垃圾回收，发现内存不够，就会把软引用指向的对象也回收掉。</div><div>    <span style="font-weight: bold;">弱引用：</span>若垃圾回收器发生了一次垃圾回收，不管内存够不够，都会把弱引用指向的对象回收掉。</div><div>    想要对软引用和弱引用进行处理，需要借助引用队列（可以配合引用队列使用，也可以不配合引用队列使用）。</div><div>  <span style="font-weight: bold;">  虚引用：</span></div><div>    例如：</div><div>        使用ByteBuffer对象使用直接内存时，会创建一个虚引用Cleaner指向该对象，当ByteBuffer对象被回收时，Cleaner会进入引用队列，ReferenceHandler守护线程会去这个引用队列中找有没有新入队的Cleaner对象，如果有，它就会调用Cleaner对象的clean()方法，clean方法去调用Unsafe对象的freeMemory()方法，释放直接内存。</div><div>    <span style="font-weight: bold;">终结器引用：</span></div><div>       Object类中的finallize()（终结方法），当一个对象重写了终结方法（JVM就会创建终结器引用对象指向它），并且没有强引用指向它时，它就可以被当成垃圾进行回收，在垃圾回收该对象之前，JVN就会将该终结器引用加入引用队列，finallizeHandler守护线程</div><div>     会去该引用队列中找有没有新加入的终结器引用，如果有就会根据该终结器引用找到要作为垃圾回收的对象，并且调用finallize()方法。在下一次垃圾回收的时候，才会真正的把该对象回收掉。</div><div>    </div><div>    不推荐使用finallize()方法释放对象的理由：</div><div>        内存释放效率低，因为finallizeHandler守护线程的优先级很低，可能会造成fin<span style="font-size: unset; color: unset; font-family: unset;">allize()方法迟迟不会执行，对象迟迟不被回收。</span></div><div>造成资源的浪费。</div><div>    虚引用和终结器引用必须配合引用队列。（当虚引用和终结器引用创建时，它就会关联一个引用队列）</div><div>    </div><div>    软引用的应用场景：</div><div>        例如：在网上下载图片，放入list集合。（不太重要的资源）</div><div>        强引用：list---&gt;byte[]</div><div>        演示软引用：</div><div>            list---&gt;SoftReference--&gt;byte[]</div><div><img src="垃圾回收_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">虚拟机参数：</span>-Xmx20m -XX:+PrintGCDetails -verbose:gc(打印垃圾回收的详细信息)</div><div>    <span style="font-weight: bold;">软引用的清理：</span></div><div>            //引用队列<span style="font-size: unset; color: unset; font-family: unset;">  </span></div><div><span style="font-size: unset; color: unset; font-family: unset;">  ReferenceQueue&lt;byte[]&gt;queue=new ReferenceQueue&lt;&gt;(); </span></div><div>           //关联了引用队列，当软引用所关联的Byte数组被回收时，软引用自己就睡被加入到引用队列queue中去。</div><div> SoftReference&lt;byte[] ref&gt;=new SoftReference&lt;&gt;(new byte[_4MB],queue);</div><div><img src="垃圾回收_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>    弱引用</div><div>list----&gt;WeakReference---&gt;byte[]</div><div><img src="垃圾回收_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold; font-size: 12pt;">垃圾回收算法：</span></div><div><span style="font-weight: bold;">1、标记清除算法</span>：</div><div><img src="垃圾回收_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>先标记后清除：标记没有GC Root直接或者间接指向的对象，然后</div><div>清除，将对象占用内存的起始和结束地址放入到空闲的地址列表中。</div><div>    优点：清除速度快</div><div>    缺点：容易造成内存碎片。</div><div><span style="font-weight: bold;">2、标记整理算法：</span></div><div><img src="垃圾回收_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>    相比于标记清除算法，也是先标记，整理是将使用的内存空间进行整理。</div><div>    优点：没有内存碎片。</div><div>    缺点：整理操作会存在对象的移动，效率较低。</div><div>  <span style="font-weight: bold;">  3、复制算法：</span></div><div>    <img src="垃圾回收_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>将存活的对象移动到To区域，移动的过程中就完成了整理工作。复制完成后，交换FROM和To的位置。（原来的To变为了FROM，FROM变为了To）</div><div>优点：不会产生内存碎片。</div><div>缺点：会使用双倍的内存空间。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14pt;">分代回收：</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="垃圾回收_files/Image [11].png" type="image/png" data-filename="Image.png"/></span></span></div><div>  分代处理，将长时间使用的对象放入老年代，短时间使用的对象放入新生代。</div><div>    新生代的垃圾回收被称为 :Minor GC（虚拟机打印信息默认为Minor GC） 。</div><div>    老年代的垃圾回收被称为：Full GC。</div><div>    </div><div><span style="font-weight: bold;">相关的JVM参数</span></div><div><img src="垃圾回收_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>  <span style="font-weight: bold;"> 打印的GC信息：</span></div><div>    Heap</div><div>        def  new generation：新生代</div><div>            eden space:伊甸园</div><div>            from space:</div><div>            to space:</div><div>        tenured generation：老年代</div><div>        Metaspace：元空间</div><div><span style="font-weight: bold;"> 策略： </span><span style="font-weight: bold;"> </span>           </div><div>大对象直接晋升到老年代。</div><div>注意：</div><div>一个线程内的堆内存溢出并不会导致整个java进程的结束。</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">垃圾回收器：</span></div><div>    <img src="垃圾回收_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold; font-size: 11pt;">串行：</span></div><div>虚拟机参数：-XX:+UseSerialGC=Serial+SerialOld(打开串行垃圾回收器)</div><div>其中 Serial 是对新生代的垃圾回收；（采用复制算法）</div><div>        SerialOld 是对老年代的垃圾回收；</div><div><img src="垃圾回收_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold; font-size: 11pt;">吞吐量优先：</span></div><div><img src="垃圾回收_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>以上的五个指令：</div><div>    1、开启吞吐量优先的GC</div><div>    2、开关：采用自适应的大小调整策略（调整新生代的大小）</div><div>    3、目标：<span style="font-size: unset; color: unset; font-family: unset;">设置设定的目标来尝试去调整堆的大小（默认值为99），公式：1/(1+ratio)</span></div><div>    4、目标：最大的暂停毫秒数（默认值是200ms）</div><div>    5、调整GC的线程数</div><div><span style="font-weight: bold;">响应时间优先：</span></div><div><span style="font-weight: bold;"><img src="垃圾回收_files/Image [16].png" type="image/png" data-filename="Image.png"/></span></div><div><b>并发：工作的同时，用户线程也能工作（垃圾回收的一些阶段不需要STW，某些阶段还是需要的）</b></div><div><b>并行：吞吐量优先是，多个垃圾回收线程并发执行，但是它们执行之前还是要STW的。</b></div><div><b>指令</b></div><div><b><span>    </span><br/></b></div><div><b><font style="font-size: 12pt;">G1垃圾回收器</font></b></div><div><b><img src="垃圾回收_files/Image [17].png" type="image/png" data-filename="Image.png"/></b></div><div><b><br/></b></div><div><b><img src="垃圾回收_files/Image [18].png" type="image/png" data-filename="Image.png"/></b></div><div><b> Young Collection---&gt;Yong Collection+Concurrent Mark---&gt;Mixed Collection</b></div><div><b><br/></b></div><div><b><img src="垃圾回收_files/Image [19].png" type="image/png" data-filename="Image.png"/></b></div><div><b><img src="垃圾回收_files/Image [20].png" type="image/png" data-filename="Image.png"/></b></div><div><b><img src="垃圾回收_files/Image [21].png" type="image/png" data-filename="Image.png"/></b></div><div><b>Young Collection+CM</b></div><div><b><img src="垃圾回收_files/Image [22].png" type="image/png" data-filename="Image.png"/></b></div><div><b>Mixed Collection</b></div><div><b><img src="垃圾回收_files/Image [23].png" type="image/png" data-filename="Image.png"/></b></div><div><b>p25</b></div></span>
</div></body></html> 