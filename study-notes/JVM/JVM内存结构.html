<html>
<head>
  <title>JVM内存结构</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3419"/>
<h1>JVM内存结构</h1>

<div>
<span><div><br/></div><div>JVM内存结构：</div><div>        1、程序计数器；</div><div>        2、虚拟机栈；</div><div>        3、本地方法区；</div><div>        4、堆；</div><div>        5、方法区。</div><div><br/></div><div><img src="JVM内存结构_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">第一部分：程序计数器：</span></div><div>        </div><div>    java代码执行顺序：java源代码-（编译器）--&gt;二进制字节码-（JVM）--&gt;机器码</div><div>编译器：在jdk中</div><div>解释器：在JVM中</div><div>  <span style="font-weight: bold;">  程序计数器（物理上是CPU中的寄存器）的作用</span>：记住下一条jvm指令的执行地址。</div><div><img src="JVM内存结构_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">    程序计数器的特点：</span></div><div>        线程私有的（每个线程都有自己的程序计数器）；</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第二部分：</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">虚拟机栈</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">   </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">定义：</span><span style="font-size: unset; color: unset; font-family: unset;">每个线程运行时所需要的内存，称为虚拟机栈；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">              每个栈由多个栈帧组成，对应着每次方法调用时所占的内存；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">               每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">  <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">  问题辨析：</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        1、垃圾回收是否涉及栈内存？</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                不需要，垃圾回收针对的是堆内存。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        2、栈内存分配越大越好吗？</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                不是，每个栈内存分配的越大，机器上最大并发执行的线程数目会变小，栈内存越大，方法递归调用的次数可以越多。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        3、方法内的局部变量是否是线程安全的？</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                是的，因为局部变量是存放在栈中的，每个线程会分配一个栈内存，因此不需要考虑线程安全问题。</span><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">全局变量是线程共享的，需要考虑线程安全问题</span><span style="font-size: unset; color: unset; font-family: unset;">。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        特殊情况：引用数据类型的局部变量</span><span style="font-size: unset; color: unset; font-family: unset;">作为返回值返回了，逃离了方法的作用范围，需要考虑线程安全问题。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">  <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">  栈内存溢出：</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        1、栈帧过多（递归调用）；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        2、栈帧过大（单个方法过大，一般不会出现）；</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">  <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">  idea设置栈内存大小：</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            Run/Debug Configurations ---&gt;Configuration--&gt;VM options --&gt;-Xss256k</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">线程运行诊断：</span></span></div><div><span style="font-size: unset;"><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">        案例1：cpu占用过多</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">       </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">定位：</span><span style="font-size: unset; color: unset; font-family: unset;">1、用 top定位哪个进程对cpu的占用过高</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                  2、ps H -eo pid,tid,%cpu|grep 进程id(用ps命令进一步定位是哪个线程引起的CPU占用过高)</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                  3、jstack 进程id</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                  4、根据线程id找到有问题的线程编号，进一步解决问题。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        案例二：程序迟迟得不到结果</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            可能原因：死锁</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">     </span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">第三部分：本地方法栈</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">       作用：执行本地方法，C++代码</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">       例如：native关键字。</span></div><div><span style="font-size: 12pt; font-weight: bold;">第四部分：堆</span></div><div>        Heap堆：通过 new 关键字，创建对象都会使用堆内存</div><div>        <span style="font-weight: bold;">特点：</span>1、它是线程共享的，堆中的对象都需要考虑线程安全问题。</div><div>                  2、有垃圾回收机制。</div><div>            垃圾回收机制：对象作为垃圾的条件是：没有引用指向该对象。</div><div>       <span style="font-weight: bold;">堆内存溢出：   </span></div><div>          控制JVM最大虚拟机参数：  <span style="font-size: unset; color: unset; font-family: unset;">Run/Debug Configurations ---&gt;Configuration--&gt;VM options --&gt;-Xmx8m(默认为4G)</span></div><div>       堆内存诊断：</div><div>                    1、jps工具：查看当前系统中有哪些java进程</div><div>                        Terminal--&gt;jps-&gt;jmap -heap 进程号(查看堆内存的占用)</div><div>                    2、jmap工具：查看堆内存占用的情况</div><div>                    3、jconsole工具：图形界面的，多功能的检测工具，可以连续的检测       </div><div>                      Terminal--&gt;jconsole  </div><div>      <span style="font-weight: bold;">  案例：垃圾回收多次之后，内存占用率依然很高。</span></div><div>            命令：jvisualvm（可以查看内存情况的快照，并且还可以查找类的占用内存的情况）--&gt;    Dump</div><div><img src="JVM内存结构_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">第五部分：方法区</span></div><div>    <span style="font-weight: bold;">定义：</span>存储类的信息，成员方法，构造方法，成员变量。</div><div>    <span style="font-weight: bold;">特点：</span>线程共享；</div><div>              在虚拟机启动时被创建；</div><div><img src="JVM内存结构_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>    <img src="JVM内存结构_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">    元空间内存溢出：</span></div><div>              IDEA设置元空间大小：</div><div>                 <span style="font-size: unset; color: unset; font-family: unset;">Run/Debug Configurations ---&gt;Configuration--&gt;VM options --&gt;-XX:MaxMetaspaceSize=8m</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">              场景：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                spring，</span><span style="font-size: unset; color: unset; font-family: unset;">mybatis等等框架使用动态代理编程，产生大量的代理类的字节码文件。</span></div><div><span style="color: unset; font-family: unset;">     <span style="color: unset; font-family: unset; font-weight: bold; font-size: 12pt;">运行时常量池：</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">         二进制字节码（类的基本信息，常量池，类方法定义，包含了虚拟机指令）</span></div><div><span style="color: unset; font-family: unset; font-size: unset;">       </span> <span style="color: unset; font-family: unset; font-size: unset; font-weight: bold;">指令：</span><span style="color: unset; font-family: unset; font-size: unset;">javap -v HelloWorld.class（反编译类的字节码文件）</span></div><div><span style="color: unset; font-family: unset; font-size: unset;">       </span> <span style="color: unset; font-family: unset; font-size: unset; font-weight: bold;">常量池：</span><span style="color: unset; font-family: unset; font-size: unset;">就是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息。</span></div><div><span style="color: unset; font-family: unset; font-size: unset;">       </span> <span style="color: unset; font-family: unset; font-size: unset; font-weight: bold;">运行时常量池：</span><span style="color: unset; font-family: unset; font-size: unset;">常量池是    *.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实的地址。</span></div><div> </div><div>      <span style="font-weight: bold;">面试题：（考察常量池与串池的关系）</span><span style="font-size: unset; font-weight: bold; color: unset; font-family: unset;">  </span><img src="JVM内存结构_files/Image [5].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;"/></div><div><span style="font-weight: bold; font-size: 12pt;">StringTable </span><span style="color: rgb(255, 0, 0);">StringTable 底层是hashtable</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Demol{</div><div>    <font color="#FF0000">//常量池中的信息，都会被加载到运行时常量池中，这时a b ab 都是常量池中的符号，还没有变为 java字符串对象</font></div><div><font color="#FF0000">    执行方法时，会把 a&quot;符号&quot;变为字符串对象。并将&quot;a&quot;放入到</font></div><div><font style="color: rgb(255, 0, 0);">StringTable[&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;] StringTable 底层是hashtable 结构，不能扩容</font></div><div>    //</div><div>    public static void main(String args[]){</div><div>        String s1=&quot;a&quot;;</div><div>        String s2=&quot;b&quot;;</div><div>        String s3=&quot;ab&quot;;</div><div>        String s4=s1+s2;//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString(),并把&quot;ab&quot;放入串池</div><div>        String s5=&quot;a&quot;+&quot;b&quot;;//javac 在编译期间的优化，结果已经在编译期间确定为&quot;ab&quot;.</div><div>        ----</div><div>       </div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>{&quot;a&quot;,&quot;b&quot;}</div><div>        String s=new String(&quot;a&quot;)+new String(&quot;b&quot;);//new String(&quot;ab&quot;)</div><div>    // new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)存放在堆中</div><div>        Strings6=s.intern;//将这个字符串对象尝试放入串池，如果没有则放入，有就不放入，最后把串池中的对象返回。</div></div><div><img src="JVM内存结构_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>StringTable位置证明：</div><div>使jdk1.6的串池溢出：报错：java.lang.OutOfMemoryError:PermGen space(永久代内存溢出)</div><div>使jdk1.8的串池溢出：报错：</div><div>java.lang.OutOfMemoryError:GC overhead limit exceeded(GC错误)</div><div><span style="font-size: unset; color: unset; font-family: unset;"> 使用命令：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    </span>java.lang.OutOfMemoryError:java heap space</div><div><br/></div><div><span style="font-weight: bold;">StringTable垃圾回收</span>：没有引用指向的String对象会被回收</div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">StringTable 性能调优：</span></div><div>    哈希表原理：</div><div>    调优：1、参数：-XX:StringTableSime=桶个数</div><div>              2、考虑将字符串对象是否入池（操作大量的字符串，且字符串存在重复，可以考虑将字符串入池）</div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">6、直接内存（Direct Memory）</span></div><div>    常见于NIO操作时，用于数据缓冲区；</div><div>    分配回收成本较高，但读写性能高；</div><div>    不受JVM内存回收管理。</div><div><span style="font-weight: bold;">案例：</span></div><div>    读取磁盘文件 <span style="font-size: unset; color: unset; font-family: unset;"> </span><img src="JVM内存结构_files/Image [7].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;"/></div><div><span style="font-weight: bold;">directBuffer 效率高的原因：</span></div><div><span style="font-weight: bold;">使用io</span></div><div><img src="JVM内存结构_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">使用</span><span style="font-weight: bold;">directBuffer：</span></div><div><img src="JVM内存结构_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>区别：<span style="font-weight: bold;">directBuffer下java 代码可以直接使用 操作系统分配的内存（直接内存）。</span></div><div><span style="font-weight: bold;">            IO下的java代码不能直接使用JVM之外的内存，数据需要先存到系统缓冲区，然后到java缓冲区，最后才进入内存。</span></div><div><br/></div><div><span style="font-weight: bold;">直接内存溢出：</span></div><div><br/></div><div><span style="font-weight: bold;">直接内存的释放原理：</span></div><div><span style="font-weight: bold;">    ByteBuffer底层工作流程：</span></div><div><span style="font-weight: bold;"><span>    </span><span>    Unsafe unsafe=getUnsafe();</span><br/></span></div><div><span style="font-weight: bold;">        //分配内存,base 记录分配内存的地址</span></div><div><span style="font-weight: bold;">            long base=unsafe.allocteMemory(_1Gb);</span></div><div><span style="font-weight: bold;">        // 释放内存</span></div><div><span style="font-weight: bold;"><span>    </span><span>    </span><span>    unsafe.freeMemory(long);</span><br/></span></div><div><b><img src="JVM内存结构_files/Image [10].png" type="image/png" data-filename="Image.png"/></b></div><div><b><span>   </span></b></div><div><b><span><span>    </span> 禁用显示回收对直接内存的影响：</span><br/></b></div><div><b><span><span>    </span><span>    -xx:+DisableExplicitGC</span><br/></span></b></div><div><b><span><br/></span></b></div><div><b><span>    </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    </span></b><span style="font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;">System.gc();//显示垃圾回收，Full GC （比较影响性能，不仅回收新生代，还会回收老年代）</span></div><div><b><span><span>    加上该参数后，程序中的System.gc();//显示的垃圾回收就失效了</span><br/></span></b></div><div><b><span><span>    ByteBuffer只有等到真正垃圾回收产生时，才会被回收。直接内存可能会长时间得不到释放。</span><br/></span></b></div><div><b><span><span>    解决办法：</span><br/></span></b></div><div><b><span>    </span><span>    </span></b><span style="font-weight: bold;">unsafe.freeMemory(long);</span></div><div><span style="font-weight: bold;"><span>    </span><span>    //使用完直接内存后对其进行手动释放，不要等到守护线程释放。</span><br/></span></div></span>
</div></body></html> 