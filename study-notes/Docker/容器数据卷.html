<html>
<head>
  <title>容器数据卷</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="5542"/>
<h1>容器数据卷</h1>

<div>
<span><div><span style="font-size: 14pt; font-weight: bold;">什么是容器数据卷？</span></div><div><img src="容器数据卷_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="容器数据卷_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>总结：容器数据卷是为了：容器的持久化和同步操作！容器间也可以数据共享。</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">使用数据卷</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">方式一：直接使用命令挂载 -v</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#使用命令挂载并启动</div><div>docker run -it -v 主机目录:容器内目录</div><div>#挂载多对目录</div><div>docker run -it -v 主机目录:容器内目录 -v 主机目录:容器内目录 -v 主机目录:容器内目录</div><div><br/></div><div>#查看容器的详细信息</div><div>docker inspect 容器id</div></div><div><img src="容器数据卷_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>测试挂载文件的同步:</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">实战：安装MySQL</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#获取镜像</div><div>docker pull mysql:5.7</div><div>#运行容器，需要做数据卷挂载#安装启动mysql，需要配置密码！</div><div>#官方测试：</div><div><br/></div><div>#启动</div><div>-d 后台运行</div><div>-p 端口映射</div><div>-v 卷挂载</div><div>-e 环境配置</div><div>--name 容器名字</div><div>docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 --name mysql01 mysql:5.7</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">#启动成功之后，在本地通过 Navicat连接测试</span></div></div><div>假设将容器删除：</div><div><br/></div><div>测试本地的文件是否被删除：</div><div><br/></div><div>发现，我们挂载的数据卷依旧没有丢失，这就实现了容器数据持久化功能！</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">具名和匿名挂载！</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">匿名挂载</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-v 容器内路径（不指定宿主机路径，由docker自己挂载）</div><div>docker run -d -p --name nginx01 -v /etc/nginx</div><div><br/></div><div>#查看所有卷的情况</div><div>docker volume ls</div><div><br/></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">具名挂载</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">-v 卷名:容器内目录</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>#查看所有卷的情况</div><div>docker volume ls</div></div><div>    所有docker容器内的卷，没有指定宿主机目录的情况下都是在：</div><div>/var/lib/docker/volumes/</div><div><br/></div><div>    通过具名挂载可以方便的找到一个卷，大多数情况都使用具名挂载。</div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt; font-weight: bold;">    如何确定是具名挂载还是匿名挂载，还是指定路径挂载？</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-v 容器内路径           #匿名挂载</div><div>-v 卷名：容器内路径    #具名挂载</div><div>-v /宿主机路径:容器内路径 #指定路径挂载</div><div><br/></div></div><div>    </div><div><span style="font-weight: bold;">扩展：</span></div><div><img src="容器数据卷_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">方式二：Dockerfile （构建镜像的时候设置挂载信息，在创建容器的时候自动进行挂载）</span></div><div><br/></div><div>初识Dockerfile</div><div>Dockerfile就是用来构建docker镜像的构建文件！命令脚本！通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">#创建一个dockerfile文件，名字可以随意，建议dockerfile</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">#文件中的内容 <b>指令（大写） 参数</b></span></div><div><font face="Monaco"><b>FROM centos</b></font></div><div><font face="Monaco"><b><br/></b></font></div><div><font face="Monaco"><b>VOLUME [&quot;/volume01&quot;,&quot;/volume02&quot;]</b></font></div><div><font face="Monaco"><b><br/></b></font></div><div><font face="Monaco"><b>CMD echo &quot;----end----&quot;</b></font></div><div><font face="Monaco"><b>CMD /bin/bash</b></font></div><div><font face="Monaco"><b><br/></b></font></div><div><font face="Monaco">#这里的每个命令，都是镜像的一层！</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">#通过dockerFile文件创建镜像</font></div><div><font face="Monaco">docker build -f dockerfile脚本文件路径 -t 生成的镜像名 生成镜像的路径</font></div><div><font face="Monaco">#例如：</font> docker build -f dockerfile_01 -t lk/centos:1.0 .</div><div><font face="Monaco"><br/></font></div></div><div><img src="容器数据卷_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b><font style="font-size: 12pt;">数据卷容器：实现容器和容器之间的数据同步</font></b></div><div><br/></div><div><img src="容器数据卷_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#创建并启动第一个容器</div><div>docker run -it --name docker01 lk/centos:1.0</div><div>#创建并启动第二个容器</div><div>docker run -it --name docker02 <b>--volumes-from</b> docker01 lk/centos:1.0</div><div>#第二个容器和第一个容器的数据卷就同步了，就算第一个容器被删除了，第二个容器的数据卷依然存在。</div></div><div><b><font style="font-size: 12pt;"><br/></font></b></div><div><b><font style="font-size: 12pt;">结论</font></b>：容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦持久化到了本地，本地的数据是不会删除的。</div><div><br/></div><div><span>    测试：将本地的数据卷删除了，相同数据卷的容器启动就会报错</span><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[root@192 ~]# docker start  7079cd1c9591  /bin/bash</div><div>Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: rootfs_linux.go:76: mounting &quot;/var/lib/docker/volumes/e1c85d73dd47750a7a1f24bda838ca255f5a0a79b03f02e0a46cbaf477197c61/_data&quot; to rootfs at &quot;/volume01&quot; caused: stat /var/lib/docker/volumes/e1c85d73dd47750a7a1f24bda838ca255f5a0a79b03f02e0a46cbaf477197c61/_data: no such file or directory: unknown</div><div>Error response from daemon: No such container: bin/bash</div><div>Error: failed to start containers: 7079cd1c9591, /bin/bash</div><div>翻译：</div><div>[root@192 ~]# docker start 7079cd1c9591 /bin/bash</div><div>从守护进程:OCI运行时创建失败:container_linux错误响应。Go:380:启动容器进程导致:process_linux。执行:545:容器初始化导致:rootfs_linux。/var/lib/docker/volumes/e1c85d73dd47750a7a1f24bda838ca255f5a0a79b03f02e0a46cbaf477197c61/_data&quot; to rootfs at &quot;/volume01</div><div>daemon的错误响应:No such container: bin/bash</div><div>错误:启动容器失败:7079cd1c9591， /bin/bash</div></div><div><br/></div><div><br/></div></span>
</div></body></html> 