<html>
<head>
  <title>多线程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1366"/>
<h1>多线程</h1>

<div>
<span><div><div><div><span style="font-weight: bold;">线程三大特性：原子性，可见性，顺序性</span></div><div><span style="font-weight: bold;">什么是进程？什么是线程？</span></div><div><br/></div><div><img src="多线程_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">进程和线程的关系：</span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">线程和线程之间</span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [2].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">java实现多线程的方式</span></div><div><span style="font-weight: bold;">第一种方式：编写类继承java.lang.Tread,重写run（）方法</span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">注意：</span></div><div><span style="font-weight: bold;">Thread中的run()和static()的区别</span></div><div><br/></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [6].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">第二种方式：编写的类实现java.lang.Runnable接口。</span></div><div><span style="font-weight: bold;"><img src="多线程_files/Image [7].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><img src="多线程_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div>线程的生命周期</div><div><img src="多线程_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>Thread  thread=new Thread(new Runable(){});</div><div>   线程默认名字 Thread-线程序号。</div><div>thread.setName();//修改线程的名字，</div><div>thread.getName();//获取线程的名字</div><div><br/></div><div><br/></div><div>获取当前线程对象   方法<span style="font-size: unset; color: unset; font-family: unset;">static Thread currentThread();</span></div><div><br/></div><div>Thread current=Thread.currentThread();</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><hr/><div>线程的sleep()方法</div><div>    static  void sleep（long millis）</div><div>1.静态方法</div><div>2.参数是毫秒</div><div>3.作用：让当前线程休眠，进入阻塞状态，放弃占有的cpu时间片。</div><div><br/></div><div>sleep方法的面试题：</div><div><img src="多线程_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>注意：run（）方法中的异常只能try catch 不能throws</div><div> 因为run在父类中没有抛出异常，子类不能比父类抛出更多的异常。</div><div><br/></div><div>唤醒正在睡眠的线程：</div><div> interrupt();</div><div><br/></div><div>强行终止一个线程：可能会丢失数据。</div><div>stop();//已过时，不建议使用。 </div><div>  </div><div>怎么合理的终止一个线程的执行？</div><div>打一个布尔标记</div><div>return前可以保存数据。</div><div><img src="多线程_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">常见的线程调度模型：</span></div><div>抢占式调度模型；</div><div>均分式调度模型；</div><div>java采用抢占式调度模型。</div><div><br/></div></div><div>java设置线程优先级</div><div> void setPriority(int newPriority)</div><div>获取线程优先级</div><div>int getPriority</div><div>最低优先级：1；</div><div>最高优先级：10；</div><div>默认优先级：5；</div><div>优先级高的抢到的CUP时间片相对多一些。</div><div><br/></div><div>让位方法：</div><div>    静态方法</div><div><br/></div><div>static void yield()</div><div>暂停当前正在执行的线程对象，执行其他线程。</div><div>进入就绪状态， 可以继续抢夺时间片。</div><div><br/></div><div>    实例方法</div><div>void join()//合并线程</div><div><img src="多线程_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">重点</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">线程安全问题</span></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="多线程_files/Image [13].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="多线程_files/Image [14].png" type="image/png" data-filename="Image.png"/></span></span></div><div><br/></div><div>什么时候数据在多线程并发的时候会存在安全问题？</div><div>1，多线程并发</div><div>2，有共享数据</div><div>3，共享数据有修改的行为。</div><div><br/></div><div>java三大变量</div><div>实例变量：在堆中；</div><div>静态变量：方法区；</div><div>局部变量：在栈中；</div><div>局部变量没有线程安全问题；（不共享）</div><div>静态变量针对所有的改类对象存在线程安全问题。</div><div>实例变量是各个对象之间存在线程安全问题。</div><div><br/></div><div>怎么解决？</div><div>线程排队执行，不能并发。这种机制被称为线程同步机制。</div><div>synchronized(){</div><div>        线程同步代码块；</div><div>}</div><div><img src="多线程_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>同步代码块越小效率越高。</div><div><br/></div><div>synchronized(&quot;adasdas&quot;);所有改类的对象都同步；</div><div>String s=New String(&quot;adasdas&quot;);//s要为成员变量</div><div>synchronized(s);//同一个对象才会同步。</div><div> 一般可以写：<span style="font-size: unset; color: unset; font-family: unset;">synchronized(this);</span></div><div><span style="font-size: unset;"><br/></span></div><div>synchronized用在实例方法上，同步整个方法，可能会扩大同步范围，降低程序的执行效率，并且这种方式锁的一定是this，不灵活。</div><div>synchronized用在静态方法上，创建的是类锁，其他创建的对象锁，对象锁也锁的是局部（********^_^********）。</div><div><br/></div><div><br/></div><div>synchronized面试题：</div><div><img src="多线程_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div>下面的代码是 doSome(）被synchronized修饰 doOther没有被synchronized修饰</div><div>        结果：不需要；</div><div>改为doSome(）被synchronized修饰 doOther也被synchronized修饰</div><div>        结果：需要；（一个对象一把锁）</div><div><img src="多线程_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>都被synchronized修饰。</div><div>    结果：不需要；</div><div><br/></div><div>改为</div><div><img src="多线程_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div>           结果：需要</div><div>这种锁叫排他锁，还有一种互斥锁。</div><div><br/></div><div>死锁：</div><div><img src="多线程_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class thread1 extends Thread {</div><div>    Object o1;</div><div>    Object o2;</div><div>    thread1(Object o1,Object o2){</div><div>        this o1=o1;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">               this   o2=o2; </span></div><div>    }</div><div>    run(){</div><div>        synchronized(o1){</div><div>            Thread.sleep(1000);</div><div>            synchronized(o2){</div><div>                        </div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>}</div><div>class thread2  extends Thread{</div><div>    Object o1;</div><div>    Object o2;</div><div>    thread1(Object o1,Object o2){</div><div>        this o1=o1;</div><div>        this o2=o2;</div><div>    }</div><div>    run(){</div><div>        synchronized(o2){</div><div>            Thread.sleep(1000);</div><div>            synchronized(o1){</div><div>                        </div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>}</div><div>public static void main(String[] str){</div><div>    Object o1;</div><div>    Object o2;</div><div>    Thread1 thread1=New Thread1(o1,o2);</div><div>    Thread2 thread2=New Thread2(o1,o2);</div><div>    thread1.static();</div><div>    thread2.static();</div><div><br/></div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div><br/></div><div><br/></div><div>异步编程模型：</div><div>    线程t1和线程t2互不干扰，各自执行。</div><div>同步编程模型：</div><div>    线程t1和线程t2，在t1执行的时候，必须等待t2执行结束，</div><div>或者t2执行的时候，必须等待t1执行结束，两个线程之间发生了等待关系，线程排队执行。</div><div><img src="多线程_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="多线程_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>如果使用局部变量：</div><div>建议使用：StringBuilder。</div><div>StringBuffer的方法使用synchronized（），会降低执行效率。</div><div><br/></div><div>ArrayList是非线程安全的；</div><div>Vector是线程安全的；</div><div>HashMap HashSet是非线程安全的；</div><div>Hashtable是线程安全的。</div><div>同上。</div><div><br/></div><div><img src="多线程_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">守护线程：</span></div><div><img src="多线程_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div>后台线程</div><div>一般是一个死循环，所有的用户线程只要结束，守护线程自动结束，主线程main是一个用户线程。</div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(227, 0, 0); font-weight: bold;">定时器：</span></font></div><div><span style="font-weight: bold;">间隔特定的时间执行特定的程序。</span></div><div>java.util.Timer（实现了Runnable接口，可以作为守护线程）</div><div><img src="多线程_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div>实际开发中，使用Spring框架中的SpringTask框架</div><div><br/></div><div>timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);</div><div><br/></div><div>定时任务：继承抽象类TimerTask</div><div><img src="多线程_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div>第一次执行时间是一个日期对象。</div><div><br/></div><div>实现线程的第三种方式（JDK8新特性）可以得到返回值。</div><div>实现Callable接口</div><div><img src="多线程_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div>call方法相当于run方法</div><div>获取 该线程的返回结果</div><div>task.get();//会导致当前线程阻塞，要等待task线程结束</div><div><br/></div><div><br/></div><div><br/></div><div>关于Object中的wait和notify方法（生产者和消费者模式）</div><div><br/></div><div><img src="多线程_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div><img src="多线程_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div>生产者消费者模式：</div><div><img src="多线程_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//使用wait和notify实现生产者和消费者模式</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//wait和notify是所有java对象都具有的</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//wait方法作用：o.wait()让o对象上活动的线程t进入等待状态，并且释放t之前占有的o对象的锁</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//notify方法作用：o.notify()让o对象上等待的线程唤醒，只是通知，不会释放o对象之前占有的对象锁。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//生产线程</span></div><div><font face="Monaco">class Producer implements Runnable{</font></div><div><font face="Monaco">        private List list;</font></div><div><font face="Monaco">        public Producer(List list){</font></div><div><font face="Monaco">                this.list=list;</font></div><div><br/></div><div><font face="Monaco">    }</font></div><div><font face="Monaco">        public void run(){</font></div><div><font face="Monaco">                while(true){</font></div><div><font face="Monaco">                  </font>synchronized(list){//给list仓库加锁</div><div><font face="Monaco">                        if(list.size()&gt;0){</font></div><div><font face="Monaco">                        list.wait();<font color="#3665EE">//当前线程进入等待状态，并且释放List集合的锁</font></font></div><div><font face="Monaco">                    }</font></div><div><font face="Monaco">                    //生产对象</font></div><div><font face="Monaco">                    Object obj=new Object();</font></div><div><font face="Monaco">                    list.add(obj);</font></div><div><font face="Monaco">                  System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+obj);</font></div><div><font face="Monaco">                    //唤醒消费者消费</font></div><div><font face="Monaco">                    list.notify();</font></div><div><font face="Monaco">                }</font></div><div><font face="Monaco">            }</font></div><div><font face="Monaco">        }</font></div><div><font face="Monaco">}</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//消费线程</span></div><div>class Consumer implements Runnable{</div><div>        private List list;</div><div>        public Consumer(List list){</div><div>                this.list=list;</div><div><br/></div><div><br/></div><div>    }</div><div>        public void run(){</div><div>         while(true){</div><div>                  synchronized(list){//给list仓库加锁</div><div>                        if(list.size()==0){</div><div>                        list.wait();//当前线程进入等待状态，并且释放List集合的锁</div><div>                    }</div><div>                            </div><div>                        list.remove(0);//消费</div><div>                        //唤醒生产者生产</div><div>                        list.notify();    </div><div>                }</div><div>            }</div><div>        }</div><div>}</div><div><br/></div><div>    }</div><div><br/></div><div><br/></div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public static void   mian(String[] args){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    List list=new ArrayList();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Thread t1=new Thread(new Producer(list));</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    </span>Thread t2=new Thread(new Consumer(list));</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    t1.setName(&quot;生产者&quot;);</span></div><div>  t2.setName(&quot;消费&quot;);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><img src="多线程_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><img src="多线程_files/多线程学习流程图.png" type="image/png" data-filename="多线程学习流程图.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 