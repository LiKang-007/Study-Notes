<html>
<head>
  <title>反射机制</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1668"/>
<h1>反射机制</h1>

<div>
<span><div><div>反射机制：</div><div>    通过java反射机制可以操作字节码文件（可以读和修改字节码文件）</div><div>反射机制相关的包：java.lang.reflect.*;</div><div><br/></div><div><span style="color: rgb(188, 0, 88); font-weight: bold;">反射机制相关的类：java.lang.Class：代表字节码文件</span></div><div><span style="color: rgb(188, 0, 88); font-weight: bold;">                                java.lang.reflect.Method：代表字节码文件中的方法字节码</span></div><div><span style="color: rgb(188, 0, 88); font-weight: bold;">                                java.lang.reflect.Constructor：代表字节码文件中的构造方法字节码</span></div><div><span style="color: rgb(188, 0, 88); font-weight: bold;">                                java.lang.reflect.Field：代表字节码文件中的属性字节码</span></div><div>    <span style="color: rgb(79, 0, 154); font-weight: bold;">先获取Class，才能获取Method、Constructor、Field。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class User{</div><div>    int no;//Field</div><div>    public User(){}//Constructor</div><div>    public void getNo(){}//Method</div><div><br/></div><div>}</div></div><div><br/></div><div><br/></div><div>要操作类的字节码，首先要获取这个类，有三种方法</div><div><br/></div><div><span style="font-weight: bold;">方法1、Class.forName();</span></div><div>        1.静态方法</div><div>        2.方法的参数是字符串</div><div>        3.字符串需要完整类名</div><div>        4.完整类名必须带有包名，java.lang也不能省略。</div><div><span style="font-weight: bold;">方法2、Object中有方法getClass()；//继承Object类中的方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>String s=&quot;abc&quot;;</div><div>Class x=s.getClass();</div></div><div><span style="font-weight: bold;">方法3、java语言任何一种类型，包括基本数据类型，都有.class属性</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Class z=String.class;</div></div><div>   <span style="color: rgb(255, 0, 0); font-weight: bold;"> </span><span style="color: rgb(255, 0, 0); font-weight: bold;">注意：字节码文件（Class类型）在JVM中只能有一份</span></div><div><span style="font-weight: bold;"><img src="反射机制_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">通过反射实例化对象</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Class c=Class.forName(&quot;完整类名&quot;);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//</span>newInstance()会调用改类的无参构造方法，实例化该对象</div><div>Object obj=c.newInstance();//已过时</div></div><div><br/></div><div><span style="font-weight: bold;">反射机制创建对象的灵活性：与配置文件联合使用，可以做到对不同对象的实例化。（符合OCP原则：对扩展开放，对修改关闭）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Class.forName()方法执行会导致类加载。</div><div><font face="Monaco">如果只想让一个类的静态代码块执行，可以采用</font>Class.forName()</div><div>JDBC Util方法;</div></div><div><br/></div><div><span style="font-weight: bold;">获取类路径下文件的绝对路径：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>src目录是类的根路径</div><div>String path=Thead.currentThread().getContextClassLoader().getResource(&quot;从类路径开始的相对路径（src下）&quot;).getPath();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//采用以上方法可以获得一个文件的绝对路径；</span></div></div><div><br/></div><div><span style="font-weight: bold;"><img src="反射机制_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">读取配置文件内容</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>String path=Thead.currentThread().getContextClassLoader().getResource(&quot;从类路径开始的相对路径（src下）&quot;).getPath();</div><div>FileRead reader=new FileReader(path);</div><div>Properties pro=new  Properties();</div><div>pro.load(readr);</div><div>reader.close();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//获取内容</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">String className=pro.getProperty(&quot;className&quot;);</span></div></div><div><span style="font-weight: bold;">改进</span></div><div><span style="font-weight: bold;">//直接以流的方式返回</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">InputStream reader=</font>Thead.currentThread().getContextClassLoader().getResourceAsStream(从类路径开始的相对路径（src下）);</div><div>Properties pro=new Properties();</div><div>pro.load(reader);</div><div>reader.close();</div><div>//读取</div><div>String className=pro.getProperty(&quot;className&quot;);</div></div><div><br/></div><div><span style="font-weight: bold; color: rgb(255, 0, 0);">资源绑定器</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容</div><div><font style="font-family: Monaco;">注：使用资源绑定器的时候，属性配置文件xxx.properties必须放到类路径下</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">public class ResourceBundleTest{</font></div><div><font face="Monaco">    public static void main(String[] args){</font></div><div><font face="Monaco">    <b><font color="#E30000">    //资源绑定器，只能绑定</font></b></font><b><font color="#E30000">xxx.properties配置文件。并且这个文件必须在类路径下。文件扩展名必须是properties</font></b></div><div>    <b><font color="#FF0000">//写路径的时候，路径后面的扩展名不能写。</font></b></div><div>    ResourceBundle bundle=ResourceBundle.getBundle(&quot;路径名&quot;);</div><div>    String className=bundle.getString(&quot;className&quot;);</div><div><font face="Monaco">        </font></div><div><font face="Monaco">}</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">}</font></div></div><div><br/></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">获取Class的名称</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px;">String s=studentClass.getName();//获取完整类名</span></div><div><span style="font-size: 12px;">String s=studentClass.getSimpleName();//简类名</span></div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">获取Field（反射属性）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Student{</div><div>    public int num;//整个public int num;是一个Field对象</div><div>    private String name;</div><div>    boolean sex;</div><div>    protected int age;</div><div>}</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">public class ReflectTest{</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    public void static main(String[] args){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Class  studentClass =Class.forName(&quot;Student&quot;);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取类中所有的(公开的)Field</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">     Field[] field=studentClass.getFields();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //获取属性的名字 Field</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    Field[] fs=studentClass.getDeclaredFields();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    for(Field field:fs){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //获取属性的修饰符列表</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            int i=field.getModifiers()//返回的int是修饰符代号</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            String modifierString= Modifier.toString(i);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //获取属性的类型</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            Class fieldType=field.getType();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            String fName=fieldType.getName();</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            //获取属性的名字</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            System.out.println(field.getName());</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><br/></div><div><span style="font-weight: bold;">反编译类文件（属性）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class util{</div><div>    public void decompilation(Class cl){</div><div>        StringBuilder s=new StringBuilder();</div><div>        s.append(Modifier.toString(cl.getModifiers())+&quot;class&quot;+cl.getSimpleName()+&quot;{&quot;+\n);</div><div>        Field[] fields=cl.getDeclaredFields();</div><div>        for(Field field:fields){</div><div>            s.append(&quot;\t&quot;);</div><div>            s.append(Modifier.toString(field.getModifiers()));</div><div>            s.append(&quot; &quot;);</div><div>            s.append(field.getType().getSimpleName);</div><div>            s.append(&quot; &quot;);</div><div>            s.append(field.getName());</div><div>            s.append(&quot;;\n&quot;);</div><div>        }</div><div>    }</div><div>    </div><div>}</div></div><div><span style="font-weight: bold; color: rgb(255, 0, 0);">通</span><span style="font-size: unset; font-weight: bold; color: rgb(255, 0, 0); font-family: unset;">过反射机制访问对象属性（掌握）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static void main(String[] args){</div><div>    Class student=Class.forName(&quot;Student&quot;);</div><div>    //通过反射机制获取对象</div><div>    Object obj=studentClass.newInstance();</div><div>    //根据属性名称获取Field</div><div>    Field field=studentClass.getDeclaredField(&quot;属性名&quot;);</div><div>    //给对象的属性赋值</div><div>    field.set(obj,属性值);给obj对象的属性赋值为&quot;属性值&quot;;</div><div>    //读取属性的值</div><div>    field.get(obj);</div><div><br/></div><div>    //访问私有属性</div><div>    Field nameField=studentClass.getDeclaredField(&quot;name&quot;);</div><div>    nameField.setAccessible(true);//打破封装</div><div>    nameField.set(obj,&quot;jackson&quot;);//给name属性赋值</div><div>    nameField.get(obj));    </div><div>}</div><div><br/></div></div><div>反射机制缺点：可以打破封装，可能给不法分子留下机会。</div><div><br/></div><hr/><div><span style="font-weight: bold;">可变长参数</span></div><div>int ...args</div><div>    语法：类型...</div><div>1、可变长参数个数要求为0-n个</div><div>2、可变长参数在参数列表只能是最后一个，并且可变长参数只能有一个。</div><div>3、可变长参数可以当成一个数组，也可以传一个数组。</div><div><br/></div><div><span style="font-weight: bold;">反射Method</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Class userServiceClass=Class.forname(&quot;User&quot;);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//获取所有的Method（包括私有的）</span></div><div><font face="Monaco">Method[] methods=userServiceClass.getDeclaredMethods();</font></div><div><font face="Monaco">遍历methods</font></div><div><font face="Monaco">for(Method method:methods){</font></div><div><font face="Monaco">    获取修饰符列表</font></div><div><font face="Monaco">        Modifier.toString(method.getModifiers()); </font></div><div><font face="Monaco">    //获取方法名</font></div><div><font face="Monaco">    method.getName();</font></div><div><font face="Monaco">    //获取返回值类型</font></div><div><font face="Monaco">    method.getReturnType().getSimpleName();</font></div><div><font face="Monaco">    //方法的参数列表</font></div><div><font face="Monaco">    Class[]parameterTypes=method.getParameterTypes();</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">}</font></div></div><div><span style="font-weight: bold;">反编译Method</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class util{</div><div>    public void decompilation(Class cl){</div><div>        StringBuilder s=new StringBuilder();</div><div>        s.append(Modifier.toString(cl.getModifiers())+&quot;class&quot;+cl.getSimpleName()+&quot;{&quot;+\n);</div><div>        Method[] methods=cl.getDeclaredMethods();</div><div>        for(Method method:methods){</div><div>            s.append(&quot;\t&quot;);</div><div>            s.append(Modifier.toString(method.getModifiers()));</div><div>            s.append(&quot;&quot;);</div><div>            s.append(method.getReturnType().getSimpleName);</div><div>            s.append(&quot; &quot;);</div><div>            s.append(method.getName());</div><div>            s.append(&quot;(&quot;);</div><div>            //参数</div><div>            Class[] parameterTypes=method.getParameterTypes();</div><div>            for(Class parameterType:parameterTypes){</div><div>                s.append(parameterType.getSimpleName());</div><div>                s.append(&quot;,&quot;);</div><div>            }</div><div>            if(parameterTypes.length&gt;0){</div><div>                s.deleteCharAt(s.length()-1);</div><div>            }</div><div>            s.append(&quot;){}\n&quot;);</div><div>        }</div><div>    }</div><div>    </div><div>}</div></div><div><span style="font-weight: bold; color: rgb(255, 0, 0);">通过反射机制调用方法（掌握）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>Class userServiceClass=Class.forName(&quot;User&quot;);</div><div>//创建对象</div><div>Object obj=userServiceClass.newInstance();</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//获取Method</span></div><div><font face="Monaco">Method loginMethod=userServiceClass.getDeclaredMethod(&quot;方法名,参数类型.class,参数类型.class,,,&quot;)</font></div><div><font face="Monaco">/*调用方法</font></div><div><font face="Monaco">    要素分析：</font></div><div><font face="Monaco">        要素1：对象</font></div><div><font face="Monaco">        要素2：方法名</font></div><div><font face="Monaco">        要素3：实参列表</font></div><div><font face="Monaco">        要素4：返回值</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">*/</span></div><div><font face="Monaco">Object retValue=loginMethod.invoke(obj,&quot;admin&quot;,&quot;123&quot;)</font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div>反编译构造方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>StringBuilder s=new StringBuilder();</div><div>Class VipClass=Class.forName(&quot;Vip&quot;);</div><div>s.append(Modifier.toString(VipClass.getModifiers()));</div><div>s.append(&quot;class&quot;);</div><div>s.append(VipClass.getSimpleName());</div><div>s.append(&quot;{\n&quot;);</div><div><br/></div><div>//拼接构造方法</div><div>Constructor[]constructors=vipClass.getDeclaredConstructors();</div><div>for(Constructor constructor:constructors){</div><div><span>    s.append(\t);</span><br/></div><div><span>    s.append(Modifier.toString(constructor.getModifiers()</span>));</div><div>s.append(&quot; &quot;);</div><div>s.append(VipClass.getSimpleName());</div><div>s.append(&quot;(&quot;);</div><div>Class[]parameterTypes=constructor.getParameterTypes();</div><div>for(Class parameterType:parameterTypes){</div><div><span>    s.append(parameterType.getSimpleName());</span><br/></div><div><span><span>    s.append(&quot;,&quot;);</span><br/></span></div><div>}</div><div><span>    </span>if(parameterTypes.length&gt;0){</div><div>                s.deleteCharAt(s.length()-1);</div><div>            }<br/></div><div>s.append(&quot;){}\n&quot;);</div><div>}</div><div><br/></div><div>s.append(&quot;}&quot;);</div><div>System.out.println(s); </div></div></div><div><br/></div><div><b>反射机制调用构造方法/通过反射机制创建对象</b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Class c=Class.forName(&quot;User&quot;);</div><div>//调用无参构造方法</div><div>Object obj=c.newInstance();</div><div>//调用有参构造方法</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Constructor con= c.getDeclaredConstructor(参数1.class,参数2.class);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//new对象</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Object newObj=con.newInstance(参数1，参数2 );</span></div><div><font face="Monaco">System.out.println(newObj);</font></div><div><font face="Monaco">//获取无参构造方法</font></div><div>Constructor conn= c.getDeclaredConstructor();</div><div>Object nobj=conn.newInstance();</div></div><div><br/></div><div><b><font style="color: rgb(255, 0, 0);">反射机制获取父类及实现的接口</font></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>Class stringClass=Class.forName(&quot;java.lang.String&quot;);</b></div><div><b><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>Class superclass=stringClass.getSuperclass();</b></span></b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>//获取String类实现的所有接口</b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>Class[] interfaces=stringClass.getInterfaces();</b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>for(Class in:interfaces){</b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b><span>    </span><span>    System.out.println(in.getName());</span><br/></b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>}</b></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 