<html>
<head>
  <title>集合</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1251"/>
<h1>集合</h1>

<div>
<span><div><div><div><div><div><div><a href="https://blog.csdn.net/ThinkWon/article/details/104588551?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160328460819725255510908%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160328460819725255510908&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-104588551.pc_search_result_cache&amp;utm_term=java%E9%9B%86%E5%90%88&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/ThinkWon/article/details/104588551?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160328460819725255510908%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160328460819725255510908&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-104588551.pc_search_result_cache&amp;utm_term=java%E9%9B%86%E5%90%88&amp;spm=1018.2118.3001.4187</a></div><div><img src="集合_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">java集合在哪个包下？</span></div><div><img src="集合_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">java集合的继承结构：</span></font></div><div><img src="集合_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/></div><div><br/></div><div><br/></div><div><img src="集合_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="集合_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Collection&lt;E&gt;接口</span></div><div><br/></div><div>Collection中的常用方法：</div><div><img src="集合_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>遍历Collection集合，需要用iterator()方法返回一个迭代器对象，</div><div><span style="font-weight: bold;">遍历集合</span></div><div>Collection c=new Arraylist();</div><div>Iterator it=c.iterator(); //获取迭代器</div><div>while(it.hasNext){</div><div>    Object o= it.next;</div><div>}</div><div><br/></div><div>注意： 1.当集合结构发生改变时，必须重新获取迭代器，否则会出现异常：java.util.ConcurrentModificationException </div><div>           2.遍历集合时，不能通过Collection的remove()方法删除元素，会出现异常：java.util.ConcurrentModificationException<span style="font-size: unset; color: unset; font-family: unset;"> 。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">可以通过Iterator中的remove()方法删除元素。Iterator中的remove()方法会主动更新迭代器。</span></div><div>           3.迭代器迭代出的默认都是Object类型。</div><div><br/></div><div>Collection中的contains()方法（判断集合中是否有该元素）</div><div>调用的是equal()方法。 </div><div>remove()方法也会调用equal(),删除元素。</div><div><br/></div><div><br/></div><div><img src="集合_files/Image [5].png" type="image/png" data-filename="Image.png"/></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">list接口</span></div><hr/><div>list接口特点：1.有序可重复；</div><div>                      2.list接口有下标，从0开始，以1递增。</div><div><span style="font-size: unset; color: unset; font-family: unset;">list接口常用方法：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            1.继承Collection接口的方法。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            2.</span><img src="集合_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>  list集合遍历：</div><div>            1.通过下标遍历（特有的，set集合没有）</div><div>            2.迭代器遍历。</div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">ArrayList集合（非线程安全的）</span></div><div><br/></div><div>1.ArrayList集合默认初始化容量是10(先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10)；</div><div>2.集合底层是Object[];</div><div>3.ArrayList自动扩容，增长1.5倍。数组扩容效率较低，最好预估计减少数组的扩容次数。</div><div><br/></div><div><img src="集合_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div>链表优点：</div><div>随机增删效率较高；</div><div>缺点：</div><div>不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头结点开始遍历，直到找到位置。</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">l</span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">inkedList集合</span></font>（双向链表）</div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">Vector集合</span>（线程安全，效率较低，使用较少）</div><div>1.底层也是一个数组；</div><div>2.初始 <span style="font-size: unset; color: unset; font-family: unset;">扩容（扩容之后是原容量的2倍）。</span></div><div><br/></div><div>怎么将ArrayList集合转换成Vector集合？(将非线程安全转换成线程安全)</div><div><span style="font-size: unset;"><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">java.util.Collections 集合工具类</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">java.util.Collections.sychronizedList();</span></div><div><span style="font-size: unset;"><br/></span></div><hr/><div><span style="font-size: 14pt; color: rgb(227, 0, 0); font-weight: bold;">泛型机制 </span><span style="font-size: unset; color: unset; font-family: unset;">指定集合中存储的数据类型。</span></div><div><span style="font-size: 12pt; font-weight: bold;">泛型这种语法机制，只在程序编译阶段起作用</span>，只是给编译器参考的。（运行阶段泛型没用）</div><div><br/></div><div>使用泛型的优点：</div><div>1.集合中的数据类型更加统一了。</div><div>2.从集合中取出的元素类型是泛型指定的类型，不需要大量的向下转型。（不适用泛型迭代器取出的是Object类型）</div><div><br/></div><div>JDK8之后引入了：自动类型推断机制（又称钻石表达式）</div><div>    eg： 之前是  List&lt;Animal&gt;myList=new ArrayList&lt;Animal&gt;();</div><div>        </div><div>           自动类型推断： List&lt;Animal&gt;myList=new ArrayList&lt;&gt;();</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">自定义泛型</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><hr/><div>JDK5.0之后新特性</div><div><span style="font-size: 14pt; font-weight: bold;">增强for循环（foreach）</span></div><div><br/></div><div>for(<span style="font-weight: bold;">元素类型</span> 变量名：数组或集合){</div><div><br/></div><div>}</div><div>foreach缺点：没有下标。</div><div><br/></div></div><hr/><div>HashSet集合</div><div><img src="集合_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>TreeSet集合</div><div><img src="集合_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><hr/><hr/><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Map接口</span></div><div><img src="集合_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="集合_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>转换成set集合中元素类型为Map.Entry。Map.Entry是Map中的静态内部类。</div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">Map的遍历</span></div><div><span style="font-size: unset;"><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">1.获取所有的Key，然后遍历。</span></span></div><div>    1&gt;通过keySet()方法获取所有的key ，返回的是Set集合；</div><div>    2&gt;Set集合构造迭代器遍历得到每一个key；</div><div>    3&gt;通过key获取value。</div><div>            String value=map.get(key);</div><div><span style="font-weight: bold;">2.foreach遍历</span></div><div>    1&gt;获取所有的key；</div><div>        Set&lt;Integer&gt;keys=map.keySet();</div><div>    2.foreach(Integer key:keys){</div><div>             String value=map.get(key);</div><div>             System.out.println(key+&quot;=&quot;+value);</div><div>}</div><hr/><div><span style="font-weight: bold;">3.Set&lt;Map.Entry&lt;E,V&gt;set&gt;=map.entrySet();</span></div><div>将Map集合转化成Set集合。</div><div>        遍历Set集合，每一次取出一个Node。</div><div>然后用迭代器遍历</div><div><img src="集合_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>还可以用foreach遍历</div><div><img src="集合_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">下面效率较高，适合大数据量。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">HashMap</span></div><hr/><div>1.HashMap集合底层是哈希表/散列表的数据结构</div><div>2.哈希表是一个数组和单向链表的结合体。</div><div>        数组：查询方面效率高，随机增删效率低。</div><div>        单向链表：随机增删效率高，查询方面效率低。</div><div><img src="集合_files/Image [14].png" type="image/png" data-filename="Image.png"/></div></div><div><img src="集合_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><img src="集合_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><img src="集合_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 14pt; color: rgb(227, 0, 0); font-weight: bold;">面试</span></div><div><img src="集合_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">HashMap扩容每次*2；默认加载因子是0.75</span></div><div>注意：</div><div>        放在HashMap k部分和HashSet中的元素，必须同时重写equals和hascode方法。</div><div><br/></div><div>在JDK8之后，Hashmap 链表节点数 超过8个时，会把链表转换成红黑树数据结构。当红黑树数据结构节点小于6时，会重新把红黑树变成单向链表数据结构。（为了提高检索效率）</div><div>HashMap k和V可以为null;</div><hr/><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">HashTable（线程安全）</span></div><div>HashTable是线程安全，初始化容量是11，默认加载因子是0.75</div><div>扩容：原容量*2+1；</div><div>HashTable的k 和V都不能为null；</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题：HashMap和HashTable的哈希函数的实现原理？</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题：为什莫选择0.75作为默认加载因子？</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题：为什莫放在HashMap k部分和HashSet中的元素，需要同时重写equals和hascode方法？</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题：基于上一个问题，要怎末重写equals和hascode方法？</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>https://www.jb51.net/article/132415.htm</div><div><br/></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题：equals == 和hashcode 的区别：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>https://www.cnblogs.com/kexianting/p/8508207.html</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题： <span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(18, 18, 18); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">为什么java的hashmap不支持动态缩小容量？</span></span></div><hr/><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">Properties属性类对象（线程安全的）</span></div><div>Properties是一个Map集合，继承Hashtabe，Properties的Key和Value都是String类型。</div><div>存</div><div>    setProperty();</div><div>取</div><div>    String getProperty();</div><hr/><div><span style="font-size: 12pt; font-weight: bold;">TreeSet集合（可排序集合）</span></div><div>1.TreeSet集合底层实际上是一个TreeMap；</div><div>2.TreeMap集合底层是一个二叉树。</div><div>3.放到TreeSet集合中的元素等同于放到TreeMap集合Key部分。</div><div>4.TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。</div><div><span style="font-size: 10pt; font-weight: bold;">无参构造TreeSet集合：</span></div><div>自定义类型放在TreeSet需要实现java.lang.Comparable接口。</div><div><span style="font-size: unset; color: unset; font-family: unset;">在compareto()方法设置比较规则。</span></div><div><img src="集合_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div><img src="集合_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div>也可以在创建TreeSet集合的时候，使用有参构造，传一个比较器Comparator进去，比较器需要实现Comparator接口。这种还可以用匿名内部类的方式。</div><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold;">结论</span></div><div><img src="集合_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">Collections集合工具类</span></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 