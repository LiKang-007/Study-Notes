<html>
<head>
  <title>10.5</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="839"/>
<h1>10.5</h1>

<div>
<span><div><div><span style="font-size: 18pt;">多态续：</span></div><div><br/></div><div>向下转型（加强制类型转换符）</div><div><br/></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">什么时候必须向下转型？</span></div><div>需要父类访问子类中特有的方法，</div><div><br/></div><div><span style="font-weight: bold;">向下转型的风险：</span></div><div>参考代码：</div><div><img src="10.5_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">编译阶段：</span>Cat和Animal存在继承关系，可以向下转型，编译通过。</div><div><span style="font-weight: bold;">运行阶段:</span>  堆内存实际创建的是：Bird对象，将Bird转成Cat，因为没有继承关系，运行出错。出现异常：Java.Lang.ClassCastException(类型转换异常)</div><div><br/></div><div>//Java.Lang.NullPointerException(空指针异常)；</div><div><br/></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">怎么避免 Java.Lang.ClassCastException异常？</span></div><div><span style="color: rgb(255, 0, 0);">运算符：</span></div><div><span style="color: rgb(255, 0, 0);">                instanceof   </span></div><div><span style="color: rgb(255, 0, 0);">   第一：instanceof可以在运行阶段动态判断引用指向对象的类型。</span></div><div><span style="color: rgb(255, 0, 0);">   第二：instanceof的语法：   （ 引用  instanceof  类型）</span></div><div><span style="color: rgb(255, 0, 0);">   第三：instanceof运算符的运算结果只能是：true/false</span></div><div><span style="color: rgb(255, 0, 0);">   第四：若（c instanceof Cat）为true表示：c引用指向堆内存的对象是Cat。</span></div><div><span style="color: rgb(255, 0, 0);">            经测试：</span></div><div><span style="color: rgb(255, 0, 0);">                        （子类引用 instanceof 父亲类型）结果为true</span></div><div><span style="color: rgb(255, 0, 0);">                        （父类引用 instanceof 子类型）结果为false</span></div><div>            若为flase，则c引用指向对内存中的对象不是Cat。</div><div><img src="10.5_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div> <span style="color: rgb(45, 79, 201);">任何时候，</span><span style="color: rgb(45, 79, 201);">Java规范中要求，</span><span style="color: rgb(45, 79, 201);">向下转型都需要用instanceof判断。</span></div><div><br/></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">向下转型是在向上转型的基础上。Animal a=new Cat();是向上转型。</span></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">    Cat c=new Animal();是错误的语句，不能这样用。    </span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">    </span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">    Animal a=new Cat();</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">    if(a instanceof Cat)</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">        Cat b=(Cat) a;//是向下转型</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">     </span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;"> 修饰符列表  返回值  方法名(Animal a){ </span></b></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">         if(a instanceof Cat){</span></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">    </span><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">             Cat c=(Cat) a;//是向下转型    </span></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">                 c.Cat类中的方法;</span></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">        }</span></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">         if(a instanceof Bird){      </span></div><div><span style="font-size: unset; color: rgb(227, 0, 0); font-family: unset; font-weight: bold;">                Bird b=(Bird)a;//是向下转型}</span></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">                b.Bird类中的方法；</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(227, 0, 0); font-family: unset;">}</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(79, 0, 154); font-family: unset;">//软件在扩展中，修改的越少越好。</span></b></div><div><b style="font-size: unset;"><span style="font-size: unset; font-weight: bold; color: rgb(79, 0, 154); font-family: unset;">七大软件开发原则：</span></b></div><div><b style="font-size: unset;"><br/></b></div><div><b style="font-size: unset;"><br/></b></div><div><span style="font-size: 12pt; color: rgb(65, 173, 28); font-weight: bold;">多</span><span style="font-size: 12pt; color: rgb(65, 173, 28); font-weight: bold;">态在开发中有什么作用？</span></div><div><span style="font-size: 12pt; color: rgb(65, 173, 28); font-weight: bold;">降低程序的耦合度，提高程序的扩展力。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(65, 173, 28); font-weight: bold;">设置形式参数为父类对象，通过向上转型，只需要新添的类继承该父类，覆盖父类的方法，不需要修改原先代码。</span></span></div><div><span style="font-size: 12pt; color: rgb(65, 173, 28); font-weight: bold;">面向父类型编程，面向抽象编程，不建议面向具体编程。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">提高代码扩展性，符合软件开发七大原则中的OCP，对修改关闭，对扩展开放。</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">开发软件，不仅要实现当前需求，还要考虑软件的扩展性。</span></div><div><br/></div><div><span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">父类中的变量无法被子类覆盖或重写</span></div><div><img src="10.5_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>可以通过成员方法得到成员变量的信息，</div><div><span style="font-weight: bold;"><img src="10.5_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: unset; font-weight: bold;">结论：对成员变量要进行封装，向上转型通过成员方法来获取成员变量，不封装的话，父类引用所调用的成员方法可能不是预期值。</span></div><div><b style="font-size: unset;"><br/></b></div><div><span style="color: rgb(222, 87, 0); font-weight: bold;">方法覆盖必须和多态机制联合起来使用才有意义，方法覆盖针对的是实例方法。</span></div><div><span style="font-weight: bold;">多态和对象有关，静态方法不需要对象，所以，静态方法覆盖没有意义。</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">总结：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">私有方法不能覆盖，</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">静态方法不谈覆盖。</span></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">关于方法覆盖中的返回值类型：</span></div><div><br/></div><div><span style="font-weight: bold;"><img src="10.5_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><hr/><hr/><div><span style="font-size: 16pt; color: rgb(173, 0, 0);">super关键字：</span></div><div><span style="font-size: 16pt; color: rgb(173, 0, 0);"><img src="10.5_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 16pt;"><img src="10.5_files/Image [6].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 16pt;">this()和Super()不能在一个构造方法中共存，都只能出现在构造方法第一行。</span></div><div><font style="font-size: 16pt;"><br/></font></div><div><span style="font-size: 14pt;">父类的构造方法一定会执行。没有手动调用父类构造方法，默认在第一行有super（）；// 默认执行父类无参构造方法</span></div><div><br/></div></div><div><img src="10.5_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>public static void main(String[] args)<span style="font-size: unset; color: unset; font-family: unset;">{</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    new c:</span></div><div>    <span style="font-size: unset; color: unset; font-family: unset;">}</span></div><div>执行结果：</div><div>1-3-6-5-4</div><div>在Java语言中，任何程序，最后Object类的无参构造方法一定会执行。Object类的无参构造方法处于“栈顶部”。</div><div>栈顶特点，最后调用，最先执行。</div><div><br/></div></span>
</div></body></html> 