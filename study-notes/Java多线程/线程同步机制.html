<html>
<head>
  <title>线程同步机制</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4047"/>
<h1>线程同步机制</h1>

<div>
<span><div>      <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">线程同步机制是一套用于协调线程之间的数据访问的机制，该机制可以保障线程安全。</span></font></div><div>        Java平台提供的线程同步机制包括：锁，<span style="font-weight: bold;">volatile关键字，final关键字，static关键字，以及相关的API</span>，如Object.wait()/Object.notify()等。</div><div><br/></div><div>    <span style="font-size: 14pt; font-weight: bold;">1、</span><span style="font-size: 14pt; font-weight: bold;">锁</span><span style="font-size: 14pt; font-weight: bold;">概述：</span></div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); color: rgb(227, 0, 0); font-weight: bold;-evernote-highlight:true;">线程安全问题的产生前提是多个线程并发访问共享数据。将多个线程对共享数据的并发访问转换为串行访问。（即一个共享数据一次只能被一个线程访问）</span></span></div><div>        <span style="font-weight: bold;">一个线程在访问共享数据之前必须先获得锁； 获得锁的线程被称为锁的持有线程；一个锁一次只能被一个线程持有。</span></div><div>        锁的持有线程在获得锁之后和释放锁之前这段时间所执行的代码被称为<span style="font-weight: bold;">临界区。</span></div><div>        锁具有排他性，即一个锁一次只能被一个线程持有，这种锁称为<span style="font-weight: bold;">排它锁或者互斥锁。</span></div><div><img src="线程同步机制_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>JVM把锁分为内部锁和显示锁两种，<span style="font-weight: bold;">内部锁</span>通过synchronized关键字实现；<span style="font-weight: bold;">显示锁</span>通过java.concurrent.locks.lock接口的实现类实现。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;"> 锁的作用：</span></div><div>       锁可以实现对共享数据的安全访问，保障线程的原子性，可见性与有序性。 </div><div>        <span style="font-weight: bold;">锁是通过互斥保障原子性</span>，一个锁只能被一个线程持有，这就保证了临界区的代码一次只能被一个线程执行，使得临界区代码所执行的操作具有不可分割的特性，即具备了原子性。</div><div>        <span style="font-weight: bold;">可见性的保障是通过写线程冲刷处理器的缓存和读线程刷新处理器缓存这两个动作实现的。</span>java平台中，锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着冲刷处理器缓存的动作。</div><div>        <span style="font-weight: bold;">锁能够保障有序性</span>，写线程在临界区所执行的在读线程所执行的临界区看来像是完全按照源码顺序执行的。</div><div>    <span style="font-weight: bold;">注意：</span></div><div>      <span style="font-weight: bold;">  使用锁保障线程的安全性，必须满足以下条件：</span></div><div>            1、这些线程在访问共享数据时必须使用同一个锁；</div><div>            2、即使是读取共享数据的线程也需要使用同步锁。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">锁相关的概念</span></div><div>  <span style="font-size: 11pt; font-weight: bold;">  1、可重入性：</span></div><div>        可重入性（Reentrancy）描述这样一个问题：一个线程持有该锁的时候能否再次（多次）申请该锁。</div><div>    Lock是一种可重入锁。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void methodA(){</div><div>    申请a锁;</div><div>    methodB();</div><div>    释放a锁</div><div>}</div><div>void methodB(){</div><div>    申请a锁;</div><div>    ...</div><div>    释放a锁;</div><div>}    </div></div><div>    如果一个线程持有一个锁的时候还能够继续成功申请该锁，称该锁是可重入的，否则称该锁是不可重入的。</div><div><br/></div><div>    <span style="font-size: 11pt; font-weight: bold;">2、锁的争用与调度</span></div><div>        Java平台中内部锁属于非公平锁，显示 Lock锁即支持公平锁又支持非公平锁。</div><div>  <span style="font-size: 11pt; font-weight: bold;">  3、锁的粒度</span></div><div>        一个锁可以保护的共享数据的数量大小称为锁的粒度。</div><div>     锁保护的共享数据量大，称该锁的粒度粗，否则就称该锁的粒度细。</div><div>    锁的粒度过粗会导致线程在申请锁时会进行不必要的等待，所得粒度过细会增加锁调度的开销。</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">2、内部锁：synchronized关键字</span></div><div><br/></div><div>    Java中的每个对象都有一个与之关联的内部锁（Intrinsic Lock），这种锁也称为监视器（Monitor），这种内部锁是一种排他锁，可以保障原子性，可见性与有序性。</div><div>    内部锁是通过synchronized关键字实现的，synchronized关键字修饰代码块，修饰方法。</div><div>    <span style="font-weight: bold;">修饰代码块的语法：</span></div><div>        synchronized(对象锁){</div><div>            同步代码块，可以在同步代码块中访问共享数据</div><div>        }</div><div>    修饰实例方法就称为同步实例方法</div><div>    修饰静态方法就称为同步静态方法</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void mm(){</div><div>    synchronized(this){//<b><font color="#FF0000">经常使用this当前对象作为锁对象</font></b></div><div>        for(int i=1;i&lt;=100;i++){</div><div>            }</div><div>    }</div><div>}</div><div><br/></div></div><div><span style="font-weight: bold;">1、使用this（当前对象）作为锁对象（synchronized同步代码块）</span></div><div>        注意：实现同步必须使用同一个锁对象。</div><div><img src="线程同步机制_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">2、使用常量作为锁对象</span></div><div>    不管是实例方法还是静态方法，只要使用同一个锁对象就可以实现同步。</div><div><span style="font-weight: bold;">3、synchroized同步实例方法</span>：把整个方法体作为同步代码块，默认的锁对象是this对象.</div><div>    语法：</div><div>            public synchronized void mm(){</div><div>                </div><div>            }</div><div><span style="font-weight: bold;">4、synchronized同步静态方法</span>：把整个方法体作为同步代码块，默认的锁对象是当前类的运行时类对象（运行时类对象：类名.class）</div><div>将运行时类对象作为锁对象，也称为类锁。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>同步静态方法，和同步实例方法，不管是对象调用静态方法还是类调用静态方法，都会实现同步。</div></div><div><br/></div><div>与同步方法相比同步代码块执行效率更高。（主要就是同步代码块代码块前的运行时间）</div><div>同步方法与同步代码块如何选择？</div><div>    同步方法锁的粒度粗，执行效率低；同步代码块，锁的粒度细，执行效率高。</div><div><br/></div><div><span style="font-size: 11pt; font-weight: bold;">脏读：</span></div><div>    出现读取属性值出现了一些意外，读取的是中间值，不是修改后的值。</div><div>    <span style="font-weight: bold;">出现脏读的原因</span>：对共享数据的修改 与对共享数据的读取不同步。</div><div>    <span style="font-weight: bold;">解决方法</span>：不仅对修改数据的代码块进行同步，还要对读取数据的代码块同步。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">    同步过程中线程出现异常，会自动释放锁对象。其他线程获得锁对象，继续执行。</span></div><div>    </div><div><span style="font-size: 14pt; font-weight: bold;">死锁：</span></div><div>    在多线程程序中，同步可能需要使用多个锁，如果获得锁的顺序不一致，可能会导致死锁。</div><div>    如何避免死锁？</div><div>        当需要获得读个锁时，所有线程获得锁的顺序保持一致即可。</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">3、轻量级同步机制：volative关键字</span></div><div><span style="font-size: 12pt; font-weight: bold;">    3.1、volative的作用</span></div><div><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">       </span> <span style="font-size: 10pt; font-weight: bold;">volatile关键字的作用：</span><span style="font-size: 10pt;">使变量在多个线程之间可见。强制线程从公共内存中读取变量的值，而不是从工作内存中读取。</span></div><div><span style="font-size: 10pt;"> </span> <span style="font-size: 12pt; font-weight: bold;"> 3.2、volatile与synchronized比较</span></div><div><span style="font-size: 10pt;">                    1&gt;volatile关键字是线程同步的轻量级实现，所以volatile的性能肯定比synchronized要好；volatile只能修饰变量，而synchronized可以修饰方法，代码块。随着JDK新版本的发布，synchronized的执行效率也有较大提升，在开发中使用synchronized的比率还是很大的。</span></div><div><span style="font-size: 10pt;">                    2&gt;多线程访问volatile变量不会发生阻塞，而synchronized可能会发生阻塞。</span></div><div><span style="font-size: 10pt;">                    3&gt;volatile能保证数据的可见性，但是它不能保证原子性。synchronized可以保证原子性，也可以保证可见性。</span></div><div><span style="font-size: 10pt;">                    4&gt;关键字volatile解决的是变量在多个线程之间的可见性；synchronized关键字解决的是多个线程之间访问公共资源的同步性。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">    3.3、volative非原子特性</span></div><div><span style="font-size: 12pt;">                volative关键字仅仅表示的所有线程从主内存读取count变量的值，它不具备原子性：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class{</div><div>    main(){</div><div>        for(int i=0;i&lt;100;i++){</div><div>            new MyThread().static();</div><div>        }</div><div>    }</div><div>    myThread(){</div><div>        public volatile static int count;</div><div>        public  static void addCount(){    </div><div>            for(int i=0;i&lt;1000;i++){</div><div>                count++;</div><div>            }</div><div>            sout(count);</div><div>        }</div><div>    }</div><div>}</div><div><font face="Monaco">这段代码不是线程同步的，想要实现线程同步，需要使用synchronized进行同步，使用synchronized关键字之后，也就不需要valatile关键字了。</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">    3.4、常用的原子类进行自增 自减操作</span></div><div><span style="font-weight: bold;"><span style="font-size: 12pt; font-weight: bold;">          </span> <span style="font-size: 10pt; font-weight: bold;">  i++操作不是原子操作，除了使用synchronized进行同步，也可以使用Atomiclnteger/AtomicLong原子类进行实现（原子类实现同步的原理：CAS）</span></span></div><div><span style="font-size: 12pt; font-weight: bold;">            1、使用AtomicInteger对象</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class{</div><div>    main(){</div><div>        for(int i=0;i&lt;100;i++){</div><div>            new MyThread().static();</div><div>        }</div><div>    }</div><div>    myThread(){</div><div>        public volatile static AtomicInteger count=newAtomicInteger();</div><div>        public  static void addCount(){    </div><div>            for(int i=0;i&lt;1000;i++){</div><div>                count.getAndIncrement();</div><div>            }</div><div>            sout(count);</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.5 CAS</span></div><div>    CAS（Compare And Swap）是由硬件实现的。</div><div>    CAS可以将read-modify-write这类的操作转换为原子操作</div><div>        i++操作包括三个子操作：</div><div>            1、从内存读取i变量的值；</div><div>            2、对i的值加1；</div><div>            3、在把加1之后的值保存到主内存</div><div>        <span style="font-weight: bold;">CAS原理：在把数据更新到主内存时，再次读取主内存变量的值，如果现在变量的值与期望的值（操作起始时读取的值）一样就更新。</span></div><div><img src="线程同步机制_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="线程同步机制_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>使用CAS实现一个线程安全的计数器：</div><div>class Count {</div><div>    volatile private long value;</div><div>    public long getValue(){</div><div>        return value;</div><div>    }</div><div>    //定义一个comare and swap</div><div>    private boolean compareAndSwap(long expectedValue,long newValue){</div><div>    //如果当前的value值与期望的expectedValue值一样，就把当前的Value字段替换为newValue</div><div>    synchronized(this){</div><div>        if(value==expectedValue){</div><div>            value=newValue;</div><div>            return true;</div><div>        }else{</div><div>            false;</div><div>        }</div><div>    }</div><div>}</div><div>    //定义自增的方法</div><div>    public int incrementAndGet(){</div><div>        long oldValue;</div><div>        long newValue;</div><div>        do{</div><div>            longValue=value;</div><div>            newValue=oldValue;</div><div>        }while(!compareAndSwap(oldValue,newValue))</div><div>        </div><div>        retrun newValue;</div><div>    }</div><div>}</div></div><div>       <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">CAS实现原子操作背后有一个假设：共享变量的当前值与当前线程提供的期望值相同，就认为这个变量没有被其他线程修改过，实际上这种假设不一定总是成立，</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        如：存在共享变量 count=0;</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                                    A线程对count值修改为10；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                                    B线程对count值修改为20；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                                    C线程对count值修改为0；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                                    当前线程看到count变量的值现在是0，现在是否认为count变量的值没有被其他线程的值更新？这种结果是否能够接受？</span></div><div>                <span style="font-weight: bold;">这就是CAS中的ABA问题，即共享变量经历了A-&gt;B-&gt;A的更新</span></div><div><span style="font-weight: bold;">            是否能够接受ABA问题跟实现的算法有关。</span></div><div>    </div><div>        如果想要规避ABA问题，可以为共享变量引入一个修订号（时间戳），每次修改共享变量时，相应的修订号就会增加1。</div><div>        引入修订号（时间戳）之后，共享变量的更新过程</div><div>    【A，0】-&gt;【B，1】-&gt;【A，2】，每次对共享变量的修改都会导致共享变量修订号的增加，通过修订号依然可以准确判断变量是否被其他线程修改过。</div><div>        AtomicStampedRefere类就是基于这种思想产生的。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">   3、6   原子变量类：</span></div><div>            原子变量类基于CAS实现的，当对共享变量read-modify-write更新操作时，通过原子变量类可以保障操作的原子性与可见性，对变量的read-modify-write更新操作是指，当前操作不是一个简单的赋值，而是变量的新值依赖变量的旧值，如自增操作i++。由于volatile只能保证可见性，无法保障原子性，原子变量类内部就是借助一个Volatile变量，并且保障了该变量的read-modify-write操作的原子性，有时把原子变量类看做是增强的volatile变量，原子变量类有12个。</div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 120px;"></col><col style="width: 250px;"></col></colgroup><tbody><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>分组</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div>原子变量类</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>基础数据型</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div>AtomicInteger,AtomicLong,AtomicBoolean</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>数组型</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div>AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>字段更新器</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div> AtomicIntegerFieldUpdate，</div><div>AtomicLongFieldUpdate，</div><div>AtomicReferenceFieldUpdater</div></td></tr><tr><td style="width: 120px; padding: 8px; border: 1px solid;"><div>引用型</div></td><td style="width: 250px; padding: 8px; border: 1px solid;"><div>AtomicReference，AtomicStamped Reference，AtomicMarkableReference</div></td></tr></tbody></table><div><span style="font-size: 12pt; font-weight: bold;">3.6.1 AtomicLong</span></div></div><div>    使用原子变量类定义一个计数器，该计数器在整个程序中都能使用，并且所有的地方都使用这一个计数器，这个计数器可以设置为单例。</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Indicator{</div><div>    //构造方法私有化</div><div>    private Indicator(){}</div><div>    //定义一个私有的本类的静态对象</div><div>    private static final Indicator INSTANCE=new Indicator();</div><div>    //提供一个公共静态方法返回改类的唯一实例</div><div>    public static Indicator getInstance(){</div><div>        return INSTANCE;</div><div>    }</div><div>    //使用原子变量类保存请求总数，成功数，失败数</div><div>    private final AtomicLong requestCount=new AtomicLong(0);//记录请求总数</div><div>private final AtomicLong successCount=new AtomicLong(0);//处理成功总数</div><div>private final AtomicLong fialureCount=new AtomicLong(0);//处理失败总数</div><div>    //有新的请求</div><div>    public void new RequestReceive(){</div><div>        requestCount.incrementAndGet();</div><div>    }</div><div>    //处理成功</div><div>    public void requestProcessSuccess(){</div><div>        successCount.incrementAndGet();</div><div>    }</div><div>    //处理失败</div><div>    public void requestProcessFailure(){</div><div>        fialureCount.incrementAndGet();</div><div>    }</div><div>    //查看总数，成功数，失败数</div><div>    public long getRequestCount(){</div><div>        return requestCount.get();</div><div>    }</div><div>    public long getSuccessCount(){</div><div>        return successCount.get();</div><div>    }</div><div>    public long getFialureCount(){</div><div>        return fialureCount.get();</div><div>    }</div><div>}</div></div><div>在实际应用中可以在ServletFilter中调用Indicator计数器的相关方法。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.6.2 AtomicIntegerArray </span> <span style="font-size: unset; color: unset; font-family: unset;">原子更新数组</span></div><div>        </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>psvm{</div><div>  //创建一个指定长度的原子数组  AtomicIntegerArray atomicIntegerArray=new AtomicIntegerArray(4);</div><div>    sout(atomicIntegerArray);//[0,0,0,0]</div><div>     //返回指定位置的元素  </div><div>    atomicIntegerArray.get(0);</div><div>    //设置指定位置的元素</div><div>    atomicIntegerArray.set(0,10);</div><div>    //在设置元素的新值，同时返回数组元素的旧值</div><div>    atomicIntegerArray.getAndSet(1,11);</div><div>    //修改数组元素的值，把数组元素加上某个值,先加在返回</div><div>    atomicIntegerArray.addAndGet(0,22);</div><div>    //修改指定元素的值，把数组元素加上某个值，先返回在加</div><div>    atomicIntegerArray.getAndAdd(1,33);</div><div>    ----</div><div>    CAS操作</div><div>    //如果0号索引元素是32的话，将它设置为222，替换成功返回true，替换不成功返回false</div><div>    atomicIntegerArray.compareAndSet(0,32,222);</div><div>    </div><div>    自增/自减</div><div>    atomicIntegerArray.incrementAndGet(0);</div><div>    atomicIntegerArray.getAndIncrement(1);</div><div>    atomicIntegerArray.getAndDecrement(1);</div><div>    atomicIntegerArray.decrementAndIncrement(1);</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>在多线程中使用原子数组</div><div>class Test{</div><div>    static  AtomicIntegerArray atomicIntegerArray =new</div><div>AtomicIntegerArray(10);</div><div><br/></div><div>    psvm(){</div><div>       //定义线程数组</div><div>        Thread[] thread=new Tread[10];</div><div>        //给线程数组元素赋值</div><div>        for(int i=0;i&lt;thread.length;i++){</div><div>            thread[i]=new AddThread();</div><div>        }</div><div>        //开启子线程</div><div>        for(Thread thread:threads){</div><div>            thread.static(); </div><div>        }</div><div>        //在主线程中查看自增完以后，原子数组中的各个元素的值，在主线程中需要在所有子线程都执行完之后在查看</div><div>        //把所有的 子线程合并到当前主线程当中</div><div>        for(Thread thread:threads){</div><div>            thread.join();</div><div>        }</div><div>        System.out.println(atomicIntegerArray);</div><div>    }</div><div><br/></div><div>    static class AddThread extends Thread{</div><div>        public void run(){</div><div>            //把每个原子数组自增1000次，</div><div>            for(int j=0;j&lt;1000;j++){</div><div>                for(int i=0;i&lt;atomicIntegerArray.length();i++){</div><div>                atomicIntegerArray.getAndIncrement(i%atomicIntegerArray.length());</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br/></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">3.6.3AtomicLintegerFiledUpdater</span></div><div>    AtomicLintegerFiledUpdater<span style="font-weight: bold;">可以对原子整数字段进行更新</span>，要求：</div><div>    1、字符必须使用volatile修饰，使线程之间可见</div><div>    2、只能是实例变量，不能是静态变量，也不能使用final修饰。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class SubThread extends Thread{</div><div>    priavte User user;</div><div>    priavte AtomicLintegerFiledUpdater&lt;User&gt;updater=   AtomicLintegerFiledUpdater.newUpdater(User.class,&quot;age&quot;);</div><div>    public SubYhread(User user){</div><div>        this.user=user;</div><div>    }</div><div>    public void run(){</div><div>        //在子线程中对user对象的age字段自增10次</div><div>        for(int i=0;i&lt;10;i++){</div><div>            System.out.println(update.getAndIncrement(user));</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.6.4 AtomicReference</span></div><div>    可以原子读写一个对象  </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test01{</div><div>    static AtomicReference&lt;String&gt; atomicReference=new AtomicReference(&quot;abc&quot;);</div><div>    public static void main(){</div><div>        //创建100个线程修改字符串</div><div>        for(int i=0;i&lt;100;i++){</div><div>            new Thread(new Runnable(){</div><div>                public void run(){</div><div>                    if(atomicReference.compareAndSet(&quot;abc&quot;,&quot;def&quot;)){</div><div>        System.out.print(Thread.currentThread().getName()+&quot;把字符串abc更改为def&quot;);</div><div>                    }</div><div>                }</div><div>            }).start();</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">AtomicReference可能会出现CAS中的ABA问题。</span></div><div>  </div><div>AtomicStamped Reference，</div><div>AtomicMarkableReference，</div><div>都可以解决ABA问题。</div><div>AtomicStamped Reference原子类中有一个整数标记值 stamp，每次执行CAS操作时，需要对比它的版本，即比较stamp的值。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test03{</div><div>    priavte static AtomicStamedReference&lt;String&gt;stampedReference=new AtomicStampedReference&lt;&gt;(&quot;abc&quot;,0);</div><div><br/></div><div>    public static void main(String[] args){</div><div>        public void run(){</div><div>            stampedReference.compareAndSet(&quot;abc&quot;,&quot;def&quot;,stampedReference.getStamp(),stampedReference.getStamp()+1);//版本号+1</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">4、线程之间通信</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">4、1 等待通知机制</span></div><div>      <span style="font-size: 11pt;"> </span> <span style="font-size: 11pt; font-weight: bold;">4.1.1、什么是等待通知机制？</span></div><div>            在单线程编程中，要执行的操作需要满足一定的条件才能执行，可以把这个操作放在if语句块中。</div><div>            在多线程编程中，可能A线程的条件没有满足只是暂时的，稍后其他的线程B可能会更新条件使得A线程的条件得到满足，可以将A线程暂停，直到它的条件得到满足后再将A线程唤醒。</div><div>            伪代码：</div><div>           atomics {//原子操作</div><div>                    while(条件不成立){</div><div>                        等待</div><div>                    }</div><div>            当前线程被唤醒条件满足后，继续执行下面的操作</div><div><br/></div><div>        }</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">       </span> <span style="font-size: 11pt; font-weight: bold;">4.1.2、等待/通知机制的实现</span></div><div>                <span style="font-weight: bold;">object类中的wait方法可以使执行当前代码的线程等待，暂停执行，直到接到通知或被中断为止。</span></div><div>              <span style="font-weight: bold;">  注意：</span></div><div>                    1、wait（）方法只能在同步代码块中由锁对象调用</div><div>                    2、调用wait（）方法，当前线程会释放锁</div><div>              <span style="font-weight: bold;">  伪代码：</span></div><div>            synchronized(锁对象){</div><div>                    </div><div>                    while(条件不成立){</div><div>                        //通过锁对象调用wait（）方法暂停线程</div><div>                        锁对象.wait();</div><div>                }</div><div>                    //线程的条件满足了继续向下执行</div><div>            }</div><div><br/></div><div>          <span style="font-weight: bold;">  object类的notify（）可以唤醒线程，该方法也必须在同步代码块中由锁对象调用</span>，<span style="font-weight: bold;">没有使用锁对象调用wait（）/notify（）会抛出IIegalMonitorStateExeption异常，如果有多个等待的线程，notify（</span><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">）方法只能唤醒其中的一个。在同步代码块中调用notify（）方法并不会立即释放锁对象，需要等当前同步代码块执行完后才会释放锁对象，一般将notify（）方法放在同步代码块的最后</span><span style="font-size: unset; color: unset; font-family: unset;">，它的</span><span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">伪代码</span><span style="font-size: unset; color: unset; font-family: unset;">如下：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            synchronized（锁对象）{</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">         </span></div><div><span style="font-size: unset; color: unset; font-family: unset;">               //修改保护条件的代码</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                //唤醒其他线程</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">                锁对象.notify();</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        }</span></div><div>    </div><div>    wait（）方法的基本使用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test01{</div><div>    /*</div><div>        <font color="#FF0000"><b>wait()和notify()必须放在同步代码块中，否则会报</b></font></div><div><b><font style="color: rgb(255, 0, 0);">java.lang.IllegalMonitorStateException异常</font></b></div><div>    */</div><div>    public static void main(String[] args){</div><div>        try{</div><div>            String test=&quot;123&quot;;</div><div>            test.wait();//java.lang.IllegalMonitorStateException异常</div><div>        }catch(InterruptedException e){</div><div>            e.printStackTrace();</div><div>        }</div><div>    }</div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test02{</div><div>   </div><div>    public static void main(String[] args){</div><div>        try{</div><div>            String text=&quot;123&quot;;</div><div>            String another=&quot;456&quot;;</div><div>            System.out.println(&quot;同步前的代码&quot;);</div><div>            synchronized(text){</div><div>                System.out.println(&quot;同步代码块开始&quot;);</div><div>                text.wait();//<b><font color="#FF0000">调用wait方法后，当前线程就会等待，释放锁对象，当前对象需要被唤醒，如果没有唤醒，就会一直等待</font></b></div><div><font color="#FF0000"><b>                //不是锁对象调用会产生</b>java.lang.IllegalMonitorStateException异常</font></div><div><b><font color="#FF0000">                //another.wait();</font></b></div><div>                System.out.println(&quot;wait后面的代码&quot;);   </div><div>            } </div><div>            System.out.println(&quot;同步代码跨后面的代码&quot;);</div><div>        }catch(InterruptedException e){</div><div>            e.printStackTrace();</div><div>        }</div><div>        System.out.println(&quot;main后面的其他代码&quot;);</div><div>    }</div><div>}</div><div><br/></div><div><br/></div></div><div><br/></div><div>使用notify唤醒等待的线程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test03{</div><div>    public static void main(String[] args){    </div><div>        String lock=&quot;123&quot;;//定义一个字符串作为锁对象</div><div>        Thread t1=new Thread(new Runnable(){</div><div>            public void run(){</div><div>                synchronized(lock){</div><div>                    System.out.println(&quot;线程1开始等待：&quot;+System.currentTimeMillis());</div><div>                    lock.wait();//线程等待，会释放锁对象，当前线程转入等待状态；</div><div>                    System.out.println(&quot;线程1结束等待&quot;+System.currentTimeMillis());</div><div>                }</div><div>            }</div><div>        });</div><div>        //定义第二个线程，在第二个线程中唤醒第一个线程</div><div>        Thread t2=new Thread(new Runnable(){</div><div>            public void run(){</div><div>                //notify()方法也需要在同步代码块中，由锁对象调用</div><div>                synchronized(lock){</div><div>                    System.out.println(&quot;线程2开始唤醒&quot;+System.currentTimeMillis());</div><div>                }</div><div>            }</div><div>        })</div><div>        t1.start();//开启t1线程，t1线程等待</div><div>        Thread.sleep(3000);// main线程睡眠3秒，确保t1入睡</div><div>        t2.static();//t1线程开启3秒后，再开启t2线程唤醒t1线程。</div><div>    </div><div>    }</div><div><br/></div><div>}</div></div><div>notify（）方法不会立即释放锁对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test04{</div><div>    public static void main(String[] args){</div><div>        //定义一个List集合存储String数据</div><div>        List&lt;String&gt;list=new ArrayList&lt;&gt;();</div><div>        //定义第一个线程，当list集合中的元素不等于5时线程等待</div><div>        Thread t1=new Thread(new Runnable(){</div><div>            public void run(){</div><div>                synchronized(list){</div><div>                    if(list.size()!=5){</div><div>                        System.out.println(&quot;线程1开始等待&quot;+System.currentTimeMillis());</div><div>                        list.wait();</div><div>                        System.out.println(&quot;线程1被唤醒&quot;+System.currentTimeMillis());</div><div>                    }</div><div>                }</div><div>            }</div><div>        })</div><div>        //定义第二个线程，向list集合添加元素</div><div>        Thread t2=new Thread(new Runnable(){</div><div>            public  void ren(){</div><div>                for(int i=0;i&lt;10;i++){</div><div>                    list.add(&quot;data--&quot;+i);</div><div>                    System.out.println(&quot;线程2添加了第&quot;+(i+1)+&quot;个数据&quot;);</div><div>                    //判断元素的数量是否满足线程1</div><div>                    if(list.size()==5){</div><div>                        list.notify();//notify不会立即释放锁对象，需要等到当前同步代码块都执行完，才会释放锁对象。</div><div>                        System.out.println(&quot;线程2已经发现唤醒 通知&quot;);</div><div>                    }</div><div>                Thread.sleep(1000);</div><div>                }</div><div>            }</div><div>        })</div><div>        t1.start();</div><div>        //为了确保t2在t1之后开启</div><div>        Thread.sleep(500);</div><div>        t2.start();</div><div>    }</div><div>}</div></div><div><br/></div><div>   <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"> </span><span style="font-size: 11pt; font-weight: bold;">4.1.3、interrupt（）方法会中断wait()</span></font></div><div>        当线程处于wait（）等待状态时，调用线程对象的interrupt（）方法会中断线程的等待状态，会产生InterruptedException异常</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Test05{</div><div>    public static void main(String[] args){</div><div>        SubThread t=new SubThread();</div><div>        t.start();</div><div>        Thread.sleep(2000);//主线程睡眠两秒，确保子线程处于wait状态 </div><div>        t.intreeupt();</div><div>    }</div><div>    private static final Object LOCK=new  Object();//定义常量作为锁对象</div><div>    static class SubThread extends Thread{</div><div>        public void run(){</div><div>            synchronized(LOCK){</div><div>                System.out.println(begin wait);</div><div>                LOCK.wait();</div><div>                System.out.println(end wait);</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div>释放锁对象：</div><div>        1、代码块执行完毕；</div><div>        2、执行wait()方法；</div><div>        3、线程意外终止。 </div><div>  <span style="font-size: 12pt; font-weight: bold;">  4.1.4 notify()与notifyAll()的作用都是唤醒线程。</span></div><div>        区别在于：</div><div>            1、notify（）一次只能唤醒一个线程，如果有多个等待的线程，只能随机唤醒其中的一个；notifyAll一次可以唤醒所有线程</div><div>        （调用一次notify来唤醒其中的一个线程，其他等待的线程依然处于等待状态，对于等待状态的线程来说，错过了通知信号，这种现象也称为信号丢失）</div><div>  <span style="font-size: 12pt; font-weight: bold;">  4.1.5 wait（long）的使用</span></div><div>        wait（long）带有long类型参数的wait()等待，如果在参数指定的时间内没有被唤醒，超时后会自动唤醒，long数值为指定的时长。</div><div>  <span style="font-size: 12pt; font-weight: bold;">  4.1.6通知过早</span></div><div>        线程wait（）等待后，可以调用notify（）唤醒线程，如果notify唤醒过早，在等待之前就调用的notify（）可能会打乱程序正常的执行逻辑。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">调用start（）就是告诉线程调度器，当前线程准备就绪，线程调度器在什么时候开启这个线程不确定，即调用start方法的顺序，并不一定就是线程实际开启的顺序。</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">定义一个静态变量作为第一个线程运行的线程 标志</font></div><div><font face="Monaco">    static boolean isFirst=true;</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco"><br/></font></div></div><div>    <span style="font-size: 12pt; font-weight: bold;">4.1.7 wait等待的条件发生了变化</span></div><div>        在使用wait/notify模式时，注意wait条件发生了变化，也可能造成逻辑的混乱。</div><div><img src="线程同步机制_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="线程同步机制_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>        出现异常的原因：向集合中添加一一个元素，取出了两次。</div><div>      <span style="font-size: 11pt; font-weight: bold;">  如何解决？</span></div><div>            当等待的线程被唤醒后，再判断一次集合中是否有数据可取，需要把if(list==0)改为while(list==0),让取数据的线程在重新获取执行权后再重新判断一次。</div><div>    <span style="font-size: 11pt; font-weight: bold;">4.1.8 生产者消费者模式</span></div><div>        在java程序设计中，负责生产数据的模块是生产者，负责使用数据的模块是消费者。生产者-消费者解决数据平衡问题，即先有数据然后才能使用，没有数据时，消费者需要等待。</div><div>       <span style="font-weight: bold;">1、生产者-消费者 操作数据 （数据量为1）</span></div><div>            <span style="font-weight: bold;">一个生产者一个消费者</span>，略。</div><div>            <span style="font-weight: bold;">多个生产者多个消费者。</span></div><div>                注意：1、每个消费者被唤醒时，要先判断集合里当前有没有值。每个生产者被唤醒时，先判断集合里的值是不是充足。</div><div>                        2、使用this作为锁，有这么一种情况，生产者1生产，唤醒了生产者2，生产者2等待，生产者2唤醒生产者3，生产者3等待，。。。。所有生产者全部等待，唤醒消费者1，消费者1消费，唤醒消费者2，等待，消费者2唤醒消费者3，消费者3等待，所有的消费者全部等待。所有线程全部等待，进入假死状态。</div><div>        <span style="font-weight: bold;">出现假死的原因：</span>生产者线程不能确定它唤醒的是消费者线程，消费者线程同理。</div><div>        <span style="font-weight: bold;">解决方案：</span>可以将notify()改为notifyAll();</div><div>       </div><div> <font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">       2、操作栈 </span></font><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">    </span></font>   </div><div>        使生产者把数据存储到List集合中，消费者从List集合取数据，使用List集合模拟栈。            </div><div>        </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">4.2、通过管道实现线程间的通信</span></div><div>        在java.io包中的PipeStream管道流用于在线程之间传送数据，一个线程发送数据到输出管道，另外一个线程从输入管道中读取数据。相关的类包括：PipedInputStream和PipedOutputStream， PipedReader和PipedWriter。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class {</div><div><br/></div><div>    public static void main(String[] args){</div><div>        //定义管道字节流</div><div>        PipedInputStream inputStream=new PipedInputStream();</div><div>PipedOutputStream outputStream=new PipedOutputStream();</div><div>    inputStream.connect(outputStream);</div><div>        //定义线程向管道流中写入数据</div><div>        new Thread(new Runnable(){</div><div>            public void run(){</div><div>                writeData(outputStream);</div><div>            }</div><div>        }).start();</div><div>        new Thread(new Runnable(){</div><div>            public void run(){</div><div>                readData(inputStream);</div><div>            }</div><div>        }).start();</div><div>    }</div><div>    public static void writeData(PipedOutputStream out){</div><div>        try{</div><div>            //分别把0-100写入管道</div><div>            for(int i=0;i&lt;100;i++){</div><div>                String data=&quot;&quot;+i;</div><div>                out.write(data.getBytes());</div><div>            }</div><div>        out.close();//关闭管道流</div><div>        }catch(IOException e){</div><div>            e.printStackTrace();</div><div>        }</div><div>    }</div><div>    public static void readData(PipedInputStream in){</div><div>        byte[] bytes=new byte[1024];</div><div>        try{</div><div>        //从管道输入字节流中读取字节保存到字节数组中</div><div>        int len=in.read(bytes);//返回读到的字节数，没有读到任何数据返回-1</div><div>        while(len!=-1){</div><div>            //把byte数组中从0开始的len个字节转换为字符串打印</div><div>            System.out.println(new String(bytes,o,len));</div><div>            len=in.read(bytes);//继续从管道中读取数据</div><div>        }</div><div>        in.close();</div><div>    }catch(IOException e){</div><div>        e.printStackTrace();</div><div>    }</div><div>}</div><div><br/></div><div>}</div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div><div>4、2 join()</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">5、ThreadLocal的使用（线程特有对象）</span></div><div><span style="font-size: 14pt;"><a href="https://blog.csdn.net/fengcaho0616/article/details/79154697?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242" style="font-size: 14pt; font-weight: bold;">https://blog.csdn.net/fengcaho0616/article/details/79154697?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></span></div><div>    除了控制资源的访问，还可以通过增加资源来保证线程安全，ThreadLocal主要解决为每个线程绑定自己的值。</div><div>    threadLocal案例：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>在多线程环境下，把字符串转换为日期对象，多个线程使用同一个对象可能会产生线程安全问题</b></div><div><font face="Monaco"><b>为每个线程指定自己的SimpleDateFormat对象  ，使用ThreadLocal</b></font></div><div>public class{</div><div>    //定义一个SimpleDateFormat对象，该对象可以把字符串转化为日期    private static SimpleDateFormat sdf=new SimpDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</div><div><font color="#FF0000">static ThreadLocal&lt;SimpleDateFormat&gt; threadLoacl=new ThreadLocal&lt;&gt;();</font></div><div>    //定义Runnable接口的实现类</div><div>    static class ParseDate implement Runnable{</div><div>        private int i=0;</div><div>        public ParseDate(int i){</div><div>            this.i=i;</div><div>        }</div><div>        public void run(){</div><div>            try{</div><div>            String text=&quot;2068年11月22日 08:28&quot;+i%60;构建日期字符串</div><div>            //Date date=sdf.parse(text);</div><div>            //System.out.print(i+&quot;--&quot;+date);</div><div>            先判断当前线程是否有SimpledateFormate对象，如果当前线程没有SimpleDateFormat对象就创建一个，如果有就直接使用</div><div>            if(threadLocal.get()==null){</div><div>                threadLocal.set(new SimpDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;););</div><div>            }</div><div>            Date date=threadLocal.get().pase(text);</div><div>            }catch(ParseException e){</div><div>                e.printStackTrace(); </div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>}</div><div><br/></div></div><div><br/></div><div>threadLocal初始值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class{</div><div>    static ThreadLocal threadlocal=new ThreadLocal();</div><div>    //定义线程类</div><div>    static class SubThread extends Thread{</div><div>        public void run(){    </div><div>            for(int i=0;i&lt;10;i++){</div><div>                //第一次调用threadLocal的get方法会返回null</div><div>                System.out.print(&quot;---&quot;+Thread.currentThread().getName()+&quot;value&quot;+threadLocal.get());</div><div>                //如果没有初始值就设置当前日期</div><div>                if(threadLocal.get()==null){</div><div>                    threadLocal.set(new Date());</div><div>                }    </div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#FF0000" face="Monaco" style="font-size: 10pt;"><b>设置TheadLocal的初始值</b></font></div><div>public class{</div><div>  <b><font color="#FF0000">  //1、定义一个ThreadLocal的子类</font></b></div><div>    static class SubThreadLocal extends ThreadLocal&lt;Date&gt;{</div><div>    <font color="#FF0000"><b>//2、重写initialValue 方法，设置初始值</b></font></div><div><font color="#FF0000"><b>        有初始值后，第一次调用ThreadLocal就不会返回null了。</b></font></div><div>    protected Date initialValue(){</div><div>        return new Date()<b><font color="#FF0000">//把当前日期设置为初始值;</font></b>    </div><div>    }</div><div><br/></div><div>}</div><div>    static ThreadLocal threadlocal=new ThreadLocal();</div><div>    //定义线程类</div><div>    static class SubThread extends Thread{</div><div>        public void run(){    </div><div>            for(int i=0;i&lt;10;i++){</div><div>                //第一次调用threadLocal的get方法会返回null</div><div>                System.out.print(&quot;---&quot;+Thread.currentThread().getName()+&quot;value&quot;+threadLocal.get());</div><div>                //如果没有初始值就设置当前日期</div><div>                if(threadLocal.get()==null){</div><div>                    threadLocal.set(new Date());</div><div>                }    </div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">6、Lock显示锁</span></div><div>    在JDK5中增加了Local锁接口，有ReentrantLock实现类，ReentrantLocal锁称为可重入锁，它的功能比synchronized多。</div><div>    <span style="font-size: 11pt; font-weight: bold;">1、锁的可重入性</span></div><div>        锁的可重入是指，当一个线程获得一个对象锁之后，再次请求该对象锁是可以获得该对象的锁的。假设锁不可重入，可能会造成死锁（如synchronized实例方法之间的调用）。   Lock是一种可重入锁。</div><div>    <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">2、ReentranLock</span><span style="font-size: 11pt; font-weight: bold;"> 的基本使用</span></font></div><div><span style="font-weight: bold;">        2.1、调用lock（）获得锁，调用unlock（）释放锁；</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class{</div><div>    //定义显示锁</div><div>    static Lock lock=new ReentrantLocal();</div><div>    //定义方法</div><div>    public static void  sm(){</div><div>    //先获得锁</div><div>    lock.lock();</div><div>    //for循环就是同步代码块</div><div>    for(int i=0;i&lt;100;i++){</div><div>        System.out.print(Thread.currentThread().getName()+&quot;--&quot;+i);</div><div>    //释放锁</div><div>    Lock.unlock();</div><div>    }</div><div>     </div><div>    } </div><div>}</div></div><div><br/></div><div>      <span style="font-weight: bold;">  2.2、</span><span style="font-weight: bold;">使用Lock锁同步不同方法中的同步代码块</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">public class{</font></div><div><font face="Monaco">    static Lock lock=new  ReentrantLock();//定义一个锁对象</font></div><div><font face="Monaco">    public static void sm(){</font></div><div><font face="Monaco">        //经常在try代码块中获得Lock锁，经常在finally字句中释放锁</font></div><div><font face="Monaco">        try{</font></div><div><font face="Monaco">            lock.lock();//获得锁</font></div><div><font face="Monaco">            System.out.println(Thread.cuuentThread().getName()+&quot;method1&quot;+System.currentTimeMillis());</font></div><div><font face="Monaco">        }catch(){</font></div><div><font face="Monaco">        }finally{    </font></div><div><font face="Monaco">            lock.unlock();//释放锁</font></div><div><font face="Monaco">        }</font></div><div><font face="Monaco">    }</font></div><div><font face="Monaco"><br/></font></div><div>  public static void sm2(){</div><div>        //经常在try代码块中获得Lock锁，经常在finally字句中释放锁</div><div>        try{</div><div>            lock.lock();//获得锁</div><div>            System.out.println(Thread.cuuentThread().getName()+&quot;method1&quot;+System.currentTimeMillis());</div><div>        }catch(){</div><div>        }finally{    </div><div>            lock.unlock();//释放锁</div><div>        }</div><div>    }</div><div><br/></div><div>       <font color="#FF0000"><b> </b><b>sm方法和sm2方法可以实现同步</b></font></div><div><font color="#FF0000" face="Monaco"><b>}</b></font></div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">    2.3、ReentranLock锁的可重入性</span></div><div>       <span style="color: rgb(255, 0, 0);"> </span><span style="color: rgb(255, 0, 0);">注意：获得几次锁，就得释放几次锁。</span></div><div><br/></div><div><span style="font-weight: bold;">    2.4、lockInterruptibly()方法</span></div><div><span style="font-weight: bold;">        </span><span style="font-weight: bold;">lockInterruptibly()方法的作用：如果当前线程未被中断则获得锁，如果当前线程被中断则出现异常。</span></div><div>        </div><div>        lock.lock();//获得锁定之后，即使调用线程的interrupt()方法，也没有真正的中断线程</div><div>        lock.lockInterruptibly();//如果 线程被中断了，不会获得锁，会产生异常。</div><div>    </div><div>    对于synchronized内部锁来说，如果一个线程在等待锁，只有两个结果：要么该线程获得锁继续执行，要么就保持等待。</div><div>    对于ReentrantLock可重入锁来说，提供另外一种可能，在等待锁的过程中，程序可以根据需要取消对锁的请求。</div><div>            <span style="font-weight: bold;">2.4.1、</span><span style="font-weight: bold;">lockInterruptibly()方法为死锁问题的处理提供了一种解决方案。（外部中断）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>假设程序检测出线程之间可能出现死锁，或者已经出现死锁</div><div><br/></div><div><font face="Monaco">使用</font>lockInterruptibly()方法获得锁：在监测线程中如果发现死锁</div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">中断任何一个线程，解决死锁</font></div><div>if(thread2.isAlive()){</div><div>    thread.interrupt();</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div>        <span style="font-size: 11pt; font-weight: bold;">2.5、tryLock(</span><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">long time,TimeUnit unit</span></span><span style="font-size: 11pt; font-weight: bold;">)方法（限时等待）</span></div><div>    tyrLock(long time,TimeUnit unit)：获得锁返回true</div><div>        作用：在跟定等待时长内锁没有被另外的线程持有，并且当前线程也没有被中断，则获得该锁。通过该方法可以实现锁对象的限时等待。</div><div>        <span style="font-weight: bold;">2.6、tryLock()方法</span> </div><div>                仅在调用时锁定未被其他线程持有的锁，如果调用方法时，锁对象被其他线程持有则放弃。调用方法尝试获得锁，如果该锁没有被其他线程占用则返回true，表示锁定成功；如果锁被其他线程占用，则返回false，不等待。</div><div>        <span style="color: rgb(255, 0, 0); font-weight: bold;">通过trylock()方法可以避免死锁。</span></div><div>    运行后，使用tryLock()尝试获得锁，不会傻傻的等待，通过循环不断的再次尝试，<span style="font-weight: bold;">如果等待的时间足够长</span>，<span style="font-weight: bold;">线程总是会获得想要的资源。</span></div><div>        <span style="font-weight: bold;">2.7、</span><span style="font-weight: bold;">newCondition()方法</span></div><div>            关键字synchronized与wait（）/notify（）这两个方法一起使用可以实现等待/通知模式。<span style="font-size: unset; color: unset; font-family: unset;">  Lock锁的newContition（）方法返回Condition对象，Condition类也可以实现等待/通知模式<span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">。</span></span></div><div>            使用notify 通知时，JVM会随机唤醒某个等待的线程，<span style="font-weight: bold;">使用Condition类可以实现选择性通知。</span></div><div>            Condition类比较常用的两个方法：</div><div>                await（）会使当前线程等待，同时会释放锁，当其他线程调用signal（）时，线程会重新获得锁并继续执行。</div><div>                signal（）用于唤醒一个等待的线程。</div><div>            <span style="font-weight: bold;">注意：</span>在调用Condition的await（）/signal（）方法前，也需要线程持有相关的Lock锁，调用await（）会释放这个锁，在singal（）调用后会从当前Condition对象的等待队列中，唤醒一个线程，唤醒的线程会尝试获得锁，一旦获得锁成功就继续执行。</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Condition实现两个线程交替打印</div><div><br/></div><div><br/></div><div><br/></div></div><div>    signalAll（）唤醒所有等待线程。（解决假死）</div><div>        <span style="font-weight: bold;">2.8 公平锁与非公平锁</span></div><div>                在大多数情况下，锁的申请都是非公平的，如果线程1与线程2都在请求锁A，当锁A可用时，系统只是会从阻塞队列中随机的选择一个线程，不能保证其公平性。</div><div>                公平的锁会按照时间先后顺序，保证先到先得，公平锁的这一特点不会让线程饥饿。</div><div>                synchronized内部锁就是非公平的，ReentrantLock重入锁提供了一个构造方法：ReentrantLock(boolean fair)，当在创建锁对象时实参传递true可以把该锁设置为公平锁。</div><div>    </div><div>        运行程序：</div><div>            1、如果是非公平锁，系统倾向于让一个线程再次获得已经持有的锁；这种分配策略是高效的，但是是非公平的。</div><div>            2、如果是公平锁，多个线程不会发生同一个线程连续多次获得锁的可能；保证了公平性。公平锁的实现需要系统维护一个有序的队列，公平锁的实现成本相对较高，性能也较低。因此默认情况下锁是非公平的。</div><div>        <span style="font-weight: bold;">2.9、几个常用的方法</span></div><div>            1、int getHoldCount() 返回当前线程调用lock()方法的次数。</div><div>            2、int getQueueLength() 返回正在等待获得锁的线程预估数。</div><div>           3、int getWaitQueueLength(Condition condition) 返回与Condition条件相关的等待的线程预估数 </div><div>            4、boolean hasQueuedThread(Thread thread ) 查询参数指定的线程是否在等待获得锁</div><div>            5、boolean hasQueuedThreads() 查询是否还有线程在等待获得该锁</div><div>            6、boolean hasWaiters(Condition condition)查询是否有线程正在等待指定的Condition条件</div><div>            7、boolean isFair 判断是否为公平锁</div><div>            8、boolean isHeldByCurrentThread() 判断当前线程是否持有该锁</div><div>            9、boolean isLocked() 查询当前锁是否被线程持有</div><div>        </div><div><b style="font-size: unset;"><span style="font-size: 12pt; font-weight: bold; color: unset; font-family: unset;">  3、ReentrantReadWriteLock 读写锁</span></b></div><div><br/></div><div>    synchronized内部锁与ReentrantLock锁都是独占锁（排他锁），同一时间只允许一个线程执行同步代码块，可以保证线程的安全性，但是执行效率低。</div><div>    <span style="font-weight: bold;">ReentrantReadWriterLock读写锁是一种改进的排它锁，也可以称作共享排他锁，允许多个线程同时读取共享数据，但是一次只允许一个线程对共享数据进行更新。</span></div><div>    读写锁通过读锁与写锁来完成读写操作，线程在读取共享数据前必须先持有读锁，该读锁可以同时被多个线程持有，即它是共享的。写锁是排他的，线程在更新共享数据前必须先持有写锁。一个线程持有写锁时其他线程无法获得相应的锁（包括 读锁和写锁）。</div><div>    读锁只是在读线程之间共享，任何一个线程持有读锁时，其他线程都无法获得写锁。</div><div>    <span style="font-weight: bold;">即，读写锁允许读读共享，读写互斥，写写互斥。</span></div><div><br/></div><div>        在java.util.concurrent.locks包中定义了ReadWriteLock接口，该接口中定义了readLock（）返回读锁，定义writeLock（）方法返回写锁，该接口的实现类是ReentrantReadWriteLock。</div><div><span style="font-weight: bold;">    注意：</span></div><div>            readLock（）与writeLock方法返回的锁对象是同一个锁的两个不同的角色，不是分别获得两个不同的锁。ReadWriteLock接口的实例可以充当两个角色。</div><div>        读写锁的基本使用方法：</div><div>            1、定义读写锁</div><div>        ReadWriteLock rwLock=new ReentrantReadWriteLock();</div><div>            2、获得读锁</div><div>        Lcok readLock=rwLock.readLock();</div><div>            3、获得写锁</div><div>        Lock writeLock=rwLock.writeLock();</div><div>            4、读数据</div><div>        readLock.lock();//申请读锁</div><div>            try{</div><div>                读取共享数据；</div><div>            }finally{</div><div>                readLock.unlock();总是在finally字句中释放锁</div><div>            }</div><div>            5、写数据</div><div>            writeLock.lock();// 申请写锁</div><div>            try{</div><div>                更新共享数据；</div><div>            }finally{</div><div>               writeLock.unlock();总是在finally字句中释放锁</div><div>            }</div><div>3、1 读读共享</div><div>3、2 写写互斥</div><div>3、3 读写互斥</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">6、线程管理</span></div><div>    <span style="font-size: 12pt; font-weight: bold;">6.1、线程组</span></div><div>        类似于在计算机中使用文件夹管理文件，也可以使用线程组来管理线程，在线程组中定义一组相似（相关）的线程，在线程组中可也以定义子线程组。</div><div>        Thread类有几个构造方法允许在创建线程时指定线程组，如果在创建线程时没有指定线程组则该线程就属于父线程所在的线程组。JVM在创建main线程时会为它指定一个线程组，因此每个java线程都有一个线程组与之关联，可以调用线程的getThreadGroup（）方法返回线程组。</div><div>        线程组开始是处于安全的考虑设计用来区分不同的Applet，然而ThreadGroup并未实现这一目标，在新开发的系统中，已经不常用线程组，现在一般会将一组相关的线程存入一个数组或一个集合中，如果仅仅是用来区分线程时，可以使用线程名称来 区分。因此，在多数情况下可以忽略线程组。</div><div><br/></div><div>    6.1.1、创建线程组</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><font face="Monaco">java.lang.ThreadGroup</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">构造方法</font></div><div><font face="Monaco">ThreadGroup t=new ThreadGroup(&quot;线程组的名称&quot;);</font></div><div><font face="Monaco">ThreadGroup t1=new ThreadGroup(父线程组，“线程租的名称”)</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//在创建线程组时，如果不指定所属线程组，则自动归属到当前所属的线程组中</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//创建线程时，可以指定线程的所属线程组</span></div><div><font face="Monaco">Thread t1=new Thread(group,r,&quot;t1&quot;);</font></div></div><div><img src="线程同步机制_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 11pt; font-weight: bold;">6.1.2、线程组的基本操作</span></div><div>    activeCount() 返回当前线程组及子线程组中活动线程的数量（近似值）</div><div>    activeGroupCount() 返回当前线程组及子线程组中活动线程组的数量（近似值）</div><div>    int enumerate(Thread[] list) 将当前线程组和子线程组中的活动线程复制到 参数数组中</div><div>    enumerate(ThreadGroup[] list) 将当前线程组中的活动线程组和子线程组复制到参数数组中</div><div>    getMaxPriority() 返回线程组的最大优先级，默认是10</div><div>    getName() 返回线程组的名称</div><div>    getParent() 返回父线程组</div><div>    interrupt() 中断线程组中的所有线程</div><div>    isDaemon()判断当前线程组是否为守护线程组</div><div>    list() 将当前线程组中的活动线程打印出来</div><div>    parentOf(ThreadGroup g) 判断当前线程是否为参数线程组的父线程组</div><div>    setDaemon(boolean daemon) 设置线程组为守护线程组</div><div><span style="font-size: 11pt; font-weight: bold;">6.1.3 复制线程组中的线程及子线程组</span></div><div>    int enumerate(Thread[] list) 将当前线程组和子线程组中的活动线程复制到 参数数组中</div><div>   int enumerate(Thread[] list,boolean recursive) 将当前线程组中的活动线程复制到 参数数组中，如果第二个参数设置为false，则只复制当前线程组中的所有的线程，不复制子线程组中的线程。</div><div>    enumerate(ThreadGroup[] list) 将当前线程组和子线程组中的活动线程组复制到参数数组中</div><div>     enumerate(ThreadGroup[] list，boolean recursive) 将当前线程组和子线程组中的活动线程组复制到参数数组中，如果第二个参数为false，则只复制当前线程组的子线程组</div><div><span style="font-size: 11pt; font-weight: bold;">6.1.4 线程组的批量中断</span></div><div>    线程组的interrupt（）可以给该线程组中所有的活动线程添加中断标志。</div><div><span style="font-size: 11pt; font-weight: bold;">6.1.5 设置守护线程组</span></div><div>    守护线程是为其他线程提供服务的，当JVM只有守护线程时，守护线程会自动销毁，JVM会自动退出。</div><div>    调用线程组的 setDaemon(true) 可以把线程组设置为守护线程组，当守护线程组中没有任何活动线程时，守护线程组会自动销毁。</div><div>    注意：线程组的守护属性，不影响线程组中线程的守护属性，或者说守护线程组中的线程可以是非守护线程。</div><div><span style="font-size: 12pt; font-weight: bold;">6.2 、捕获线程的执行异常</span></div><div>        在线程的run方法中，如果有受检异常必须捕获处理，如果想要获得run()方法中出现的运行时异常信息，可以通过回调 UncaughExceptionHandler接口获得哪个线程出现了运行时异常，在Thread类中有关处理运行时异常的方法有：</div><div>        getDefaultUncaughtExceptionHandler()获得全局的（默认的）UncaughtExceptionHandler</div><div>        getUncaughtExceptionHandler（）获得当前线程的UncaughtExceptionHandler</div><div>        setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler u)设置全局的（默认的）UncaughtExceptionHandler</div><div>        setUncaughtExceptionHandler（UncaughtExceptionHandler u）设置当前线程的UncaughtExceptionHandler</div><div>        当线程运行过程出现异常，JVM会调用Thread类的dispathUncaughtException(Throwable  e)方法，该方法会调用</div><div>getUncaughtExceptionHandler().uncaughtException(this,e);如果想要出现线程中出现异常的信息，就需要设置线程的</div><div>UncaughtExceptionHandler</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>psvm(){</div><div>    //设置线程全局的回调接口</div><div>    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){</div><div>    public void uncaughtException(Thread t,Throwable e){</div><div>        //t参数接收发生异常的线程，e就是该线程的异常</div><div>        System.out.println(t.getName()+&quot;线程产生了异常：&quot;+e.getMessage());</div><div>}</div><div>});</div><div>}    </div></div><div>    实际开发中，这种异常处理的方式还是比较常见的，尤其是异常执行的方法，如果线程产生了异常，JVM会调用dispatchUncaughtExcaption()方法，在该方法中调用了getUncaughtExceptionHandler().uncaughtException(this,e);如果在当前线程设置了UncaughtExceptionHandler回调接口就直接调用它自己的uncaughtException()方法，如果没有设置则调用当前线程所在线程组UncaughtExceptionHandler回调接口的uncaughtException方法，如果线程组也没有设置，则直接把异常的栈信息定向到System.err中。</div><div>    <span style="font-size: 12pt; font-weight: bold;">6.3 注入Hook钩子线程</span></div><div>        现在很多软件包括Mysql，Zookeeper， kafka等都存在Hook线程的校验机制，目的是校验进程是否已经启动，防止重复启动程序。</div><div>        Hook线程也称为钩子线程，当JVM退出的时候会执行Hook线程，经常在程序启动的时候创建一个.lock文件，用lock文件校验程序是否启动，在程序退出（JVM退出）时删除该.lock文件，在Hook线程中除了防止重新启动进程外，还可以做资源释放，尽量避免在Hook线程中进行复杂的操作。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>psvm{</div><div>    1&gt;注入Hook线程，在程序退出时删除.lock文件</div><div>    Runtime.getRuntime().addShutdownHook(new Thread(){</div><div>        public void run(){</div><div>            System.out.println(&quot;JVM退出，会启动当前Hook下线程，在Hook线程中删除.lock文件&quot;);</div><div>            getLockFile().toFile().delete();</div><div>        }</div><div>});</div><div>    2&gt;程序运行时，检查lock文件是否存在，如果lock文件存在，则抛出异常</div><div>    if(getLockFile().toFile().exists()){</div><div>        throw new RuntimeException(&quot;程序已启动&quot;);</div><div>        else{</div><div>            //文件不存在，说明程序是第一次启动，创建lock文件</div><div>            getLockFile().toFile().createNewFile();</div><div>        } </div><div>    }</div><div>    </div><div>}</div><div>private static Path getLockFile(){</div><div>    return Paths.get(&quot;&quot;,&quot;tmp.lock&quot;);</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">    6.4、线程池</span></div><div>   <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">6.4.1 什么是线程池？</span></font></div><div>              可以以  new Thread(()-&gt;{线程执行的任务}).start();这种形式开启一个线程，当run()方法结束后，线程对象会被垃圾回收器释放。</div><div>                在真实的生产环境中，可能需要很多个线程来支撑整个应用，当线程数量非常多时， 反而会耗尽CPU资源，如果不对线程进行控制与管理，反而会影响程序的性能。</div><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">线程的开销主要包括：</span></div><div>        创建于启动线程的开销；线程销毁的开销； 线程调度的开销；线程数量受限于CPU处理器的数量。</div><div>        线程池就是有效使用线程的一种常用方式，线程池内部可以预先创建一定数量的工作线程，客户端 代码直接将任务作为一个对象提交给线程池，线程池将这些任务缓存在工作队列中，线程池中的工作线程不断地从队列中取出任务并执行。</div><div><img src="线程同步机制_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.2、JDK对线程池的支持</span></div><div>JDK提供了一套Executor框架，可以帮助开发人员有效的使用线程池，</div><div><img src="线程同步机制_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div>6.4.3、线程池的基本使用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class{</div><div>    psvm(){</div><div>        //创建有5个线程大小的线程池</div><div>        ExecutorService fixedThreadPool=Executors.newFixedThreadPool(5);</div><div>        //向线程池中提交18个任务</div><div>        for(int i=0;i&lt;18;i++){</div><div>            fixedThreadPool.execute(new Runnable(){</div><div>                public void run(){    </div><div>                    System.out.print(Thread.currentThread().getId()+&quot;编号的线程在执行，开始时间&quot;+System.currentTimeMillis());</div><div>                Thread.sleep(3000);//睡眠3秒，模拟任务执行时长</div><div>                }</div><div>        </div><div>            });</div><div>        }</div><div>    }</div><div><br/></div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.4、线程池的计划任务</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class{</div><div>    psvm(){</div><div>        //创建一个有调度功能的线程池</div><div>        ExecutorService fixedThreadPool=Executor.newFixedThreadPool(10);</div><div><br/></div><div><br/></div><div><br/></div><div>        //在延迟2秒后执行任务，schedule(Runnable任务，延迟时长，时间单位);</div><div>        scheduledExecutorService.schedule(new Runnable(){        public void run(){</div><div>                System.out.println(Thread.currentThread().getId()+&quot;---&quot;+System.currentTimeMillis());</div><div>},2,TimeUnit.SECONDS);</div><div><br/></div><div><br/></div><div>        //以固定的频率执行任务，开启任务的时间是固定的,在3秒后执行任务，以后每隔5秒重新执行一次，如果任务执行时长超过了时间间隔，则任务完成后立即开启下一个任务。</div><div>        scheduledExecutorService.scheduleAtFixedRate(new Runnable(){</div><div>        public void  run(){</div><div>        }</div><div>}</div><div>,3,5,TimeUnit.SECONDS);</div><div><br/></div><div><br/></div><div> //在上次任务结束后，在固定延迟后再次执行该任务，不管执行任务耗时多长，总是在任务结束后的2秒再次开启新的任务       scheduledExecutorService.scheduleWithFixedDelay(new Runnable(){</div><div>        public void  run(){</div><div>        }</div><div>}</div><div>,3,5,TimeUnit.SECONDS);</div><div>        }</div><div>    }</div><div><br/></div><div>}</div><div><br/></div></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.5、核心线程池的底层实现</span></div><div>        查看Executors工具类中 newCachedThreadPool(),newSingleThreadExcecutor(),newFixedThreadPool()源码。</div><div>    newCachedThreadPool()： <img src="线程同步机制_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>    newSingleThreadExcecutor()：</div><div><img src="线程同步机制_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>核心线程数等于最大线程数，如果指定线程数为10，那么最大线程数和核心线程数都为10，第11个任务来的时候会放入无界阻塞队列。</div><div>    newFixedThreadPool()：</div><div><img src="线程同步机制_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>核心线程数和最大线程数都是1，在任意时刻，只有一个线程在执行一个任务，如果有多个任务，会放入阻塞队列。</div><div><br/></div><div>        Excutors工具类中返回线程池的方法底层都使用了ThreadPoolExecutor线程池，这些方法都是ThreadPoolExecutor线程池的封装。</div><div><br/></div><div>        ThreadPoolExecutor的构造方法：</div><div>            public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime，TimeUnit unit，BlockingQueue&lt;Runable&gt;workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler<span style="font-size: unset; color: unset; font-family: unset;">)</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        各个参数的含义：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            corePoolSize,指定线程池中核心线程的数量</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            maxinumPoolSize，指定线程池中最大线程数量</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            KeepAliveTime，当线程池线程的数量超过corePoolSize时，多余的空闲线程的存活时长，即空闲线程在多长时长内销毁</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            unit，是keepAliveTime时长单位</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            workQueue，任务队列，把任务提交到该任务队列中等待执行</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            threadFactory，线程工厂，用于创建线程</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            handler 拒绝策略，当任务太多来不及处理时如何拒绝</span></div><div><br/></div><div><span style="font-size: unset; color: unset; font-family: unset;">        说明：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">            workQueue工作队列 是指提交未执行的任务队列，它是BlockingQueue接口的对象，仅用于存储Runnable任务，根据队列功能分类，<span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">在ThreadPoolExecutor构造方法中可以使用以下几种阻塞队列：</span></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">           </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">1、直接提交队列</span><span style="font-size: unset; color: unset; font-family: unset;">，由SynchronousQueue对象提供，该队列没有容量，提交给线程池的任务不会被真实的保存，总是将新的任务提交给线程执行，没有线程则尝试创建新的线程，如果线程数量已经达到maxinumPoolSize规定的最大值则执行拒绝策略。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">           </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">2、有界任务队列，</span><span style="font-size: unset; color: unset; font-family: unset;">由ArrayBlockingQueue实现，在使用ArrayBlockingQueue对象时，可以指定一个容量，当有任务需要执行时，如果线程池中线程数小于corePoolSize核心线程数  则创建新的线程，如果大于corePoolSize核心线程数则加入等待 队列。如果队列已满则无法加入，在线程数小于maxinumPoolSize指定的最大线程数前提下会创建新的线程来执行，如果线程数大于maxinumPoolSize最大线程数则执行拒绝策略。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">           </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">3、无界任务队列，</span><span style="font-size: unset; color: unset; font-family: unset;">由LinkedBlockingQueue对象实现，与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务失败入队的情况。当有新的任务时，在系统线程数小于corePoolSize核心线程数则创建新的线程来执行任务，当线程池中线程大于核心线程数 则把任务加入阻塞队列。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">           </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">4、优先任务队列，</span><span style="font-size: unset; color: unset; font-family: unset;">由priorityBlockingQueue实现的，是带有任务优先级的队列，是一个特殊的无界队列。不管是</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">ArrayBlockingQueue，还是</span><span style="font-size: unset; color: unset; font-family: unset;">LinkedBlockingQueue队列，都是按照先进先出算法处理任务的，在PriorityBlockingQueue队列中可以按照任务优先级顺序先后执行。</span></div><div><img src="线程同步机制_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.6、拒绝策略</span></div><div>    ThreadPoolExecutor构造方法的最后一个参数指定了拒绝策略，当提交给线程池的任务量超过实际承载能力时，如何处理？</div><div>    即线程池中的线程已经用完了，等待队列也满了，无法为新提交的任务服务，可以通过拒绝策略来处理这个问题。</div><div>    <span style="font-weight: bold;">JDK提供了四种拒绝策略：</span></div><div>        AbortPolicy策略，会抛出异常。</div><div>        CallerRunsPolicy策略，只要线程池没有关闭，会在调用者线程中运行当前被丢弃的任务。</div><div>        DiscardOldestPolicy策略，将任务队列中最老的任务丢弃，尝试再次提交新任务。</div><div>        DiscardPolicy直接丢弃这个无法处理的任务。</div><div> <span style="font-size: 11pt; font-weight: bold;">   Exectors工具类提供的静态方法返回的线程池默认的拒绝策略是抛出异常，如果内置的拒绝策略无法满足需求，RejectedExecutionHandler接口</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>自定义拒绝策略</div><div>class{</div><div>    psvm(){</div><div>        //创建任务</div><div>        Runnable r=new Runnable(){</div><div>            public void run(){</div><div>            }</div><div>        }</div><div>        //创建线程池，使用自定义拒绝策略</div><div>        ThreadPoolExector threadPoolExector= new threadPoolExecutor(5,5,0,TimeUnit.SECONDS,newLinkedBlockingQueue&lt;&gt;(10),Exectors.defaultThreadFactory(),new RejectedExecutionHandler(){</div><div>    public void rejectedExecution(Runnable r,ThreadPoolExecutor executor){</div><div>        //r就是请求的任务，executor就是当前线程池</div><div>        System.out.println(r+&quot;is discarding...&quot;);</div><div>    }</div><div>});</div><div>    </div><div>    }</div><div><br/></div><div><br/></div><div>}</div></div><div><span style="font-weight: bold;">6.4.7 ThreadFactory</span></div><div><span style="font-weight: bold;">        线程池中的线程从哪来的？答案就是</span><span style="font-weight: bold;">ThreadFactory</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">ThreadFactory是一个接口，只有一个用来创建线程的方法 ：</span></div><div><span style="font-weight: bold;">        Thread newThread(Runnable r);</span></div><div><span style="font-weight: bold;">    当线程池中需要创建线程时就会调用该方法。可以使用默认的线程工厂，也可以自定义线程工厂。</span></div><div><span style="font-weight: bold;">    </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class{</div><div>    psvm(){</div><div>         //创建任务</div><div>        Runnable r=new Runnable(){</div><div>            public void run(){</div><div>            }</div><div>        }</div><div>        //创建线程池,使用自定义线程工厂</div><div>        ThreadPoolExector threadPoolExector= new threadPoolExecutor(5,5,0,TimeUnit.SECONDS,newLinkedBlockingQueue&lt;&gt;(10),new ThreadFactory(){</div><div>    public Thread newThread(Runnable r){</div><div>        //根据参数r接收的任务，创建一个线程</div><div>        Thread t=new Thread(r);</div><div>        return t;</div><div>    }</div><div>},</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><b style="background-color: transparent; color: unset; font-family: unset; font-size: unset;">);</b></div><div>    }</div><div>}</div></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.8 监控线程池</span></div><div><span style="font-weight: bold;">    ThreadPoolExecutor提供了一组方法用于监控线程池</span></div><div><span style="font-weight: bold;">    int getActiveCount() 获得线程池中当前线程的数量</span></div><div><span style="font-weight: bold;">    long getCompletedTaskCount()返回线程池完成任务的数量</span></div><div><span style="font-weight: bold;">    int getCorePoolSize()返回线程池中核心线程的数量</span></div><div><span style="font-weight: bold;">    int getLargestPoolSize()返回线程池曾经达到的最大数</span></div><div><span style="font-weight: bold;">    int getMaximumPoolSize()返回线程池的最大容量</span></div><div><span style="font-weight: bold;">    int getPoolSize()当前线程池的大小</span></div><div><span style="font-weight: bold;">    BlockingQueue&lt;Runnable&gt;getQueue()返回线程池的阻塞队列</span></div><div><span style="font-weight: bold;">    long getTastCount()返回线程池收到的任务总数</span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.9 扩展线程池</span></div><div><span style="font-weight: bold;">    有时候需要对线程池进行扩展，如在监控每个任务的开始和结束时间，或者自定义一些其他增强的功能，</span></div><div><span style="font-weight: bold;">    ThreadpoolExecutor线程池提供了两个方法：</span></div><div><span style="font-weight: bold;">        1、protected void afterExecute(Runnable r,Throwable t)</span></div><div><span style="font-weight: bold;">        2、protected void beforeExecute(Thread t,Runnable r    )</span></div><div><span style="font-weight: bold;">    在线程池执行某个任务前会调用beforeExecute()方法，在任务结束后（或者是任务异常退出）会执行afterExecute()方法</span></div><div><span style="font-weight: bold;">    查看ThreadPoolExecutor线程池中的工作线程就是Worker类的实例，worker实例在执行时也会调用beforeExecute（）与afterExecute（）方法</span></div><div><br/></div><div><span style="font-weight: bold;">扩展线程池</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>class{</b></div><div><b>    //定义任务类</b></div><div><b>    private static class MyTask implements Runnable{</b></div><div><b>        private String name;</b></div><div><b>        public MyTask(String name){</b></div><div><b>            this.name=name;</b></div><div><b>        }</b></div><div><b>        public void run(){</b></div><div><b>             </b></div><div><b>        }</b></div><div><b>    }</b></div><div><b>    psvm(){</b></div><div><b>        //定义扩展线程池，可以定义线程池类继承ThreadPoolExecutor，在子类中重写beforeExecute()/afterExecute()方法</b></div><div><b>        //也可以直接使用ThreadPoolExector的内部类</b></div><div><b>        ExecutorService executorService=new ThreadPoolExecutor(5,5,0,TimeUnit.SECONDS,new LinkedBlockingQueue&lt;&gt;(),){</b></div><div><b>        //在内部类中重写任务开始方法</b></div><div><b>        protected void beforeExecute(Thread t,Runnable r){</b></div><div><b>        《》</b></div><div><b>        }</b></div><div><b>        protected void afterExecute(Runnable r,Throwable t){</b></div><div><b>        《》</b></div><div><b>        }</b></div><div><b>    };</b></div><div><b>    }</b></div><div><b>    //向线程池中添加任务</b></div><div><b>    </b></div><div><b>    //关闭线程池</b></div><div><b>    executorService.shutdown();//关闭线程池仅仅是说线程池不再接收新的任务，线程池中已接收的任务正常执行完毕。</b></div><div><b><br/></b></div><div><b>}</b></div><div><b><br/></b></div><div><b><br/></b></div></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.10、优化线程数量</span></div><div><span style="font-weight: bold;">      </span>  线程池大小对系统性能是有一定影响的，过大或者过小都会无法发挥最优的系统性能，线程池大小不需要做的非常精确，只要避免极大或者极小的情况即可，一般来说，线程池大小需要考虑CPU数量，内存大小等因素，在&lt;Java Concurrency in Practice&gt;书中给出一个估算线程池大小的公式：</div><div><span style="font-weight: bold;">        线程池大小等于=cpu的数量*目标cpu的使用率*（1+等待时间与计算时间的比）</span></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.11、线程池死锁</span></div><div><span style="font-weight: bold;">   </span> 如果在线程池中执行的 任务A在执行过程中又向线程池提交了任务B，任务B添加到了线程池的等待队列中，如果任务A结束需要等待任务B的执行结果，就有可能：线程池中所有的工作线程都处于等待任务处理结果，而这些任务在阻塞队列中等待执行，线程池中没有可以对阻塞队列中的任务进行处理的线程，这种等待会一直持续下去，从而造成死锁。</div><div><span style="font-weight: bold;">    合适给线程池提交相互独立的任务，而不是彼此依赖的任务，对于彼此依赖的任务，可以考虑分别提交给不同的线程池来执行。</span></div><div><br/></div><div><span style="font-weight: bold;">6.4.12、线程池中的异常处理</span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-weight: bold;">    演示线程池可能会“吃掉程序中的异常”</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">案例：定义五个任务交给线程处理，其中一个任务存在除0操作</font></div><div>运行程序，只有四条结果，线程池把改算数异常吃掉了。</div><div>    解决办法：</div><div>        <b>1、把submit()提交方法改为execute();</b></div><div><b>        2、对线程池进行扩展，对submit()方法进行包装</b></div></div><div><br/></div><div><span style="font-weight: bold;">自定义线程池类，对ThreadPoolExecutor进行扩展</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class TraceThreadPoolExecutor extends ThreadPoolExecutor{</div><div>    public TraceThreadPollExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt;workQueue){</div><div>    super(corePoolSize,maximumPoolSize,KeepAliveTime,unit,workQueue)</div><div>}</div><div>    //定义方法，对执行的任务进行包装，接收两个参数，第一个参数接收要执行的任务，第二个参数是一个Exception异常</div><div>    public Runnable wrap(Runnable task,Exception exception){</div><div>        return new Runnable(){</div><div>            public  void  run(){</div><div>                 try{</div><div>                    task.run();</div><div>                    }catch(Exception e){</div><div>                        exception.printStackTrace();</div><div>                        throw e; </div><div>                    }</div><div>            }</div><div>        };</div><div>    }</div><div>    //重写submit方法</div><div>    public Future&lt;?&gt;submit(Runnable task){</div><div>        return super.submit(wrap(task,new Exception(&quot;客户跟踪异常&quot;)));</div><div>    }</div><div>    public void execute(Runnable command){</div><div>        super.execute(wrap(command,new Exception(&quot;客户跟踪异常&quot;)))</div><div>    }</div><div><br/></div><div>}</div><div><br/></div></div><div><span style="font-size: 12pt; font-weight: bold;">6.4.13、ForkJoinPool线程池</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;">        “分而治之”，是一个有效处理大数据的方法，MapReduce就是采用这种分而治之的思想。简单点说，如果要处理1000个数据，但是我们不具备处理1000个数据的能力，可以只处理10个数据，可以把这1000个数据分阶段处理100次，每次处理10个，把100次处理结果进行合成，形成1000个数据的处理结果。</span></div><div><span style="font-weight: bold;">        把一个大任务调用fork()方法分解为若干个小任务，把小任务的处理结果进行join（）合并为大任务的结果。</span></div><div><span style="font-weight: bold;"><img src="线程同步机制_files/Image [13].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">        系统对ForkJoinPool线程池进行了优化，提交的任务数量与线程的数量不一定是一对一的关系，在多数情况下，一个物理线程实际上需要处理多个逻辑任务。</span></div><div><span style="font-weight: bold;"><img src="线程同步机制_files/Image [14].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">ForkJoinPool线程池中最常用的方法是：</span></div><div><span style="font-weight: bold;">        &lt;T&gt;ForkJoinTask&lt;T&gt;submit(ForkJoinTask&lt;T&gt;task) 向线程池提交一个ForkJoinTask任务，ForkJoinTask任务支持fork（）分解与join等待的任务。</span></div><div><span style="font-weight: bold;">        ForkJoinTask 有两个重要的子类：RecursiveAction和RecursiveTask，它们的区别在于RecursiveAction任务没有返回值，Recursive任务可以带有返回值。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>演示ForkJoinPool线程池</div><div>使用该线程池模拟数列求和</div><div>class{</div><div>    private static  class CountTask extends RecursiveTask&lt;long&gt;{</div><div>    Private static final int THRESHOLD=10000;//定义数据规模的阈值，允许计算10000个数内的和，超过这个阈值就需要分解</div><div>    private long static;//计算数列的起始值</div><div>    private long end;//计算数列的结束值</div><div>    public CountTask(long static,long end){</div><div>        this.static =static;</div><div>        this.end=end;</div><div>    }</div><div>    //重写RecursiveTask类的computer()方法，计算数列的结果</div><div>    protected Long computer(){</div><div>        long sum=0;//保存计算的结果</div><div>        //判断任务是否需要继续分解，如果当前数列end与static范围的数超过阈值THRESHOLD，就需要继续分解</div><div>        if(end-static&lt;THRESHOLD){</div><div>            //小于阈值可以直接计算        </div><div>            for(long i=static ;i&lt;=end;i++){</div><div>                sum+=i;</div><div>            }else{</div><div>                //数列范围超过阈值，需要继续分解</div><div>                //约定每次分解为100个小任务，计算每个任务的计算量</div><div>                long step=(static+end)/100;</div><div>                //static =0，end=200000,step=2000,如果计算【0，200000】范围内数列的和，把该范围的数列分解为100个小任务，每次任务计算2000个数即可</div><div>                //注意，如果任务划分的层次很深，即THRESHOLD阈值太小，每个任务的计算量很小，层次划分就会很深，可能会出现两种情况，一是系统内的线程数量会越积越多，导致性能下降严重；二是分解次数过多，方法调用过多，可能会导致栈溢出</div><div>                //创建一个存储任务的集合</div><div>                ArrayLsit&lt;CountTask&gt; subTaskList=new ArrayList&lt;&gt;();</div><div>                long pos=start;//每个任务的起始位置</div><div>                for(int i=0;i&lt;100;i++){</div><div>                    long lastOne=pos+step;//每个任务的结束位置</div><div>                    //调整最后一个任务的结束位置</div><div>                    if(lastOne&gt;end){</div><div>                        lastOne=end;</div><div>                    }</div><div>                    //创建一个子任务</div><div>                    CountTask task=CountTask(pos,lastOne);</div><div>                    //把任务添加到集合中</div><div>                    subTaskList.add(task);</div><div>                    //调用fork()提交子任务</div><div>                    task.fork();</div><div>                    //调整下个任务的起始位置</div><div>                    pos+=step+1;</div><div>                    </div><div>                }</div><div>                //等待所有的子任务结束后，合并计算结果</div><div>                for(CountTask task:subTaskList){</div><div>                    sum+=task.join();//join()会一直等待子任务执行完毕返回执行结果</div><div>                }</div><div>            }</div><div>            return sum;</div><div>        }</div><div>        </div><div>    }</div><div><br/></div><div><br/></div><div>        psvm(){</div><div>            //创建ForkJoinPool线程池</div><div>            ForkJoinPool forkJoinPool=new ForkJoinPool();</div><div>            //创建一个大的任务</div><div>            CountTask task=new CountTask(0L,200000L);</div><div>            //把大的任务提交给线程池</div><div>         ForkJoinTask&lt;Long&gt;result=   forkJoinPool.submit(task);</div><div>            try{</div><div>                Long res=result.get();//调用任务的get（）方法返回结果</div><div>                System.out.println(&quot;计算数列结果为：&quot;+res);</div><div>            }catch(){</div><div>            }</div><div>        }</div><div>}</div><div><br/></div><div><br/></div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">7、保障线程安全的设计技术</span></div><div><span style="font-weight: bold;">        </span></div><div><span style="font-weight: bold;">        </span></div><div><span style="font-weight: bold;">        从面向对象设计的角度出发介绍几种保障线程安全的设计技术，这些技术可以使我们在不比借助锁的情况下保障线程安全，避免锁可能导致的问题及开销。</span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-size: 12pt; font-weight: bold;">7、1 java运行时存储空间</span></div><div><br/></div><div>        Java运行时（Java runtime）空间可以分为栈区，堆区与方法区。</div><div>        </div><div>        <span style="font-weight: bold;">栈空间（Stack Space）</span>为线程的执行准备的一段固定大小的存储空间，每个线程都有独立的线程栈空间，创建线程时就为线程分配栈空间，在线程栈中每调用一个方法就给方法分配一个栈帧，栈帧用于存储方法的局部变量 ，返回值等私有数据，即局部变量是存储在栈空间当中的，基本类型变量也是存储在栈空间当中的，引用类型变量值也是存储在栈空间中，引用的对象存储在堆中，由于线程栈是相互独立的，一个线程不能访问另外一个线程的栈空间，因此线程对局部变量以及只能通过当前线程的局部变量才能访问的对象进行的操作具有固定的线程安全性。</div><div>        <span style="font-weight: bold;">堆空间（Heap Space</span>）用于存储对象，是在JVM启动时分配的一段可以动态扩容的内存空间，创建对象时，在堆空间 中给对象分配    存储空间，实例变量就是存储在堆空间中的，堆空间是多个线程之间可以共享的空间，因此实例变量可以被多个线程共享。<span style="font-size: unset; color: unset; font-family: unset;"> 多个线程同时操作实例变量可能存在线程安全问题。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">       </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">方法区（非堆空间</span><span style="font-size: unset; color: unset; font-family: unset;">）用于存储常量，类的元数据等，非堆空间也是在JVM启动时分配的一段可以动态扩容的存储空间，类的元数据包括静态变量，类有哪些方法即这些方法的元数据（方法名，参数，返回值等 ），非堆空间也是多个线程可以共享的，因此访问非堆空间中的静态变量也可能存在线程安全问题。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;"><span style="font-size: unset; color: unset; font-family: unset; font-weight: normal;">   </span> <span style="font-size: unset; color: unset; font-family: unset; font-weight: bold;">堆空间和非堆空间是线程可以共享的空间，即实例变量与静态变量是线程可以共享的，可能存在线程安全问题。栈空间是线程私有的存储空间，局部变量存储在栈空间中，局部变量具有固有的线程安全性。</span></span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-size: 12pt; font-weight: bold;">7.2 无状态对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;">    对象就是数据及对数据操作的封装，对象所包含的数据称为对象的状态，实例变量与静态变量称为状态变量。</span></div><div><span style="font-weight: bold;">    如果一个类的同一实例被多个线程共享并不会使这些线程存储共享的状态，那么改类的实例就成为无状态对象（Stateless Object）,反之，如果一个类的实例被多个线程共享会使这些线程存在共享状态，那么改类的实例就称为有状态对象，</span><span style="color: rgb(255, 0, 0); font-weight: bold;">实际上无状态对象就是不包含任何实例变量也不包含任何静态变量的对象。</span></div><div><br/></div><div><span style="font-weight: bold;">        线程安全问题的前提就是多个线程存在共享的数据，实现线程安全 的一种办法就是避免在多个线程之间共享数据，使用无状态对象就是这种方法。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">7、3不可变对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;">        不可变状态是指一经创建它的状态就保持不变的对象，不可变对象具有固定的线程安全性，当不可变对象现实实体的状态发生了变化时，系统会创建一个新的不可变对象，就如String字符串对象，一个不可变对象需要满足以下条件：</span></div><div><span style="font-weight: bold;">        1、类本身使用final修饰，防止通过创建子类来改变它的定义；</span></div><div><span style="font-weight: bold;">        2、所有的字段都是用final修饰的，final字段在创建对象时必须显示初始化，不能被修改</span></div><div><span style="font-weight: bold;">        3、如果字段引用了其他状态可变的对象（如集合，数组），组这些字段必须是Private私有的    </span></div><div><span style="font-weight: bold;">        </span></div><div><span style="font-weight: bold;">    不可变对象主要应用场景：</span></div><div><span style="font-weight: bold;">            1、被建模对象的状态变化不频繁</span></div><div><span style="font-weight: bold;">            2、同时对一组相关数据进行写操作，可以引用不可变对象，既可以保障原子性也可以避免锁的使用</span></div><div><span style="font-weight: bold;">            3、使用不可变对象作为安全可靠的Map键，HashMap键值对的存储位置与建的hashCode（）有关，如果键的内部状态发生了变化会导致键的哈希吗不同，可能会影响键值对的存储位置。如果HashMap的键是一个不可变对象，则hashCode()方法的返回值恒定，存储位置是固定的</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">7.4 线程特有对象</span></div><div><span style="font-weight: bold;">        我们可以选择不共享非线程安全的对象，对于非线程安全的对象，每个线程都创建一个该对象的实例，各个线程访问各自创建的实例。一个实例只能被一个线程访问的对象就称为线程特有对象。</span></div><div><span style="font-weight: bold;">        ThreadLocal&lt;T&gt;类相当于线程访问其特有对象的代理，即各个线程通过ThreadLocal对象可以创建并访问各自的线程特有对象，泛型T指定了线程特有对象的类型，一个线程可以使用不同的ThreadLocal实例来创建并访问不同的线程特有对象。</span></div><div><span style="font-weight: bold;"><img src="线程同步机制_files/Image [15].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">7.5 装饰器模式</span></div><div><br/></div><div>    装饰器模式可以用来实现线程安全，基本思想是为非线程安全额对象创建一个相应的线程安全的外包装对象，客户端代码不直接访问非线程安全的对象而是访问它的外包装对象，外包装对象与非线程安全的对象具有相同的接口，即外包装对象的使用方式与非线程安全对象的使用方式相同，而外包装对象内部通常会借助锁，以线程安全的方式调用非线程安全对象的方法。</div><div>    在java.util.Collections 工具类中提供了一组synchronizedXXX(xxx)可以把不是线程安全的xxx集合转换为线程安全的集合，它就是采用了这种装饰器模式。这个方法的返回值就是指定集合的外包装对象。这类集合又称为同步集合。</div><div>    采用装饰器模式的优势:</div><div>        1、关注点分离：在这种设计中，实现同一组功能的对象的两个版本：非线程安全的对象，与线程安全的对象。对于非线程安全的在设计是只关注要实现功能，对于线程安全的版本只关注线程安全性</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">8、锁的优化及注意事项</span></div><div><span style="font-size: 12pt; font-weight: bold;">    8.1 有助于提高锁的性能的几点建议：</span></div><div>            <span style="font-weight: bold;">1、 减少锁的持有时间</span></div><div>                对于使用锁进行并发控制的应用程序来说，如果单个线程持有锁的时间过长，会导致锁的竞争更加激烈，会影响系统的性能。</div><div><span style="font-weight: bold;">            2、减小锁的粒度</span></div><div>                一个锁保护的共享数据的数量大小称为锁的粒度，如果一个锁保护的共享数据量大就称该锁的粒度粗，负责就称该锁的粒度细，锁的粒度过粗会导致线程在申请锁的时候进行不必要的等待，</div><div>，减少粒度是一种削弱多线程锁竞争的一种手段。</div><div>    HashTable将整张Hash表锁起来，锁的粒度大。</div><div>          <span style="font-weight: bold;">  3、使用读写分离锁代替独占锁</span></div><div>        使用ReadWriteLock读写分离锁可以提高系统的性能，使用读写分离锁也是减少锁粒度的一种特殊情况。第二条建议是分割数据结构实现减小锁的粒度，那么读写锁是对系统功能点的分割。</div><div>        在多数情况都允许多个线程同时读，在写的使用采用独占锁，在读多写少的情况下，使用读写锁可以大大提高系统的并发能力。</div><div>            <span style="font-weight: bold;">4、锁分离</span></div><div>        将读写锁的思想进一步延伸就是锁分离，读写锁是根据读写操作功能上的不同进行了锁分离，根据应用程序功能的特点，也可以对独占锁进行分离，如java.util.concurrent.LinkedBlockingQueue   类中take（）与put（）方法分别从队头取数据，把数据添加到对尾，虽然这两个操作都是对队列进行修改操作，由于操作的主体是链表，take()操作的是链表的头部，put（）操作的是链表的尾部，两者并不冲突。如果采用独占锁的话，这两个操作不能同时并发，在该类中就采用锁分离，take（）取数据时有取锁，put添加数据时有自己的添加锁。</div><div>        <span style="font-weight: bold;">    5、粗锁化</span></div><div>        </div><div>        为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短。但是，如果对同一个锁不断的请求，同步和释放，也会消耗系统资源。</div><div>        例如：</div><div>            for(){</div><div>                synchronized{}</div><div>        }</div><div>        这种情况下，意味着每循环一次都需要申请锁和释放锁，可以更改为：</div><div>            synchronized{</div><div>            for(){}</div><div>    },增加锁的粒度</div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">8.2 JVM对锁的优化</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1、锁偏向</span></div><div>        锁偏向是一种针对加锁操作的优化，如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无需在做任何同步操作，这样可以节省有关锁申请的时间，提高了程序的性能。</div><div>        锁偏向在没有锁竞争的场合可以有较好的优化效果，对于锁竞争比较激烈的场景，效果不加。锁竞争激烈的情况下可能是每次都是不同的线程来请求锁，这时偏向模式就失效了</div><div><span style="font-size: 12pt; font-weight: bold;">2、轻量级锁</span></div><div>    如果锁偏向失败，JVM不会立即挂起线程，还会使用一种称为轻量级锁的优化手段。会将共享对象的头部作为指针，指向持有锁的线程的堆栈内部，来判断一个线程是否持有对象锁，如果线程获得轻量级锁成功，就进入临界区，如果获得轻量级锁失败，表示其他线程抢到了锁，当前线程的锁的请求就膨胀为重量级锁，当前线程就转为阻塞队列中，变为阻塞状态。</div><div>    偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁</div><div>    </div><div>    一个对象刚开始实例化时，没有任何线程访问它，它是可偏向的，也就是说它认为只可能有一个线程来访问它，所以当第一个线程来访问它时，他会偏向这个线程。偏向第一个线程，这个线程在修改对象头成为偏向锁时使用CAS操作，将对象头中ThreadId改成自己的ID，之后再访问这个对象时，只需要对比ID即可，一旦有第二个线程访问该对象，因为偏向锁不会主动释放，所以第二个线程可以查看对象的偏向状态，当第二个线程访问对象时，表示在这个对象上已经存在竞争了，检查原来持有对象锁的线程是否存活，如果挂了则将对象变为无锁状态，重新偏向自己，如果原来的线程依然存活，则马上执行原来线程的栈，检查该对象的使用情况，如果仍然需要偏向锁，则偏向锁升级为轻量级锁。</div><div>    轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对同一个锁的操作会错开，或者稍微等待一下（自旋）另外一个线程就会释放锁。当自选超过一定次数，或者一个线程持有锁，一个线程在自旋，又来第三个线程访问时，轻量级锁就会膨胀为重量级锁，重量级锁除了持有锁的线程外，其他的线程都阻塞。</div></span>
</div></body></html> 