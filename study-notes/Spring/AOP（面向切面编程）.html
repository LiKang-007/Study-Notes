<html>
<head>
  <title>AOP（面向切面编程）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2696"/>
<h1>AOP（面向切面编程）</h1>

<div>
<span><div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">一、动态代理：</span></div><div>        1、实现方式：1、JDK动态代理，使用jdk中Proxy，Method，InvocaitonHanderl创建对象，jdk动态代理要求目标类必须实现接口。</div><div>                         2、cglib动态代理，第三方工具库，创建代理工具，原理是继承。通过继承目标类，创建子类，子类就是代理对象。要求目标类不能是final的，方法也不能是final的。</div><div>        2、动态代理的作用：</div><div>                1&gt;在目标类源代码不改变的情况下，增加功能。</div><div>                2&gt;减少代码的重复</div><div>                3&gt;专注业务逻辑</div><div>                4&gt;解耦和，让业务功能和非业务功能分离</div><div>oop：面向对象编程</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">二、AOP</span></div><div>        面向切面编程，基于动态代理，可以使用jdk，cglib两种代理方式。</div><div>        AOP就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式去用动态代理。</div><div>    A：切面，给目标类增加的功能，就是切面。</div><div>                切面的特点：一般都是非业务方法，独立使用。</div><div>    O：面向，对着</div><div>    P：编程</div><div>        </div><div>        <span style="color: rgb(255, 0, 0); font-weight: bold;">面向切面编程要求：</span></div><div>            1&gt;需要在分析项目功能时，找出切面</div><div>            2&gt;合理的安排切面的执行时间</div><div>            3&gt;合理的安排切面执行的位置，在哪个类，哪个方法增加增强。</div><div>        <span style="color: rgb(227, 0, 0); font-weight: bold;">术语：</span></div><div>            1&gt;Aspect，切面，表示增强的功能，就是一堆代码，完成某些非业务功能，常见的切面有：日志，事务，统计信息，参数检查，权限验证。</div><div>            2&gt;JoinPoint，连接业务方法和切面的位置</div><div>            3&gt;Pointcut，切入点，指多个连接点方法的集合。</div><div>            4&gt;目标对象，给哪个类增加功能，哪个类就是目标对象。</div><div>            5&gt;Advice，通知，表示切面的功能执行的时间。</div><div>        描述一个切面三个关键的要素：</div><div>            1&gt;切面的功能代码，即切面干什么。</div><div>            2&gt;切面的执行位置，使用Pointcut表示切面执行的位置。</div><div>            3&gt;切面的执行时间，使用Advice表示时间，在目标方法之前，还是在目标方法之后。</div><div>    </div><div>    <span style="color: rgb(255, 0, 0); font-weight: bold;">AOP的实现</span></div><div>        aop是一个规范，是动态的一个规范化，一个标准</div><div>        aop的技术实现框架：</div><div>            1、spring：spring在内部实现了aop规范，能做aop的工作。spring主要在事务处理时使用aop，其他很少用spring的aop实现，因为spring的aop实现比较笨重</div><div>            <span style="color: rgb(255, 0, 0); font-weight: bold;">2、aspectJ：一个开源的专门做aop的框架。</span>spring框架集成了aspectj框架，通过spring就能使用aspectj的功能。</div><div>            </div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">aspectJ框架实现aop有两种方式：</span></div><div>        1、使用xml的配置文件</div><div>        2、使用注解，项目中一般都使用注解。</div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">三、aspectJ框架的使用</span></div><div><span style="font-weight: bold;"><span style="font-weight: bold; color: rgb(255, 0, 0);">    </span><span style="font-weight: bold; color: rgb(255, 0, 0);"> </span>   <span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1、切面的执行时间，这个执行时间在规范中叫做Advice（通知，增强）。</span></span></div><div><span style="font-weight: bold;">            aspectj框架中有五个注解</span></div><div><span style="font-weight: bold;">                    <span style="font-weight: bold; color: rgb(45, 79, 201);">@Before</span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                    @AfterReturning</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                    @Around</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                    @AfterThrowing</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                    @After</span></div><div>  <span style="font-weight: bold;"> </span> <span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">    2、表示切面执行的位置，使用的是切入点表达</span><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">式。</span></div><div><img src="AOP（面向切面编程）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="AOP（面向切面编程）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><img src="AOP（面向切面编程）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="AOP（面向切面编程）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="AOP（面向切面编程）_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">aspectJ框架使用步骤：</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [6].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">依赖项</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [7].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">aspectJ框架注解：    </span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">   </span> <span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1、@Aspect，是aspectj框架中的注解</span></div><div><span style="font-weight: bold;">              作用：表示当前类是切面类</span></div><div><span style="font-weight: bold;">              切面类：给业务方法增加功能的类，在这个类中有切面的功能代码。</span></div><div><span style="font-weight: bold;">              位置：类定义的上面</span></div><div><br/></div><div><span style="font-weight: bold;">        定义切面类中的方法，该方法要求：</span></div><div><span style="font-weight: bold;">                1&gt;公共方法public</span></div><div><span style="font-weight: bold;">                2&gt;方法没有返回值</span></div><div><span style="font-weight: bold;">                3&gt;方法名称自定义</span></div><div><span style="font-weight: bold;">                4&gt;方法可以有参数，也可以没有参数</span></div><div><span style="font-weight: bold;">           如果有参数，参数不是自定义的，有几个参数类型可以使用。</span></div><div><span style="font-weight: bold;">        指定方法的参数：JoinPoint</span></div><div><span style="font-weight: bold;">                </span><span style="font-weight: bold;">JoinPoint：业务方法，要加入切面功能的业务方法。</span></div><div><span style="font-weight: bold;">                    作用是：可以在通知方法中获取方法执行时的信息，例如方法的名称，方法的实参。</span></div><div><span style="font-weight: bold;">                                 如果切面功能中需要用到方法的信息，就加入JoinPoint</span></div><div><span style="font-weight: bold;">                                </span><span style="font-weight: bold;">JoinPoint参数的值是由框架赋予的，必须是第一个位置的参数</span></div><div><span style="font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [8].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">   <span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;"> </span><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">2、@Before：前置通知注解</span></span></div><div><span style="font-weight: bold;">                属性：value，是切入点表达式，表示切面的功能执行的位置。</span></div><div><span style="font-weight: bold;">                位置：方法的上面</span></div><div><span style="font-weight: bold;"><span><span>    </span><br/></span></span></div><div><span style="font-weight: bold;">                特点：</span></div><div><span style="font-weight: bold;">                        1&gt;在目标方法之前先执行</span></div><div><span style="font-weight: bold;">                        2&gt;不会改变目标方法的执行结果</span></div><div><span style="font-weight: bold;">                        3&gt;不会影响目标方法的执行</span></div><div><span style="font-weight: bold;">    </span></div><div><span style="font-weight: bold;">        将切面类交给spring容器</span></div><div><span style="font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [9].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;">&lt;aop:aspectj-autoproxy /&gt;标签会把spring容器中所有的目标对象一次性都生成代理对象。</span></div><div><br/></div><div><span style="font-weight: bold;">测试类</span></div><div><span style="font-weight: bold;"><img src="AOP（面向切面编程）_files/Image [10].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">    3、</span><span style="color: rgb(45, 79, 201); font-weight: bold;">@AfterReturning：后置通知</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                属性：1、value 切入点表达式</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                          2、returning 自定义的一个变量，表示目标方法的返回值。<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">自定义的变量名必须和通知方法的形参名一样.</span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                位置：在方法定义的上面</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                特点：1、在目标方法执行之后执行。</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">                          2、可以获取到目标方法的返回值，可以根据这个返回值做不同的业务逻辑。</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  3、可以修改这个返回值。</span><br/></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    4、</span>@Around：环绕通知-增强方法有ProceedingJoinPoint参数</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span><span> </span><span>方法定义格式：1&gt;public</span><br/></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    2&gt;必须有一个返回值，推荐使用Object</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    3&gt;方法名称自定义</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    4&gt;方法有参数，固定的参数<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  </span></span></span><span style="color: rgb(45, 79, 201); font-weight: bold;">ProceedingJoinPoint</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span><span>    属性：value 切入点表达式</span><br/></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    位置：方法定义的上面</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    特点：1、是功能最强的通知。</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    2、在目标方法的前和后都能增强功能。</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    3、控制目标方法是否被调用执行。</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    4、修改原来的目标方法的执行结果，影响最后的调用结果。（程序执行，是将目标方法替换为@Around修饰的方法）</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    环绕通知，等同于jdk动态代理的InvocationHandler接口</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    参数：ProceedingJoinPoint 就等同于Method</span><br/><span>    <span>    </span><span>    </span><span>    </span><span>    作用：执行目标方法</span></span></span></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    返回值：目标方法的执行结果，可以被修改。</span><br/></span></span></div><div><span style="color: rgb(45, 79, 201);"><b>ProceedingJoinPoint类继承JoinPoint，可以获取方法信息。</b></span></div><div><font color="#2D4FC9"><b><span>    环绕通知：</span>经常做事务，在目标方法之前开启事务，执行目标方法，在目标方法之后提交事务。</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Around(&quot;切入点表达式&quot;)</div><div>public Object myAround(ProceedingJoinPoint pr){</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    //实现环绕通知</span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    Object resul</span></span><span style="font-family: Monaco; font-size: 9pt;">t=null;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span>//目标方法之前</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span>//执行目标方法</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    result=pr.proceed();</span><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    return result;</span><br/></span></span></div><div><span>    </span><br/></div><div>}</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-family: Monaco;">自己的理解：前置通知，后置通知和环绕通知在实现上的区别</font></div><div><font face="Monaco">首先 </font>前置通知，后置通知和环绕通知都是使用InvocationHandler接口</div><div>前置通知，后置通知是框架定义好的，切面方法和目标方法在生成代理对象的时候，相当于方法的顺序拼接。</div><div>环绕通知则是将目标方法替换为@Around修饰的方法。</div></div><div><span>    5、</span><span style="color: rgb(45, 79, 201); font-weight: bold;">@AfterThrowing：异常通知</span><br/></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    方法定义格式：</span><br/></span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span></span><span style="font-weight: bold;"> <span>    </span> 1&gt;公共方法public</span></div><div><span style="font-weight: bold;">            <span>    </span>  2&gt;方法没有返回值</span></div><div><span style="font-weight: bold;">                  3&gt;方法名称自定义</span></div><div><span style="font-weight: bold;">                  4&gt;方法参数，</span><span style="font-weight: bold;">Exception</span><span style="font-weight: bold;">，如果还有就是</span><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;">JoinPoint。</span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    属性：1、value：切入点表达式</span><br/></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  2、throwing 自定义的变量，表示目标方法抛出的异常对象，变量名必须和方法的参数名一样</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    特点：</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    1&gt;在目标方法抛出异常时执行。</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    2&gt;可以做异常的监控程序，监控目标方法在执行时是不是有异常，如果有异常，可以发送邮件或者短信进行通知</span></span><span style="color: unset; font-family: unset; font-size: unset; font-weight: bold;">。</span></div><div><span style="color: unset; font-family: unset; font-size: unset; font-weight: bold;"><span>    6、</span></span><span style="color: rgb(45, 79, 201); font-weight: bold;"> @After：最终通知</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;"><span>    </span><span>    </span><span>    </span><span> </span></span><span style="color: rgb(45, 79, 201); font-weight: bold;">方法定义格式：</span></div><div><span style="color: rgb(45, 79, 201); font-weight: bold;">    </span><span style="color: rgb(45, 79, 201); font-weight: bold;">    </span><span style="color: rgb(45, 79, 201); font-weight: bold;">    </span><span style="font-weight: bold;"> </span><span style="font-weight: bold;">    </span> <span style="font-weight: bold;">1&gt;公共方法public</span></div><div><span style="font-weight: bold;">            </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">  2&gt;方法没有返回值</span></div><div><span style="font-weight: bold;">                  3&gt;方法名称自定义</span></div><div><span style="font-weight: bold;">                  4&gt;方法没有参数，如果有参数就是</span><span style="color: rgb(45, 79, 201); font-weight: bold;"><span> </span></span><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;">JoinPoint。<span>    </span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    属性：value：切入表达式</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    位置：方法的上面</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    特点：</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    1&gt;总是会执行</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    2&gt;在目标方法之后执行</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    </span><span>    一般做的是资源的清理工作。类似于finally语句块。</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    7、@Pointcut：</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    定义和管理切入点，如果在项目中存在多个切入点是重复的，可以复用的，可以使用</span></span><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;">@Pointcut</span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    属性：value：切入点表达式</span><br/></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><span>    </span><span>    </span><span>    位置：自定义的方法的上面</span><br/></span></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    特点：当使用了</span></span><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;">@Pointcut定义在一个方法的上面，此时这个方法的名称就是切入点表达式的别名，其他的通知中value属性就可以使用这个方法名称，代替切入点表达式。</span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span>    </span><span>    </span><span>    </span><br/></span></div><div><span style="font-weight: bold; color: unset; font-family: unset; font-size: unset;"><span><br/></span></span></div><hr/><div>在目标类存在接口时，使用的是jdk的动态代理；没有接口时，使用的是cglib动态代理。</div><div><span>    如果有接口时，要使用cglib动态代理：</span><br/></div><div><span>    </span><span>  </span><span style="font-weight: bold;">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;</span></div></div></span>
</div></body></html> 