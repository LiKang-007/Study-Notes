<html>
<head>
  <title>IOC（控制反转）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602916 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2668"/>
<h1>IOC（控制反转）</h1>

<div>
<span><div><div><div><div><div><br/></div><div>IOC：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">控制反转</span>，是一个理论，概念，思想。把对象的创建父子，管理工作都交给代码之外的容器实现，也就是对象的创建是由其他外部资源完成。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">控制：创建对象，对象的属性赋值，对象之间的关系管理。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">反转：把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。由容器代替开发人员管理对象，创建对象，给属性赋值。</span></div><div><br/></div><div>正转：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象。</div><div>容器：是一个服务器软件，一个框架。</div><div><br/></div><div>为什么使用ioc：目的是减少对代码的改动，也能实现不同的功能。</div><div><br/></div><div>java中创建对象的方式：</div><div>    1、构造方法；</div><div>    2、反射</div><div>    3、序列化</div><div>    4、克隆</div><div>    5、ioc</div><div>    6、动态代理</div><div><br/></div><div>ioc的体现：</div><div>        servlet：1、创建类继承HttpServlet</div><div>                        2、在web.xml中注册servlet</div><div>                        3、Servlet是Tomcat服务器创建的。Tomcat也成为容器。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>ioc的技术实现：</div><div>    DI：ioc的技术实现</div><div>    DI：依赖注入，只需要在程序中提供要使用的对象的名称就可以，至于对象如何在容器中创建，赋值，查找都由容器内部实现。</div><div>    spring是使用的di实现ioc的功能，spring底层创建对象，使用的是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">反射机制</span>。</div><div><br/></div><hr/><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第一个例子：（使用容器创建对象</span><span style="color: rgb(255, 0, 0);">）</span></div><div><img src="IOC（控制反转）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--Spring依赖--&gt;</div><div>&lt;dependency&gt;</div><div>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div>    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    </div><div>    &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;</div><div>&lt;/dependency&gt;</div></div><div>更改@test全称</div></div><div>Shift+F6</div><div><br/></div><div>在resources目录下加入spring的配置文件</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Spring配置文件介绍</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    1、beans：是根标签，spring把java对象称为bean。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    2、spring-beans.xsd是约束文件，和Mybatis指定的 dtd是一样的。</span></div><div>鼠标停留在 resources目录，Ait+insert---&gt;XML Configuration File---&gt;Spring Config----&gt;文件名起为：applicationContext</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">声明bean（告诉spring要创建某个类的对象）</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">id:对象的自定义名称，唯一值。spring通过这个名称找到对象。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">class：类的全限定名称（不能是接口，因为spring是反射机制创建对象，必须使用类）</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><img src="IOC（控制反转）_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;</span></div></div><div><br/></div><div>创建容器对象ApplicationContext</div><div><img src="IOC（控制反转）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">spring创建对象的时机：在读取配置文件</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">new ClassPathXmlApplicationContext(config);</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">的时候，就将对象创建完毕（调用无参构造），放入map，使用时取出对象。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><img src="IOC（控制反转）_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">获取容器中对象信息的api</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div> ApplicationContext ac=new ClassPathXmlApplicationContext(config);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//获取容器中定义对象的数量</span></div><div><font face="Monaco">int nums=ac.getBeanDefinitionCount();</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//获取容器中每个定义的对象的名称</span></div><div><font face="Monaco">String[] names=ac.getBeanDefinitionNames();</font></div><div><font face="Monaco">for(String name:names){</font></div><div><font face="Monaco">    System.out.println(name);</font></div><div><font face="Monaco">}</font></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">创建非自定义对象</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>和创建自定义对象相同，只要知道类的全限定名称。</div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; color: rgb(255, 70, 53); font-family: Monaco; font-weight: bold;">DI分为两类</span></div><div><span style="font-size: 12px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">1、基于XML的DI：</span></div><div><span style="font-size: 12px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">2、基于注解的DI：</span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;"><img src="IOC（控制反转）_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="font-size: 12px;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Monaco; font-weight: bold;">基于XML的DI：</span></font></div><div><span style="font-size: 12pt; color: rgb(134, 0, 164); font-family: Monaco; font-weight: bold;">设值注入：（给对象的属性赋值）</span></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">di的语法分类：</span></span></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">    1&gt;set注入（property标签只是执行类中的set方法）</span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14.6667px;"><b>1&gt;<font color="#FF0000">简单类型</font>的set注入</b></span></div><div><span style="font-size: 14.6667px;"><b>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</b></span></div><div><span style="font-size: 14.6667px;"><b>    &lt;!--一个property一次只能给一个属性赋值--&gt;</b></span></div><div><span style="font-size: 14.6667px;">    &lt;property name=&quot;属性名&quot; value=&quot;属性值&quot;&gt;&lt;!--set属性名(属性值)--&gt;</span></div><div>&lt;/bean&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>2&gt;引用类型</b></span></div><div>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div>    &lt;property name=&quot;属性名&quot; ref=&quot;bean的id&quot;&gt;&lt;!--set属性名(属性值)--&gt;</div><div>&lt;/bean&gt;</div></div><div><br/></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">    2&gt;构造注入</span></span></div><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">    </span><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">   <span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;"> </span></span><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">通过有参构造实现创建对象的同时传递参数。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;constructor-arg&gt;</div><div>&lt;!--一个&lt;constructor&gt;标签表示构造方法的一个参数--&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--</span>&lt;constructor&gt;标签属性<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--name:表示构造方法的形参名</span><span style="font-family: Monaco; font-size: 9pt;">--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--index:表示构造方法的参数的位置,参数从左往右是0,1,2的顺序--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--value:构造方法的形参是简单类型，使用value--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--ref:构造方法的形参是引用类型，使用ref--&gt;</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div>   &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;/&gt;</div><div>   &lt;constructor-arg name=&quot;&quot; ref=&quot;&quot;/&gt;</div><div>&lt;/bean&gt;</div><div>---</div><div>&lt;!--使用index属性--&gt;</div><div>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div>   &lt;constructor-arg index=&quot;0&quot; value=&quot;&quot;/&gt;</div><div>   &lt;constructor-arg index=&quot;1&quot; ref=&quot;&quot;/&gt;</div><div>&lt;/bean&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--省略index，赋值顺序必须和形参顺序一致--&gt;</span></div><div>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div>   &lt;constructor-arg  value=&quot;&quot;/&gt;</div><div>   &lt;constructor-arg  ref=&quot;&quot;/&gt;</div><div>&lt;/bean&gt;</div></div><div><br/></div></div><div><img src="IOC（控制反转）_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold;">引用类型的自动注入</span></div><div>    spring框架根据某些规则可以给引用类型赋值，不用手动给引用类型赋值。使用的规则常用的是byName，byType。</div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">byName（按名称注入）</span>：java类中引用类型的属性名和spring容器中（配置文件 ）&lt;bean&gt;的id名称一样并且数据类型是一致的，这样的容器中的bean ，spring能够赋值给引用类型。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--语法--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;byName&quot;&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    简单类型属性赋值</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;/bean&gt;</span></div></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">byType(按类型注入)</span>：java类中引用类型的数据类型和spring容器中 （配置文件）&lt;bean&gt;的class属性是同源关系的，这样的bean能够赋值给引用数据类型。<span style="font-weight: bold;">（符合条件的bean只能存在一个）</span></div></div><div>    同源：  1、java类中引用类型的数据类型和class的值是一样的。</div><div>                2、java类中引用类型的数据类型和bean的class的值是父子类关系。</div><div>                3、java类中引用类型的数据类型和bean的class的值是接口和实现类关系。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--语法--&gt;</div><div>&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;byType&quot;&gt;</div><div>    简单类型属性赋值</div><div>&lt;/bean&gt;</div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">使用多配置文件</span></div><div>    1、每个文件的大小比一个文件小很多，效率高。</div><div>    2、避免多人竞争带来的冲突。</div><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">多文件的分配方式：</span></div><div>        1&gt;按照项目的模块分开，一个模块配置一个配置文件。</div><div>        2&gt;按类的功能，数据库相关一个配置文件，事务一个配置文件，services一个配置文件。</div><div>    </div><div><span style="font-size: 10pt; color: rgb(255, 0, 0); font-weight: bold;">包含关系的配置文件</span></div><div>        <span style="font-weight: bold;">主配置文件</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--spring-tatal表示主配置文件：用来包含其他配置文件，一般不定义对象--&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">语法：</span><span style="font-family: Monaco; font-size: 9pt;">&lt;import resource=&quot;其他配置文件的路径&quot;&gt;</span></div><div><font face="Monaco">关键字：&quot;classpath:&quot;表示类路径（class文件所在的目录），在spring的配置文件中要指定其他文件的位置，需要告诉spring到哪去加载读取文件。</font></div><div><font face="Monaco">    注意：Maven编译生成的target目录下classes为类路径。</font></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;import resource=&quot;classpath:&quot;&gt;</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco"><b>在包含关系的配置文件中，可以使用通配符（*：表示任意字符）</b></font></div><div><font face="Monaco">&lt;import resource=&quot;classpath:bao/spring-*.xml&quot;&gt;</font></div><div><font face="Monaco">可以表示当前路径符合条件的配置文件。</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco"> <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">   </span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意： 主配置文件不能符合通配符的条件，否则会死循环。</span></font></div><div><font face="Monaco"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                使用通配符必须要在目录下。</span></font></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: Monaco; font-weight: bold;">基于注解的DI：</span></div><div><br/></div><div><span style="font-weight: bold;">一、使用注解的步骤：</span></div><div>        1、加入maven的依赖 spring-context，在你加入spring-context的同时，间接加入spring-aop的依赖。使用注解必须使用spring-aop依赖。</div><div>        2、在类中加入spring的注解（多个不同功能的注解）</div><div>        3、在spring的配置文件中，加入一个组件扫描器的标签，说明注解在项目中的位置。</div><div>        4、使用注解创建对象，创建容器ApplicationContext</div><div><span style="font-weight: bold;">二、相关的注解</span></div><div>        1、@Componten</div><div>        2、@Respotory</div><div>        3、@Service</div><div>        4、@Controller</div><div>        5、@Value</div><div>        6、@Autowired</div><div>        7、@Resource</div><div><span style="font-weight: bold;">三、在spring配置文件中声明组件扫描器</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--声明组件扫描器（component-scan），组件就是java对象</div><div>    base-package：指定注解在项目中的包名。</div><div> --&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--</span>component-scan工作方式：spring会扫描遍历base-package指定的包，把包和子包中的所有类，找到类中的注解，按照注解的功能创建对象，或者给属性赋值<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">--&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--这种方式原理是递归遍历文件夹--&gt;</span></div><div><b>&lt;context:component-scan base-package=&quot;&quot;/&gt;</b></div><div><b><br/></b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">&lt;!--加入了component-scan标签，配置文件的变化：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        1、加入了一个新的约束文件spring-context.xsd</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        2、给这个新的约束文件起个命名空间的名称</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">--&gt;</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>&lt;!--指定多个包的三种方式--&gt;</b></span></b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>&lt;!--第一种方式：使用多次组件扫描器，指定不同的包--&gt;</b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>&lt;!--第二种方式：使用分隔符（;或者,）分隔多个包名--&gt;</b></span></div><div>&lt;context:component-scan base-package=&quot;com.ba01;com.ba02&quot;/&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>&lt;!--第三种方式：指定父包--&gt;</b></span></div><div>&lt;context:component-scan base-package=&quot;com&quot;/&gt;</div><div>&lt;!--包的层数越高，扫描的文件越多，效率越低，建议满足项目需求就行--&gt;</div></div><div><br/></div><div><span style="font-weight: bold;">四、注解的介绍</span></div><div>     1、@Component：创建对象的，等同于&lt;bean&gt;的功能</div><div>                属性：value 就是对象的名称，也就是&lt;bean&gt;的id值</div><div>                          value的值是唯一的，创建的对象在整个spring容器中就一个。</div><div>                位置是：在类的上面。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Component(value=&quot;值&quot;)</div><div>@Component(&quot;值&quot;)</div><div>@Component()//不指定对象名称，由spring提供默认名称，默认名称为：类名的首字母小写</div></div><div><br/></div><div><span style="font-weight: bold;">    2、</span><span style="font-weight: bold;">@Respotory(用在持久层类的上面)：放在dao的实现类上面，表示创建dao对象，dao对象是能访问数据库的。</span></div><div><span style="font-weight: bold;">    3、</span><span style="font-weight: bold;">@Service(用在业务层类的上面)：放在Service的实现类上面，表示创建Service对象，Service是做业务处理，可以有事务等功能的。</span></div><div><span style="font-weight: bold;">    4、</span><span style="font-weight: bold;">@Controller(用在控制器上面)：放在控制器（处理器）类的上面，创建控制器对象的，能够接收用户提交的参数，显示请求的处理结果。</span></div><div><br/></div><div><span style="font-weight: bold;">2/3/4注解的使用语法和</span><span style="font-weight: bold;">1、@Component是一样的。都能够创建对象，但是这三个注解还有额外的功能。</span></div><div><span style="font-weight: bold;">@Respotory 、</span><span style="font-weight: bold;">@Service、 </span><span style="font-weight: bold;">@Controller是给项目的对象分层的。</span></div><div><br/></div><div><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(134, 0, 164); font-family: Monaco; font-weight: bold;">设值注入：（给对象的属性赋值）</span></span></div><div><span style="font-family: Monaco; font-weight: bold;">  5、@Value（简单类型属性赋值）</span></div><div><span style="font-family: Monaco;">           </span> <span style="color: rgb(222, 87, 0); font-family: Monaco; font-weight: bold;">属性：</span><span style="font-family: Monaco;">value 是String类型的，表示简单属性的属性值</span></div><div><span style="font-family: Monaco;">           </span> <span style="color: rgb(222, 87, 0); font-family: Monaco; font-weight: bold;">位置：</span><span style="font-family: Monaco;">1、在属性定义上面，无需set方法，推荐使用。</span></div><div><span style="font-size: 10pt; font-family: Monaco;">                      2、在set方法上面</span></div><div><span style="font-weight: bold;">  6、@Autowired（引用类型赋值）</span></div><div>            <span style="color: rgb(250, 122, 0); font-weight: bold;">介绍：</span>spring框架提供的注解，实现引用数据类型的赋值。</div><div> spring通过注解给引用类型赋值，使用的是<span style="font-weight: bold;">自动注入原理</span>。支持byName，byType。</div><div>            @Autowired默认使用的是byType自动注入。</div><div>            <span style="color: rgb(250, 122, 0); font-weight: bold;">位置：</span>1、在属性定义的上面，无需set方法，推荐使用。    </div><div>                      2、在set方法上面。</div><div>            如果要使用byName自动注入。</div><div>                1、在属性上面加入@Autowired</div><div>                2、在属性上面加入@Qualifier(value=&quot;bean的id&quot;)：表示使用指定名称的bean完成赋值。</div><div>（这两个注解没有先后顺序，但习惯先写@Autowired）</div><div>          <span style="color: rgb(250, 122, 0);"> </span> <span style="color: rgb(250, 122, 0); font-weight: bold;">属性：</span> required，是一个 Boolean类型，默认为true；</div><div>           required=true;表示引用数据类型赋值失败，程序报错，并终止执行。</div><div>           required=flase;表示引用数据类型赋值失败，程序正常执行，该引用数据类型为NULL。 </div><div>        <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">推荐为true，会尽早暴露程序当中的错误。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注：</span><span style="font-size: 14px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;-evernote-highlight:true;">在使用@Autowired时，首先在容器中查询对应类型的bean</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;-evernote-highlight:true;">　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false</span></div><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">7、@Resource</span><span style="font-weight: bold;">（引用类型赋值）</span></div><div>                介绍：来自JDK中的注解，spring提供了对这个注解的功能支持，可以使用它给引用数据类型赋值。使用的是自动注入原理，支持byName，byType，默认是byName。</div><div>            默认是先使用的是byName自动注入，如果byName赋值失败，再使用byType。</div><div>            只使用byName，需要增加一个属性 name，name的值是bean的id（名称）。</div><div>                位置：1、在属性定义的上面，无需set方法，推荐使用。</div><div>                            2、在set方法上面。</div><div>                </div><div><span style="font-weight: bold;">五、创建容器ApplicationContext</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ApplicationContext ac=new ClassPathXmlApplicationContext(config);</div><div>//获取容器中定义对象的数量</div><div>int nums=ac.getBeanDefinitionCount();</div><div>去//获取容器中每个定义的对象的名称</div><div>String[] names=ac.getBeanDefinitionNames();</div><div>for(String name:names){</div><div>    System.out.println(name);</div><div>}</div></div><div><br/></div><div><br/></div></div><div>XML配置文件和注解的对比    </div><div>        XML配置文件：依赖注入和代码完全分离，解耦和程度高，更改方便。缺点是代码量太多。</div><div>        注解：便于开发，快捷，缺点是更改困难。</div><div><br/></div><div>ioc实现解耦和：ioc能够实现业务对象之间的解耦和，例如service和dao对象之间的解耦和。</div><div><br/></div><div><br/></div></span>
</div></body></html> 